#+TITLE: My Vanilla Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes :results none
#+STARTUP: fold

* README (Intro)
Whenever this file is saved from my emacs, =init.el= and =early-init.el= are automatically generated based on it. Check [[*Automatically tangle this file (Emacs.org)]] for logic that does this.

Even though =init.el= and =early-init.el= are generated, I still keep them in version control (git), because it helps me avoid the situation where I don't have them on disk (maybe I deleted them, or I did fresh checkout) and can't easily start emacs and evaluate this very org file in order to generate them! By keeping them in version control, I have easy access to them, and I can even more easily see the diffs that were done.

Sometimes manual setup is needed for certain parts of this config to work, for example installing external dependencies or setting up API keys -> settings local to the machine. In such case, you will find instructions how to do it spread through this file, and they will be labeled with =manual_setup= org label.

** NOTE: Splitting (use-package) declarations into multiple org code blocks
This can be useful in order to nicely group and document the code. In this case, best way to do this is to use =(with-eval-after-load 'packagename <code that would normally go under :config>)=, for code that would go under =:config=, which is usually what we need, this is better then having multiple =(use-package ...)= declarations for the same package, because those can allegedly mess up with each other then.

* Preamble (must go first)
** Lexical binding
This has to be first line in the file (in this case init.el) for lexical binding to be enabled!

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

** Timestamps
I am actually not sure how useful is this but I found it fun.

#+name: timestamp
#+begin_src emacs-lisp :tangle no :results value none
  (format-time-string "%Y-%m-%d %H:%M:%S %Z")
#+end_src

#+begin_src emacs-lisp :tangle ./early-init.el :noweb yes
  ;; NOTE: This file was generated from Emacs.org on <<timestamp()>>, don't edit it manually.

#+end_src

#+begin_src emacs-lisp :tangle ./init.el :noweb yes
  ;; NOTE: This file was generated from Emacs.org on <<timestamp()>>, don't edit it manually.

#+end_src

* Package management
** Tutorial
*** package.el vs use-package vs elpaca

There are three important "packages" to understand here: package.el, use-package, and elpaca.

- **package.el** is a default package manager (like e.g. cabal for Haskell) that comes with emacs.
- **use-package** is a third-party package that allows for nicer, declarative and performant way to define your package configurations.
  It uses package.el in the background to install packages, but it is not a package manager, instead it is a layer above it that is focused on loading and configuring packages (and not installing, that it delegates to package manager).
- **elpaca** is a third-party package that is a package manager, a direct alternative to package.el, but more powerful / performant. Instead of downloading tarballs from .e.g melpa, it pulls package sources directly from their git repos.

In this config I use elpaca + use-package (package.el is not even loaded).

*** Installing vs loading vs configuring packages

- Installing package means downloading (and building) the package to your machine, so it can be loaded when you want.
  This is what package manager does for you.
- Loading package means importing/requiring it in our emacs config (init.el), so it can be used. It needs to be installed first in order to be loaded (unless it comes with emacs already).
  This is what use-package takes care of.
- Configuring means exactly that: adapting the package to your needs by defining variables, key bindings, hooks, ... .
  use-package also helps with this, giving us structure and reducing boilerplate.

*** Lifecycle of a package

1. Installation typically happens when you start emacs for first time on new machine, or when you update packages or add new package.
2. Loading typically happens each time you start emacs, and it can happen immediately on init, or it can happen later, on demand,
   when package is needed (in lazy fashion), depending on how you set it up for that package.
3. Configuration typically happens right after loading.

*** use-package

The idea is that you organize all your code in `(use-package <package-name> ...)` declarations.
There is even `(use-package emacs ...)` where `emacs` is a special "package" that won't trigger any installation or loading, allowing you to put general emacs config under it (e.g. `(column-number-mode)`).

use-package has a bunch of keywords that you can use to configure your package or define how it is loaded / installed.
Mostly you will use keywords that come with use-package, but other packages can also extend use-package with their own keywords.
I will quickly explain some of the more important/confusing ones:
- :ensure -> This is really an interface toward package manager (who does package installation). Any value passed to :ensure is passed to the package manager as instructions for installation, e.g. `:ensure (:host "github" :repo "user/repo")`.
    Therefore, its behaviour depends on the package manager used. But generally, `:ensure nil` will not allow package installation, while `:ensure t` or any other value will try to do install package if not installed yet. Should be really named :ensure-installed hah.
    Normally you will want `:ensure t` for most of the packages, in which case you can (I do) configure use-package to have it be `t` by default.
    When using elpaca, you can pass elpaca recipe to :ensure.
- :defer -> `:defer t` tells use-package to postpone loading of the package till it is needed (lazy). See "deferred loading" below.
    Alternatively, you can pass it a number of seconds emacs needs to be idle before package is loaded.
- :demand -> Opposite of defer, `:demand t` tells use-package to load package now. Useful when using autoload keywords (see "deferred loading" below).
- :init -> happens right before package is loaded.
- :config -> happens right after package is loaded.
- ...

**** Deferred loading 

It is generally recommended to postpone/defer loading of packages till they are needed (if applicable), for faster emacs startup.

use-package will defer loading of packages if `:defer <non-nil>` is set, or if any of the keywords with the "autoloading side effect" are used (e.g. `bind`, `command`, `hook`, ... : these all will make use-package defer loading and then autoload package once corresponding binding / command / hook / ... has happeend).

If you use any of the "autoload" keywords but don't want use-package to be "smart" and assume you want autoloading, you can use `:demand t`.

It can be good practice to add `:defer t` even when autoloading keywords are used, to be explicit about the intention.

*** elpaca
Elpaca can install package directly: `(elpaca some-package (message "this happens after package is installed"))`, but we use it via use-package.
In the background, a call to `(use-package some-package :ensure t :some-keyword <smth>)` becomes `(elpaca some-package (use-package some-package :some-keyword <smth>))`.

Compared to native package.el, that pulls in tarballs from package repos, Elpaca (and also Straight) work in a different way -> they pull package sources directly from their github repos, based on the "recipes", which say for each package where to pull from (and optionally how to build them).

**** Recipes

Elpaca allows you to define how the package should be installed via a `recipe`, which is provided as an argument to `:ensure` if using `use-package`.
Example of a recipe: `(some-package :host github :repo "user/example")`.

**** Deferred installing

Elpaca, unlike package.el, doesn't install packages immediately, instead it waits for emacs init to finish, and then installs them asynchronously, in parallel for fast, non-blocking installations.

To prevent this behaviour and make elpaca install package right now, when the corresponding `use-package` declaration is evaluated, one can pass `:wait t` keyword do the elpaca recipe: `:ensure (:wait t ...)`.
This can be useful for packages that e.g. add keywords to use-package, since you need those installed and loaded first.

Due to elpaca's deffered installing, instead of installing and loading happening during init phase (evaluation of init.el), we have following order of events: init -> installation of packages -> loading packages.
Exception are packages with `:wait t` in their recipe, those will get installed / loaded at init.
That also means that `after-init-hook` is often not the right choice any more, and we should instead use `elpaca-after-init-hook`, which will guarantee packages are installed / loaded.

** Config
*** Disable package.el (in early-init.el)

#+begin_src emacs-lisp :tangle ./early-init.el

  (setq package-enable-at-startup nil) ; Elpaca requires this.

#+end_src

*** Install and set up Elpaca (in init.el)

#+begin_src emacs-lisp

  (defvar elpaca-installer-version 0.10)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1 :inherit ignore
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
        (build (expand-file-name "elpaca/" elpaca-builds-directory))
        (order (cdr elpaca-order))
        (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                    ,@(when-let* ((depth (plist-get order :depth)))
                                                        (list (format "--depth=%d" depth) "--no-single-branch"))
                                                    ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))

#+end_src

*** Set up elpaca lock file

Here we set the elpaca lock file, so that, when installing packages, Elpaca will inherit recipes from =elpaca-lock-file=, where recipes contain exact version control references. Meaning that exact versions of packages as in the lock file are installed each time, ensuring consistency.

#+begin_src emacs-lisp

  (setq elpaca-lock-file (expand-file-name "elpaca-lock.eld" user-emacs-directory))

  (defun my/elpaca-write-lock-file ()
    (interactive)
    (elpaca-write-lock-file elpaca-lock-file)
  )

#+end_src

**** TODO Make updating of lock file automatic (advice on relevant elpaca functions?)
*** Install and set up use-package (with Elpaca as backend)

#+begin_src emacs-lisp

  (elpaca elpaca-use-package (elpaca-use-package-mode)) ; Install/setup use-package.
  (setq use-package-always-ensure t) ; Tells use-package to have :ensure t by default for every package it manages.

#+end_src

** Cheatsheet :cheatsheet:
- ~elpaca-manager~ to run the main elpaca UI.
- ~elpaca-update-all~ to fetch package updates and apply them.
- To create/update a lock file, run ~my/elpaca-write-lock-file~.
- *NOTE*: When lock file is set via ~elpaca-lock-file~ var, it is always used for obtaining the package recipes, and that prevents us from updating the packages. Commands like ~elpaca-update~ and similar will just use the version from the lock file. So if I indeed want to update the package, I need to turn off the lock file (e.g. by temporarily commenting-out the setting of ~elpaca-lock-file~ var) and then doing the update of the package.
* Utils
** Packages

#+begin_src emacs-lisp

  (require 'cl-lib) ;; Common utilities and functions, e.g. cl-some, cl-loop, ... .

  ;; Package for displaying content in a nice inline overlay.
  ;; I use it in the rest of the config in some place(s).
  (use-package quick-peek)

#+end_src

** Vars

#+begin_src emacs-lisp

  (defun my/var-state (var)
    "Returns the value of a variable with specified name, or 'my/var-unbound if it is not bound."
    (if (boundp var) (symbol-value var) 'my/var-unbound)
  )

  (defun my/local-var-state (var)
    "Returns the value of a buffer-local variable with specified name, or 'my/var-unbound if it is not bound."
    (if (local-variable-p var) (symbol-value var) 'my/var-unbound)
  )

  (defun set-local (var value)
    "Like setq-local but takes a var symbol (analogous to setq and set)."
    (set (make-local-variable var) value)
  )

#+end_src

*** Saving and restoring buffer-local vars

#+begin_src emacs-lisp

  (defun my/save-local-var-state (var)
    "Save the current state of buffer-local VAR (symbol) and return a lambda that restores VAR to its original state.
  USAGE:
    (let ((restore-foo (my/save-local-var-state 'foo)))
      ...
      (funcall restore-foo)
    )"
    (let ((og-state (my/local-var-state var)))
      (lambda ()
        (if (eq og-state 'my/var-unbound)
  	(kill-local-variable var)
        (set-local var og-state)
      )
      )
    )
  )

  (defun my/save-local-vars-state (vars)
    "Like my/save-local-var-state but takes a list of vars.
  USAGE:
    (let ((restore-vars (my/save-local-vars-state '(foo bar buzz))))
      ...
      (funcall restore-vars)
    )"
    (let ((restore-fns (mapcar #'my/save-local-var-state vars)))
      (lambda () (dolist (restore-fn restore-fns) (funcall restore-fn)))
    )
  )

  (defun my/set-local-vars-with-restore (vars-and-values)
    "Set each variable in VARS-AND-VALUES as a buffer-local variable with the specified value.
  Returns a lambda that, when called, restores each variable to its original buffer-local state.
  VARS-AND-VALUES should be a list of (VAR . VALUE) pairs.
  USAGE:
    (let ((restore-vars (my/save-local-vars-with-restore '((foo . 42) (bar .  t)))))
      ...
      (funcall restore-vars)
    )"
    (let* ((vars (mapcar #'car vars-and-values))
  	 (restore-fn (my/save-local-vars-state vars)))
      (dolist (var-and-value vars-and-values)
        (let ((var (car var-and-value))
  	    (value (cdr var-and-value)))
  	(set-local var value)
        )
      )
      restore-fn
    )
  )

#+end_src

** Modes
*** Saving and restoring

#+begin_src emacs-lisp

  (defun my/save-mode-state (mode)
    "Save the current state (enabled or disabled) of MODE (symbol) and return a lambda that restores MODE to its original state.
  USAGE:
    (let ((restore-evil-local-mode (my/save-mode-state 'evil-local-mode)))
      ...
      (funcall restore-evil-local-mode)
    )"
    (let ((og-mode-var-state (my/var-state mode)))
      (lambda ()
        (when (not (eq og-mode-var-state 'my/var-unbound))
          (funcall mode (if (eq og-mode-var-state nil) -1 1))
        )
      )
    )
  )

  (defun my/save-modes-state (modes)
    "Like my/save-mode-state but takes a list of modes.
  USAGE:
    (let ((restore-modes (my/save-modes-state '(evil-local-mode org-tidy-mode))))
      ...
      (funcall restore-modes)
    )"
    (let ((restore-fns (mapcar #'my/save-mode-state modes)))
      (lambda () (dolist (restore-fn restore-fns) (funcall restore-fn)))
    )
  )

  (defun my/set-modes-with-restore (modes-and-values)
    "Set each mode in MODES-AND-VALUES with the specified value.
  Returns a lambda that, when called, restores each mode to its original state (enabled/disabled).
  MODES-AND-VALUES should be a list of (MODE . VALUE) pairs.
  USAGE:
    (let ((restore-modes (my/save-modes-with-restore '((evil-local-mode . -1) (org-tidy-mode . 1)))))
      ...
      (funcall restore-modes)
    )"
    (let* ((modes (mapcar #'car modes-and-values))
  	 (restore-fn (my/save-modes-state modes)))
      (dolist (mode-and-value modes-and-values)
        (let ((mode (car mode-and-value))
  	    (value (cdr mode-and-value)))
  	(funcall mode value)
        )
      )
      restore-fn
    )
  )

#+end_src

** List

#+begin_src emacs-lisp

  (defun random-atom (xs)
    "Returns a random atom from the given list."
    (nth (random (length xs)) xs)
  )

#+end_src

** Quotes

#+begin_src emacs-lisp

  (defvar my-motivational-quotes
    '("\"You have power over your mind – not outside events. Realize this, and you will find strength.\" – Marcus Aurelius"
      "\"First say to yourself what you would be; and then do what you have to do.\" – Epictetus"
      "\"Waste no more time arguing about what a good man should be. Be one.\" - Marcus Aurelius"
      "\"No man is free who is not master of himself.\" – Epictetus"
      "\"Well-being is attained by little and little, and nevertheless is no little thing itself.\" – Zeno of Citium"
      "\"Don’t explain your philosophy. Embody it.\" - Epictetus"
      "\"No great thing is created suddenly.\" – Epictetus"
      "\"Begin at once to live, and count each separate day as a separate life.\" – Seneca"
      "\"Dwell on the beauty of life. Watch the stars, and see yourself running with them.\" – Marcus Aurelius"
      "\"Nulla dies sine linea.\" - Pliny the Elder"
      )
  )

#+end_src

** Other

#+begin_src emacs-lisp

  (defun my/is-face-at-point (face)
    "Returns non-nil if given FACE is applied at text at the current point."
    (let ((face-at-point (get-text-property (point) 'face)))
      (or (eq face-at-point face) (and (listp face-at-point) (memq face face-at-point)))
    )
  )

#+end_src

* Basic Emacs config
** General

#+begin_src emacs-lisp

  (use-package emacs
    :ensure nil
    :config
    (setq inhibit-startup-message t)
    (defun display-startup-echo-area-message () (message nil))
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (menu-bar-mode -1)
    (setq ring-bell-function 'ignore)
    (set-fringe-mode 10)
    (setq-default fill-column 100)
    (column-number-mode) ; Show row:column in mode line.
    (visual-line-mode 1) ; Treat wrapped lines as multiple lines when moving around.
    (global-hl-line-mode 1) ; Highlights the line in which cursor is.
    (global-auto-revert-mode t) ; Automatically reload files if they change on disk (will ask if conflict).
    (add-hook 'window-setup-hook 'toggle-frame-fullscreen t) ; Start in fullscreen.
    (setq-default indent-tabs-mode nil) ; Don't use tabs when indenting.
    (delete-selection-mode t) ; Delete the selection with a keypress.

    ;; Sets default font (at size 10). I use Monaspace font (Neon variant) which was created by
    ;; "Github Next" -> Github's dev tools research team. I specifically installed otf "frozen"
    ;; version that comes with all the goodies baked in (check below under Manual Setup).
    ;; Some other nice fonts: "RobotoMono Nerd Font" (best right after Monaspace),
    ;; "Source Code Pro", "Noto Sans Mono".
    ;; NOTE: Monaspace has very cool "texture healing" feature where some letters are widened or narrowed
    ;;   when there is space due to the neighbouring letters, but Emacs doesn't (yet, there is a todo))
    ;;   support OTF's "contextual alternate" feature that is needed for this.
    ;;   If it does support it one day, I should enable it to reap all the benefits of Monaspace font.
    (set-face-attribute 'default nil :family "Monaspace Neon" :height 100)

    (setq gc-cons-threshold 100000000) ; Default is low, so we set it to 100mb. Helps with e.g. lsp-mode.
    (setq read-process-output-max (* 1024 1024)) ;; Default is low, so we set it to 1mb. Helps with e.g. lsp-mode.

    (setq initial-major-mode 'org-mode) ; Start Scratch buffer with Org mode.
    (setq initial-scratch-message (concat "# " (random-atom my-motivational-quotes) "\n\n"))

    (global-subword-mode) ; Makes vim motions treat subwords in camelCase as individual words.

    ;; Emacs by default creates different kinds of additional files on the disk while editing.
    ;; While they can be useful in theory, I found that I don't have much need for any of them,
    ;; while on the other hand they litter the disk and are a potential security issue if they contain
    ;; sensitive information copied from the files that were being edited.
    (setq make-backup-files nil) ; I either have files version controlled or I will manually create backup.
    (setq auto-save-default nil) ; I save so often myself that I don't have a need for this.
    (setq create-lockfiles nil) ; I don't have a situation where multiple emacses want to edit the same file.

    (setq custom-file "/dev/null") ; Prevent emacs from adding `customize` system choices to my init.el.
  )

#+end_src

*** Install the fonts                                        :manual_setup:
For Emacs to be able to use any font, it needs to be installed on your machine.
To install on Archlinux:
 - Monaspace: ~sudo pacman -S otf-monaspace~ -> This "otf" version comes with all the goodies (ligatures, ...) baked in (a "frozen" variant).

** Pretty startup

#+begin_src emacs-lisp :tangle ./early-init.el

  ;; I had emacs window appearing at the very start, for a short time (~0.5-1s), as a small window with white background,
  ;; before the config from init.el (or even early-init.el) is applied.
  ;; Usual advice of setting the `(background . "black")` in early-init.el didn't help, that would happen after it.
  ;; From what I got, the problem is that window is white because Emacs doesn't have control yet, GTK does, and
  ;; by default it shows white window.
  ;; I solved that at the end by setting `(visibility . nil)`, and then when emacs progresses enough, by explicitly
  ;; calling `make-frame-visible` (otherwise it would remain invisible forever).
  ;; This hides the window until init.el is loaded, which means now wait time is longer before first render, ~2s,
  ;; but there is no flashing and sudden changes.
  (setq initial-frame-alist '(
    (visibility . nil)
    (undecorated . t)
    (menu-bar-lines . 0)
    (tool-bar-lines . 0)
    (fullscreen . maximized)
  ))
  (add-hook 'emacs-startup-hook (lambda () (make-frame-visible (selected-frame))))

#+end_src

** GPG

#+begin_src emacs-lisp

  (use-package epg-config
    :ensure nil ; emacs built-in
    :config
    ; Makes emacs query the passphrase via minibuffer, instead of external program.
    (setq epg-pinentry-mode 'loopback)
  )

#+end_src

** plstore

=plstore= is a library for storing elisp plists on disk, in a file. It also encrypts them.
Some emacs packages use it.

#+begin_src emacs-lisp

    (use-package plstore
      :ensure nil ; emacs built-in
      :config
      ; Stops plstore from asking for passphrase many times, instead it caches it and reuses it.
      ; NOTE: If this stops working, alternative is to set it to use GPG key for encryption.
      ;       Check plstore code for instructions on this if it will ever be needed.
      (setq-default plstore-cache-passphrase-for-symmetric-encryption t)
    )

#+end_src

* Theme

#+begin_src emacs-lisp

  ;; doom-themes have nice, high quality themes.
  (use-package doom-themes
    :ensure (:wait t) ; Too ensure theme gets loaded as early as possible, so there is no white scren.
    :config
    ;; I went with moonlight for now. palenight is also nice. city-lights is also not bad. Also tomorrow-night.
    ;; TODO: Figure out where and how is the best way to do theme customization. I am guessing it shoudl be happening in a central place,
    ;;   even if it is about other packages faces, and that it should happen next to loading of the theme?
    (load-theme 'doom-moonlight t)
  )

  ;; Nice themes by Prot.
  ;; `ef-dream' is nice, also `ef-night'.
  (use-package ef-themes
    :ensure (:wait t) ; Too ensure theme gets loaded as early as possible, so there is no white scren.
  )

#+end_src

* Modeline

#+begin_src emacs-lisp

  ;; TODO: Configure better or use some other modeline.
  (use-package doom-modeline
    :custom
    (doom-modeline-height 40)
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-minor-modes nil)
    :config
    (doom-modeline-mode 1)
  )

#+end_src

* Undo
** Increase undo memory limits

#+begin_src emacs-lisp

  (use-package emacs
    :ensure nil
    :config
    ;; Default emacs undo limits are quite low so we increase them here.
    (setq undo-limit         50000000) ; ~50mb.
    (setq undo-strong-limit 100000000) ; ~100mb.
    (setq undo-outer-limit  300000000) ; ~300mb.
  )

#+end_src

** undo-fu: "normal" undo behaviour

**undo-fu** is a simple package that brings undo/redo commands that behave in a simple, linear fashion, like you would expect.
However, it still keeps emacs' undo/redo complex system intact with all the state it keeps, these commands just serve as a simpler interface toward it, so you can still interact with it if you wish (e.g. with vundo which visualizes the undo state as tree).
I don't set any keybindings here because it is enough to set undo-fu as evil's undo system (check my evil config) and then evil uses it.

#+begin_src emacs-lisp

  (use-package undo-fu
    :config
    (setq undo-fu-ignore-keyboard-quit t) ; I don't want C-g to trigger normal emacs undo behavior.
  )

#+end_src

** vundo: undo tree

#+begin_src emacs-lisp

  ;; Displays undo history as a tree and lets you move through it.
  (use-package vundo
    :defer t
    :config
    (setq vundo-glyph-alist vundo-unicode-symbols)

    ;;;;;; Vundo Live Diff ;;;;;;
    ;; In vundo, you have to manually mark one node and call diff on another node to get their diff.
    ;; Here we extend vundo to have "live diff mode", that always shows diff between current node and its parent.
    ;; I turn it on by default. It can be toggled by pressing "F".
    (defun vundo-live-diff-post-command ()
      "Post command hook function for live diffing."
      (when (not (memq this-command '(vundo-quit vundo-confirm)))
        (progn
          (vundo-diff-mark (vundo-m-parent (vundo--current-node vundo--prev-mod-list)))
          (vundo-diff)
        )
      )
    )
    (define-minor-mode vundo-live-diff-mode
      "Shows live diff between the current node and its parent."
      :lighter nil
      (if vundo-live-diff-mode
        (add-hook 'post-command-hook #'vundo-live-diff-post-command 0 t)
        (remove-hook 'post-command-hook #'vundo-live-diff-post-command t)
      )
    )
    (evil-define-key 'normal vundo-mode-map (kbd "F") #'vundo-live-diff-mode)
    (add-hook 'vundo-mode-hook (lambda () (vundo-live-diff-mode 1)))
    ;;;;;/ Vundo Live Diff ;;;;;;
  )

#+end_src

** TODO Install undo-fu-session?
Do I need persistent undo between the emacs sessions? I think not?
** TODO Install undo-hl (highlights changes by undo in buffer)?
Seems to not be on any package manager though, so I need straight.el probably.

* Keybindings
** general.el

#+begin_src emacs-lisp

  ;; general.el provides convenient, unified interface for key definitions.
  ;; It can do many cool things, one of them is specifying leader key and prefixes.
  ;; For best results, you should do all/most of the key defining via general (e.g. `general-define-key`).
  ;; NOTE: I found general.el to be really complex, and I haven't invested the time to properly understand it.
  ;;   Therefore, I don't completely understand if the config below is written in the best way, but
  ;;   it was recommended by others and it seems to work.
  (use-package general
    :ensure (:wait t) ; Load it immediately, so that I can use :general keyword in use-package declarations below if I want.
    :config
    (general-evil-setup t)

    ;; Here we use the following two expressions to create a function ~my/leader-keys~ that we can then use to created
    ;; new keys that all start with SPC prefix (leader key).
    (general-define-key
      :prefix-map 'my/leader-map
      :states '(motion normal insert visual emacs)
      :keymaps 'override ; Override any other keymaps with same keybindings. Otherwise I get issues with the `motion` and SPC, since `motion` already defines keybindings for SPC.
      :prefix "SPC" ; This will be active only in "normal"-like states (so `normal`, `motion` and `emacs`).
      :global-prefix "C-SPC" ; This will be always active.
    )
    (general-create-definer my/leader-keys
      :keymaps 'my/leader-map)

    ;; TODO: Also, should I use :general keyword in use-package? Figure this out, the best way to define keybindings with SPC prefix,
    ;;   should they all be here, or in their respective packages, or what.
    (my/leader-keys
      "SPC" '("M-x (exec cmd)" . counsel-M-x)
      "TAB" '("previous buffer" . my/alternate-buffer)
      "RET" '("work diary" . (lambda () (interactive) (org-agenda nil "d")))

      "^"   '("top-level keybindings" . which-key-show-top-level)

      "C-u" '("universal argument" . universal-argument)

      "0"   '("jump to window 0" . winum-select-window-0)
      "1"   '("jump to window 1" . winum-select-window-1)
      "2"   '("jump to window 2" . winum-select-window-2)
      "3"   '("jump to window 3" . winum-select-window-3)
      "4"   '("jump to window 4" . winum-select-window-4)

      ;; TODO: When inside counsel-projectile-rg, you can do C-c C-o to persist the search results in a special buffer,
      ;;   and then in that buffer you can press enter on any of them and jump to that location.
      ;;   This is awesome, but how will I remember this? Somehow help myself remember this. Another candidate for "hint"/"help" zone?
      ;;   Btw Helm (in Spacemacs) has this bar at the bottom where it shows which command was just run and some hints (C-z for actions, ...).
      ;;   Is this something I can replicate, at least for Ivy?
      "/"   '("search in project" . counsel-projectile-rg)
      "*"   '("search in project w/input" . counsel-projectile-rg-region-or-symbol)

      "`"   '("mark ring" . counsel-mark-ring)

      "t"   '("toggles" . (keymap)) ; This is how prefix is defined.
      "tt"  '("choose theme" . counsel-load-theme)
      "ts"  '("scale text" . hydra-text-scale/body)

      "a"   '("apps" . (keymap))
      "au"  '("undo tree" . vundo)

      "af"  '("fun" . (keymap))
      "afa" 'animate-birthday-present
      "afb" 'blackbox
      "afc" 'butterfly
      "afd" 'doctor
      "afe" 'bubbles
      "aff" 'dunnet
      "afg" 'gnugo
      "afh" 'hanoi
      "afi" 'gomoku
      "afj" 'solitaire
      "afl" 'life
      "afp" 'pong
      "afs" 'snake
      "aft" 'tetris
      "afx" '5x5
      "afz" 'zone

      "q"   '("quit" . (keymap))
      "qq"  '("quit" . save-buffers-kill-terminal)
      "qr"  '("restart" . restart-emacs)

      "w"   '("windows" . (keymap))
      "ww"  '("other window" . ace-window)
      "wd"  '("delete window" . delete-window)
      "wx"  '("delete window and buffer" . kill-buffer-and-window)
      "w/"  '("split vertically" . split-window-right)
      "w-"  '("split horizontally" . split-window-below)
      "wr"  '("resize window" . hydra-window-resize/body)
      "wR"  '("reset: just scratch" . (lambda () (interactive) (delete-other-windows) (scratch-buffer)))
      "wm"  '("move window" . hydra-window-move/body)
      "w."  '("focus window" . delete-other-windows)
      "w="  '("balance window sizes" . balance-windows)

      "b"   '("buffers" . (keymap))
      "bb"  '("switch buffer" . ivy-switch-buffer)
      "bd"  '("kill buffer" . kill-current-buffer)
      "bs"  '("go to scratch" . scratch-buffer)
      "bm"  '("go to messages" . my/switch-to-messages-buffer)
      "bp"  '("previous buffer" . hydra-buffer-next-prev/previous-buffer)
      "bn"  '("next buffer" . hydra-buffer-next-prev/next-buffer)
      "br"  '("reload buffer" . revert-buffer)
      "bv"  '("select whole buffer" . mark-whole-buffer)

      "e"   '("errors" . (keymap))

      "f"   '("files" . (keymap))
      "fj"  '("jump in file" . avy-goto-char-timer)
      "ff"  '("find file" . counsel-find-file)
      "fs"  '("save" . save-buffer)
      "fr"  '("recent files" . counsel-recentf)

      "fe"  '("emacs" . (keymap))
      "feo" '("open Emacs.org file" . my/open-emacs-org-file)
      "fei" '("open init.el file" . my/open-init-file)

      "i"   '("ai" . (keymap))

      "v"   '("eval (elisp)" . (keymap))
      "vl"  '("last-sexp" . eval-last-sexp)
      "vv"  '("top-level form" . eval-defun)
      "vr"  '("region" . eval-region)
      "v:"  '("expression" . eval-expression)

      "o"   '("org" . (keymap))
      "oa"  '("agenda" . org-agenda)
      "oc"  '("capture" . org-capture)
      "ol"  '("store link" . org-store-link)

      "p"   '("projects" . (keymap))
      "pf"  '("find file" . counsel-projectile-find-file)
      "pd"  '("find dir" . projectile-find-dir)
      "pb"  '("switch buffer" . projectile-switch-to-buffer)
      "pp"  '("switch project" . counsel-projectile-switch-project)
      "pr"  '("find and replace" . projectile-replace)
      "p."  '("all commands" . projectile-command-map)
    )

    (general-define-key
      :states '(normal visual)
      :keymaps 'override
      "p" 'my/paste-after-then-hydra
      "P" 'my/paste-before-then-hydra
    )
  )

#+end_src

** which-key

#+begin_src emacs-lisp

  (use-package which-key
    :config
    (setq which-key-idle-delay 0.5)
    (setq which-key-add-column-padding 2)
    (setq which-key-min-display-lines 5)
    (which-key-mode)
  )

#+end_src

** hydras

Hydra enables you to define a small "menu", which when you activate, activates transient unique keybindings (which you also defined) that you can use only then, and lists them in the minibuffer in a nice menu.

It is convenient when you need to spam a lot of very specific commands, e.g. scale text (in / out), or resize window (left / right / up / down), or iterate through kill ring, or something like that.
So then you go into "text scale resizing mode" to put it that way, and you can easily resize it with e.g. one letter commands.

#+begin_src emacs-lisp

  (use-package hydra
    :config
    (defhydra hydra-text-scale ()
      "Scale text"
      ("j" text-scale-decrease "out")
      ("k" text-scale-increase "in")
      ("r" (progn (text-scale-increase 0)) "restore")
      ("q" nil "quit" :exit t)
    )

    (defhydra hydra-buffer-next-prev ()
      "Next/previous buffer"
      ("p" previous-buffer "previous")
      ("n" next-buffer "next")
      ("q" nil "quit" :exit t)
    )

    (defhydra hydra-paste ()
      "Choose what to paste from the kill ring"
      ("C-j" evil-paste-pop "previous")
      ("C-k" evil-paste-pop-next "next")
      ("/" (progn
            (evil-undo-pop) ; Undo last paste.
            ;; NOTE: Ideally, I would put the new paste (about to be selected by counsel-yank-pop)
            ;; starting exactly from the same place as previous paste, as e.g. evil-paste-pop does,
            ;; but I haven't found a simple way to implement that, so I do a more simplistic
            ;; approach, below that is a bit less precise (e.g. adds redundant newline). However I
            ;; don't think that is a big problem if one decided to browse kill ring visually, you
            ;; care less about speed / formatting then.
            (goto-char (nth 2 evil-last-paste)) ; Put cursor back where it was before the last paste.
            (if (eq last-command 'evil-paste-before)
                (evil-insert-newline-above)
                (evil-insert-newline-below)
            )
            (counsel-yank-pop) ; Browse kill ring, pick entry and paste it.
          )
          "browse"
      )
      ("q" nil "quit" :exit t)
    )
    (defun my/paste-after-then-hydra ()
      (interactive)
      (call-interactively 'evil-paste-after)
      (hydra-paste/body)
      ;; This way this command is recognized as evil-paste-after, making evil-paste-after a last-command,
      ;; which is a requirement for evil-paste-pop functions from hydra-paste to be able to be executed
      ;; after this one.
      (setq this-command 'evil-paste-after)
    )
    (defun my/paste-before-then-hydra ()
      (interactive)
      (call-interactively 'evil-paste-before)
      (hydra-paste/body)
      (setq this-command 'evil-paste-before)
    )

    (defhydra hydra-window-resize (:hint nil)
      "
    Resize window
    -------------
                _h_: ⇾ ⇽          ↑        ↓
                              _k_:     _j_:
                _l_: ⇽ ⇾          ↓        ↑
    "
      ("h" shrink-window-horizontally)
      ("j" shrink-window)
      ("k" enlarge-window)
      ("l" enlarge-window-horizontally)
      ("q" nil "quit" :exit t)
    )

    (defhydra hydra-window-move (:hint nil)
      "
    Move window
    -----------
                        _k_: top
                _h_: left       _l_: right
                        _j_: bottom
    "
      ("h" evil-window-move-far-left)
      ("j" evil-window-move-very-bottom)
      ("k" evil-window-move-very-top)
      ("l" evil-window-move-far-right)
      ("q" nil "quit" :exit t)
    )
  )

#+end_src

** Evil

#+begin_src emacs-lisp
  
  ;; CHEATSHEET: C-z puts us into `emacs` mode, which is normal situation without evil.
  (use-package evil
    :init
    (setq evil-want-integration t)  ; Required by evil-collection.
    (setq evil-want-keybinding nil) ; Required by evil-collection.
    (setq evil-undo-system 'undo-fu)
    ;; C-u-scroll needs explicit enabling because in Emacs C-u is important, it is
    ;; universal argument. But I don't use it much, so I rather go with vi's
    ;; scroll, which I use a lot. I anyway mapped universal argument to also be SPC C-u.
    (setq evil-want-C-u-scroll t)
    :custom
    (evil-shift-width 2) ; When shifting text left or right with < or >, do it for 2 spaces.
    :config
    (evil-mode 1)
    (define-key evil-motion-state-map (kbd "SPC") nil) ; To avoid conflict with me using SPC as leader key (defined via general.el).
    (define-key evil-motion-state-map (kbd ",") nil) ; I prefer using "," for mode-specific keymap (e.g. for lsp).
  )

#+end_src

#+begin_src emacs-lisp

  (use-package evil-escape
    :after evil
    :custom
    (evil-escape-key-sequence "fd")
    :config
    (evil-escape-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Sets evil keybindings in many more parts of emacs than evil-mode does by default,
  ;; and in a better way than evil does.
  (use-package evil-collection
    :after evil
    :custom (evil-collection-setup-minibuffer nil)  ; If set to `t` it messes up / overrides my custom keybindings for Ivy (e.g. C-k).
    :config (evil-collection-init)
  )

#+end_src

* Org mode
** Basic setup (org)

#+begin_src emacs-lisp

  (use-package org
    :defer t
    :hook
    (org-mode . (lambda ()
      (org-indent-mode) ; Enforces correct indentation under each heading.
      (visual-line-mode 1)
      (setq evil-auto-indent nil)
    ))
    :config
    (general-define-key
     :states '(normal)
     :keymaps 'org-mode-map
     :prefix ","
     "cs" 'org-schedule
     "cd" 'org-deadline
     "ct" 'org-set-tags-command
     "ce" 'org-set-effort
     "x" 'org-toggle-checkbox
     "J" 'org-priority-down
     "K" 'org-priority-up
     "t" 'org-todo
     "/" 'org-sparse-tree
     "ln" 'org-next-link
     "lp" 'org-previous-link
    )

    ;; Set headers to have different sizes.
    (dolist (face '((org-level-1 . 1.5)
                    (org-level-2 . 1.3)
                    (org-level-3 . 1.2)
                    (org-level-4 . 1.1)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :height (cdr face))
    )

    (setq org-log-into-drawer t)
    (setq org-habit-graph-column 60)

    (setq org-ellipsis " ▼")
    (set-face-attribute 'org-ellipsis nil
                        :foreground (face-attribute 'shadow :foreground))

    (add-to-list 'org-modules 'org-habit)
    (add-to-list 'org-modules 'org-inlinetask)

    (setq org-priority-faces '((?A . (:foreground "#ff757f" :weight normal))
                               (?B . (:foreground "orange" :weight light))
                               (?C . (:foreground "yellow" :weight light))))

    (set-face-attribute 'org-mode-line-clock nil
                        :inherit 'highlight
                        :weight 'bold)
    (set-face-attribute 'org-mode-line-clock-overrun nil
                        :inherit 'org-mode-line-clock
                        :background (face-attribute 'error :foreground))

    (setq org-todo-keyword-faces
          '(("INBOX" . (:foreground "yellow" :weight bold))
            ("INPR" . (:foreground "dark orange" :weight bold))
            ;; I obtained #446a73 by adding a bit of green to the color of org-agenda-done face.
            ("DONE" . (:foreground "#446a73" :weight bold))
            ;; I got #bf6900 by darkening the "dark orange" which allegedly is #ff8c00.
            ("BLCK" . (:foreground "#bf6900" :weight bold :strike-through t))
            ("CANCELED" . (:foreground "dim gray" :weight bold :strike-through t))
            ("EPIC" . (:foreground "orchid" :weight bold))
            ("CANCELED[EPIC]" . (:foreground "dim gray" :weight bold :strike-through t))
            ("CHKL" . (:foreground "grey" :weight bold))
            ("NOTE" . (:foreground "white" :weight bold))
           )
    )
  )

  ;; Replace header and list bullets (*, **, -, +, ...) with nice bullets.
  (use-package org-superstar
    :after (org)
    :defer t
    :hook (org-mode . org-superstar-mode)
    :custom
    ;; I use `org-superstar-leading-bullets' to hide leading stars of the heading by setting them to space.
    ;; I use two spaces because that is how they have shown it should be done in the docs and it works well.
    ;; Why don't I use `org-superstar-remove-leading-stars', which should hide them for real?
    ;; Because when I tried using it, it resulted in headings being shifted too much to the left.
    (org-superstar-leading-bullet "  ")
    (org-superstar-item-bullet-alist '((?* . ?★) (?+ . ?✦) (?- . ?•)))
    :config
    (set-face-attribute 'org-superstar-item nil :foreground (face-attribute 'font-lock-keyword-face :foreground))
  )

  ;; Org Tempo expands snippets to structures defined in org-structure-template-alist and org-tempo-keywords-alist.
  (use-package org-tempo
    :after (org)
    :ensure nil ; Comes with org already.
  )

  ; Colors tags in org mode with "random" colors based on their string hash.
  (use-package org-rainbow-tags
    :after (org)
    :hook ((org-mode org-agenda-finalize) . org-rainbow-tags-mode)
    :custom
    (org-rainbow-tags-extra-face-attributes '(:slant 'italic :weight 'normal))
    (org-rainbow-tags-adjust-color-percent 100) ; Make colors as light as possible, so they work well with dark bg.
  )

  ;; Display "prettified" pieces of text in their raw shape when point is on them.
  ;; E.g. links or superscript.
  (use-package org-appear
    :hook (org-mode . org-appear-mode)
    :custom
    (org-appear-autoemphasis t)
    (org-appear-autolinks nil) ; `t` is too intrusive, instead I should just use `org-insert-link`.
    (org-appear-autosubmarkers t)
    (org-appear-autoentities t)
    (org-appear-autokeywords t)
    (org-appear-inside-latex t)
    (org-appear-trigger 'always)

    ;; Make bold and italic and similar nice by default, since we now have org-appear
    ;; to show them as raw when needed.
    (org-hide-emphasis-markers t)
  )

#+end_src

** Show org links in echo area

Org and org-agenda mode show links in echo area when you go over them with mouse, but they don't show them if you move to them with cursor.
Therefore, here we replicate that same behaviour when you move over them with cursor.
Since information displayed in echo area upon mouse is ~help-echo~ information, we take that same info and display it when cursor comes at the link.

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (defun my/org-display-link-info-at-point ()
      "Display the link info in the echo area when the cursor is on an Org mode link."
      (when-let* ((my/is-face-at-point 'org-link)
                  (link-info (get-text-property (point) 'help-echo)))
        ;; This will show the link in the echo area without it being logged in the Messages buffer.
        (let ((message-log-max nil)) (message "%s" link-info))
      )
    )
    (dolist (h '(org-mode-hook org-agenda-mode-hook))
      (add-hook h (lambda () (add-hook 'post-command-hook #'my/org-display-link-info-at-point nil 'local)))
    )
  )

#+end_src
** evil-org
#+begin_src emacs-lisp

  (use-package evil-org
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
  )

#+end_src

** Code blocks (org-babel)

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    ;; Here we define our custom structure templates (snippets) for quickly creating code blocks.
    ;; Typing e.g. "<elTAB" will expand it to snippet.
    (dolist (key-to-block-type '(("sh" . "src shell")
                                 ("el" . "src emacs-lisp")
  			       ("py" . "src python")))
      (add-to-list 'org-structure-template-alist key-to-block-type)
    )
    
    ;; Define which languages can be evaluated/executed in org files.
    ;; Org will load support for them.
    (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (python . t))
    )

    (setq org-confirm-babel-evaluate nil) ; Don't ask for confirmation when evaluation a block.
  )

#+end_src

** Automatically tangle this file (Emacs.org)

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (defun my/org-babel-tangle-no-confirm ()
      (let ((org-confirm-babel-evaluate nil)) (org-babel-tangle))
    )
    (defun my/when-emacs-org-file-tangle-on-save ()
      (when (and buffer-file-name (file-equal-p buffer-file-name (my/emacs-org-file-path)))
        (add-hook 'after-save-hook 'my/org-babel-tangle-no-confirm nil 'local)
      )
    )
    (add-hook 'org-mode-hook 'my/when-emacs-org-file-tangle-on-save)
  )

#+end_src

** org-tidy

#+begin_src emacs-lisp

  (use-package org-tidy)

#+end_src

** org-present

Turns any org document into a presentation! Each top-level header is one slide.

#+begin_src emacs-lisp

  (use-package org-present
    :after (org visual-fill-column org-tidy)
    :bind (
      :map org-present-mode-keymap
             ("q" . org-present-quit)
    )
    :config

    ;; TODO: I should make it work with evil-mode.
    ;;   Then I could not probably even need to go read-only.

    (defun my/on-presentation-start ()
      (let ((restore-local-vars
  	      (my/save-local-vars-state
  	        '(visual-fill-column-width
  		  visual-fill-column-center-text
  		  org-tidy-properties-style
  		  org-tidy-general-drawer-flag
  		  org-tidy-general-drawer-name-whitelist)))
            (restore-modes
                (my/save-modes-state
                  '(evil-local-mode
  		  visual-line-fill-column-mode
                    org-tidy-mode)))
  	 )

        (when (featurep 'evil)
          (evil-local-mode -1) ; Otherwise evil messes up org-present.
        )

        (org-present-big)
        (org-display-inline-images)
        (org-present-hide-cursor)
        (org-present-read-only)

        ;; Soft wraps the text at fixed width while also centering it.
        ;; TODO: I could get decent fixed width only with value of 20 when `(org-present-big)`
        ;;   is used above, while I would normally expect 80 to do it.
        ;;   Figure out why is that so -> does usage of `(text-scale-increase)` in `(org-present-big)`
        ;;   uses somehow mess things up? This is because it is after inline-images!
        ;; TODO: There also seems to be some weird interaction between this mode and (org-display-inline-images).
        ;;   If this happens before inlining images, then ATTR_ORG :width behaves weird.
        (setq-local visual-fill-column-width 20
                    visual-fill-column-center-text t)
        (visual-line-fill-column-mode 1)

        ;; Hide org drawers (:PROPERTY: and :NOTES:).
        (setq-local org-tidy-properties-style 'invisible
  		  org-tidy-general-drawer-flag t
  		  org-tidy-general-drawer-name-whitelist '("NOTES"))
        (org-tidy-mode 1)

        (defun my/on-presentation-quit ()
  	(org-present-small)
  	(org-remove-inline-images)
  	(org-present-show-cursor)
  	(org-present-read-write)

  	(funcall restore-local-vars)
  	(funcall restore-modes)

  	(remove-hook 'org-present-mode-quit-hook 'my/on-presentation-quit)
        )
        (add-hook 'org-present-mode-quit-hook 'my/on-presentation-quit)
      )
    )
    (add-hook 'org-present-mode-hook 'my/on-presentation-start)

    (defun my/org-present-eval-print-last-sexp ()
      "Evaluate and print (in buffer) the last sexp while in presentation mode."
      (interactive)
      (org-present-read-write)
      (eval-print-last-sexp)
      (org-present-read-only)
    )
  )

#+end_src

*** Cheatsheet :cheatsheet:
- `org-present` to go into presentation mode.
- left and right arrow take you to previous or next header (which is actually now a slide).
- "q" to exit the presentation.
- I configured it so that it hides :NOTES: org drawer, so you can use it to add speaker notes to each slide.

** Calendar sync

Two most popular emacs packages for pulling in calendar events into org file are https://github.com/dengste/org-caldav and https://github.com/kidd/org-gcal.el . I decided to go with the later one, but for no strong reason except for it being specific for gcal.

#+begin_src emacs-lisp

  (use-package org-gcal
    :init
    ;; Get calendar credentials from .authinfo file and use them.
    (let* ((gcal-auth-info (car (auth-source-search :host "gcal" :max 1 :require '(:user :secret)))))
      (setq org-gcal-client-id (plist-get gcal-auth-info :user)
            org-gcal-client-secret ((lambda (x) (if (functionp x) (funcall x) x))
                                    (plist-get gcal-auth-info :secret))
      )
    )
    ;; First elements of the pairs here are ids of google calendars.
    (setq my/calendar-events-wasp-org-file "~/Dropbox/calendar-events-wasp.org")
    (setq my/calendar-events-private-org-file "~/Dropbox/calendar-events-private.org")
    (setq org-gcal-fetch-file-alist `(("martin@wasp-lang.dev" . ,my/calendar-events-wasp-org-file)
  				    ("sosic.martin@gmail.com" . ,my/calendar-events-private-org-file)
  				    ))

    (my/leader-keys
      "o C" '("calendar" . (keymap))
      "o C f" '("fetch newest calendar data" . org-gcal-fetch)
      "o C C" '("clear sync tokens" . org-gcal-sync-tokens-clear)
      "o C F" '("refetch calendar data" . (lambda () (interactive) (org-gcal-sync-tokens-clear) (org-gcal-fetch)))
    )
  )

#+end_src

*NOTE*: It saves Google Oauth secrets locally with =plstore=. I followed intructions in the README of =org-gcal= regarding it, to create an empty file if I get some issues. Also, it is important that we have =plstore= configured correctly in general, otherwise it asks for password too many times and makes =org-gcal= slow.

*** Obtaining Google OAuth credentials                       :manual_setup:
We need to create an OAuth 2.0 client id on our Google Developer Console for a project that gives access to the calendar, and then provide the client id and secret to org-gcal in order for it to be able to work with the calendar.

Detailed instructions on how to do this the Google side are provided in the org-gcal README.

As for storing client secret (and id) in safe manner, I decided to keep them in the ~/.authinfo file.
This is the manual setup part here: I need to make sure there is a line in that file of this format:
~machine gcal login <client-id> password <client-secret>~

In the config above I then fetch those credentials from .authinfo and provide them to org-gcal.

*** TODO Make fetching of events automatic (check org-gcal [[https://github.com/kidd/org-gcal.el?tab=readme-ov-file#sync-automatically-at-regular-times][README]])
*** Cheatsheet                                                 :cheatsheet:
- ~org-gcal-fetch~ updates the events in all files in the alist, by pulling the info from the gcalendar.
  This is the command I will most often want to run.
- ~org-gcal-sync-tokens-clear~ clears the sync tokens (which is gcalendar concept). If they are not cleared, ~org-gcal-fetch~ will be fetching only changes after the time of the last fetch! This is ok if we kept all the events stored, but if we maybe deleted files with events and want to fetch them again, there want to do full sync -> we should run this command first.
** org-agenda
*** General setup
#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (setq org-agenda-scheduled-leaders '("-> " "-%dd -> "))
    (setq org-agenda-deadline-leaders '("! " "+%dd ! " "-%dd ! "))
    ;; Make the current time in the time-grid (<- now --------) stand out.
    (set-face-attribute 'org-agenda-current-time nil
                        :foreground "#9a93cf" ;; Obtained by making org-time-grid face a bit purple.
                        :weight 'bold)
    ;; Make events in the time grid that are not scheduled tasks not stand out.
    (set-face-attribute 'org-agenda-calendar-event nil
                        :foreground (face-attribute 'org-time-grid :foreground))
  )

#+end_src

*** Evil keybindings

#+begin_src emacs-lisp

  (with-eval-after-load 'evil
    ;; TODO: I am basing these keybindings on the evil-org-agenda-set-keys function from
    ;;   evil-org-agenda.el (from evil-org package), but I copied them directly here so I can easily modify
    ;;   them as I wish.

    (evil-set-initial-state 'org-agenda-mode 'motion)

    (evil-define-key 'motion org-agenda-mode-map
      ;; Opening org file.
      (kbd "<tab>") 'org-agenda-goto
      (kbd "RET") 'org-agenda-switch-to
      (kbd "M-RET") 'org-agenda-recenter

      ;; Motion.
      "j" 'org-agenda-next-line
      "k" 'org-agenda-previous-line
      "gH" 'evil-window-top
      "gM" 'evil-window-middle
      "gL" 'evil-window-bottom
      (kbd "C-j") 'org-agenda-next-item
      (kbd "C-k") 'org-agenda-previous-item
      (kbd "[[") 'org-agenda-earlier
      (kbd "]]") 'org-agenda-later

      ;; manipulation
      ;; We follow standard org-mode bindings (not org-agenda bindings):
      ;; <HJKL> change todo items and priorities.
      ;; M-<jk> drag lines.
      ;; M-<hl> cannot demote/promote, we use it for "do-date".
      "J" 'org-agenda-priority-down
      "K" 'org-agenda-priority-up
      "H" 'org-agenda-do-date-earlier
      "L" 'org-agenda-do-date-later
      "t" 'org-agenda-todo
      (kbd "M-j") 'org-agenda-drag-line-forward
      (kbd "M-k") 'org-agenda-drag-line-backward
      (kbd "C-S-h") 'org-agenda-todo-previousset ; Original binding "C-S-<left>"
      (kbd "C-S-l") 'org-agenda-todo-nextset ; Original binding "C-S-<right>"

      ;; undo
      "u" 'org-agenda-undo

      ;; actions
      "dd" 'org-agenda-kill
      "dA" 'org-agenda-archive
      "da" 'org-agenda-archive-default-with-confirmation
      "ct" 'org-agenda-set-tags
      "ce" 'org-agenda-set-effort
      "cs" 'org-agenda-schedule
      "cd" 'org-agenda-deadline
      "cT" 'org-timer-set-timer
      "i" 'org-agenda-diary-entry
      "a" 'org-agenda-add-note
      "A" 'org-agenda-append-agenda
      "C" 'org-agenda-capture
      "e" 'org-agenda-tree-to-indirect-buffer
      "o" 'org-agenda-goto

      ;; mark
      "m" 'org-agenda-bulk-toggle
      "~" 'org-agenda-bulk-toggle-all
      "%" 'org-agenda-bulk-mark-regexp
      "x" 'org-agenda-bulk-action

      ;; refresh
      "gr" 'org-agenda-redo
      "gR" 'org-agenda-redo-all

      ;; quit
      "ZQ" 'org-agenda-exit
      "ZZ" 'org-agenda-quit

      ;; display
      "gD" 'org-agenda-view-mode-dispatch
      "ZD" 'org-agenda-dim-blocked-tasks

      ;; clock
      "I" 'org-agenda-clock-in ; Original binding
      "O" 'org-agenda-clock-out ; Original binding
      "cg" 'org-agenda-clock-goto
      "cc" 'org-agenda-clock-cancel
      "cr" 'org-agenda-clockreport-mode

      ;; go and show
      "." 'org-agenda-goto-today
      "gc" 'org-agenda-goto-calendar
      "gC" 'org-agenda-convert-date
      "gd" 'org-agenda-goto-date
      "gh" 'org-habit-stats-view-habit-at-point-agenda
      "gm" 'org-agenda-phases-of-moon
      "gs" 'org-agenda-sunrise-sunset
      "gt" 'org-agenda-show-tags
      "ge" 'org-agenda-entry-text-mode

      "p" 'org-agenda-date-prompt
      "P" 'org-agenda-show-the-flagging-note

      "+" 'org-agenda-manipulate-query-add
      "-" 'org-agenda-manipulate-query-subtract
    )
  )

#+end_src

*** org-super-agenda

Org-super-agenda allows both easier and smarter grouping of entries under a day/week org agenda view.
Each org-super-agenda group "consumes" entries it shows, leaving the next group with less entries, kind of like a parser. Whatever is left at the end is shown at the end of agenda as "Other items".

#+begin_src emacs-lisp

  (use-package org-super-agenda
    :after org
    :init
    ;; org-super-agenda-header-map is keymap for super agenda headers and normally it just copies keybindings
    ;; from org-agenda-mode-map, but since I modify those later with evil-org, then I don't want
    ;; org-super-agenda-header-map sticking to the old keybindings and having super agenda headers behave
    ;; in default, non-evil way (e.g. "j" when on them doesn't move down but opens calendar).
    ;; I haven't managed to figure out how to update it to behave in an evil fashion, so I ended up just disabling
    ;; it completely, and that works great.
    (setq org-super-agenda-header-map nil)
    (setq org-super-agenda-keep-order t) ; Can degrade performance, which is why it isn't enabled by default.
    :config
    (org-super-agenda-mode)
  )

#+end_src

*** Work Diary

#+name: my/work-diary-org-path
#+begin_src emacs-lisp :tangle no :results value none
  "~/Dropbox/work-diary.org"
#+end_src

**** Inbox
Inbox here is the same concept as is in GTD: a place where I can quickly drop raw ideas / tasks that are to be refined later (soon).
We drop these in Work Diary org file, with the right todo keyword (INBOX), at the place of special org target in the org file.

I define a bash script that can be used outside of emacs to easily add entries to inbox (should be bound to some easily accessible OS-wide keybinding).
This bash script picks up whatever is in the clipboard, and if it is URI, it will automatically add it to the entry. Therefore, usual workflow is to copy the URI if there is one (e.g. Discord message link) and then call the script via the keybinding.

#+begin_src bash :tangle ./inbox-add.bash :noweb yes

  WORK_DIARY_ORG_PATH="$(eval echo "<<my/work-diary-org-path()>>")"
  # I redundantly escape < and > here to not trigger the noweb interpolation.
  WORK_DIARY_ORG_INBOX_TARGET="\<\<Insert INBOX tasks here\>\>"

  # Obtain URI from the clipboard, if there is one.
  uri=$(wl-paste)
  if [[ ! "$uri" =~ ^[a-zA-Z][a-zA-Z0-9+.-]*:// ]]; then
    uri=""
  fi

  SEPARATOR=";"
  input=$(yad --title="Inbox" --form --separator="${SEPARATOR}" \
              --field="Title" "" \
              --field="Uri" "${uri}" \
              --field="Description" "" \
              --button=Add:0) || exit 1
  title=$(echo "${input}" | cut -d"${SEPARATOR}" -f1)
  uri=$(echo "${input}" | cut -d"${SEPARATOR}" -f2)
  description=$(echo "${input}" | cut -d"${SEPARATOR}" -f3)

  if [ -z "${title}" ]; then exit 1; fi

  org_heading="** INBOX ${title}"
  if [ -n "$uri" ]; then
    org_heading="$org_heading ([[${uri}][URI]])"
  fi
  if [ -n "$description" ]; then
    org_heading="$org_heading"$'\n'"  ${description}"
  fi

  sed -i "/${WORK_DIARY_ORG_INBOX_TARGET}/r /dev/stdin" "${WORK_DIARY_ORG_PATH}" <<< "${org_heading}"

#+end_src

***** System requirements and defining an OS keybinding    :manual_setup:
- For the bash script to work, make sure that ~yad~ and ~wl-clipboard~ are installed system wide.
- Also set up a keybinding at the OS level that will allow to easily run the script. A good one is =Win + I=.

*** Marking todo deadlines with earlier schedule

These are todo deadline entries that are not yet done and have a schedule some earlier day.
You will usually encounter such entries when looking at future dates in the weekly agenda view.
They are indicators of deadlines, but are likely to be done earlier, so by clearly marking them we can adapt things such as calculating expected effort for such days, and also make it clear visually that they are likely not to be done on that day (day of deadline).

#+begin_src emacs-lisp

  (defvar my/after-org-agenda-mark-todo-deadlines-with-earlier-schedule-hook nil
    "Hook called after the marking of the todo deadlines with the earlier schedule")

  (defun my/org-agenda-mark-todo-deadlines-with-earlier-schedule ()
    "Mark all todo deadline entries in agenda that have earlier schedule.
  It will both mark them with a text property and also style them to be less emphasized."
    (save-excursion
      (while (< (point) (point-max))
        (let* ((entry-type (org-get-at-bol 'type))
               (entry-is-deadline (string= entry-type "deadline"))
               ;; org-hd-marker returns position of header in the original org buffer.
               (entry-marker (org-get-at-bol 'org-hd-marker))
               (entry-scheduled-time-str (when entry-marker (org-entry-get entry-marker "SCHEDULED")))
               (entry-deadline-time-str (when entry-marker (org-entry-get entry-marker "DEADLINE")))
               (entry-todo-state (org-get-at-bol 'todo-state))
               (entry-is-done (when entry-todo-state
                               (member entry-todo-state org-done-keywords-for-agenda)))
               (entry-is-todo (when entry-todo-state (not entry-is-done)))
               (entry-scheduled-before-deadline
                (and entry-scheduled-time-str
                      entry-deadline-time-str
                      (< (org-time-string-to-absolute entry-scheduled-time-str)
                        (org-time-string-to-absolute entry-deadline-time-str)
                      )
                )
               )
              )
          (when (and entry-is-deadline entry-is-todo entry-scheduled-before-deadline)
            (let ((ov (make-overlay (line-beginning-position) (line-end-position))))
              (overlay-put ov 'face '(:weight extra-light :slant italic))
              (overlay-put ov 'category 'my-agenda-todo-deadline-with-earlier-schedule)
              (put-text-property (line-beginning-position) (line-end-position) 'is-todo-deadline-with-earlier-schedule t)
            )
          )
        )
        (forward-line)
      )
    )
    (run-hooks 'my/after-org-agenda-mark-todo-deadlines-with-earlier-schedule-hook)
  )

  (add-hook 'org-agenda-finalize-hook 'my/org-agenda-mark-todo-deadlines-with-earlier-schedule)

#+end_src

*** Calculating total daily leftover effort

#+begin_src emacs-lisp

  (require 'cl-lib)

  (defun my/org-agenda-calculate-total-leftover-effort-today (point-limit)
    "Sum the leftover org agenda entries efforts for today from the current point till the POINT-LIMIT.
  Return minutes (number)."
    (let (efforts)
      (save-excursion
        (while (< (point) point-limit)
          (let* ((entry-type (org-get-at-bol 'type))
                 ;; org-hd-marker returns position of header in the original org buffer.
                 (entry-marker (org-get-at-bol 'org-hd-marker))
                 (entry-scheduled-time-str (when entry-marker (org-entry-get entry-marker "SCHEDULED")))
                 (entry-deadline-time-str (when entry-marker (org-entry-get entry-marker "DEADLINE")))
                 (entry-todo-state (org-get-at-bol 'todo-state))
                 (entry-is-done (when entry-todo-state
                                  (member entry-todo-state org-done-keywords-for-agenda)))
                 (entry-is-todo (when entry-todo-state (not entry-is-done)))
                )
            (when (and entry-is-todo
                       ;; We intentionally didn't include the "upcoming deadline" entries.
                       (or (member entry-type '("scheduled" "past-scheduled" "timestamp"))
                           ;; We count only deadlines that also have a scheduled time on that same day.
                           ;; This is specific to how my agenda is set up: Such deadline entries will
                           ;; appear under the list of tasks for today, so we want to count them.
                           (and (string= entry-type "deadline")
                                entry-scheduled-time-str
                                entry-deadline-time-str
                                (= (org-time-string-to-absolute entry-scheduled-time-str)
                                   (org-time-string-to-absolute entry-deadline-time-str)
                                )
                           )
                       )
                  )
              (push (org-entry-get entry-marker "Effort") efforts)
            )
          )
          (forward-line)
        )
      )
      (cl-reduce #'+
                 (mapcar #'org-duration-to-minutes (cl-remove-if-not 'identity efforts))
                 :initial-value 0
      )
    )
  )

  (defun my/org-agenda-insert-total-daily-leftover-efforts ()
    "Insert the total scheduled effort for each day inside the agenda buffer."
    (save-excursion
      (let (curr-date-header-pos)
        (while (setq curr-date-header-pos (text-property-any (point) (point-max) 'org-agenda-date-header t))
          (goto-char curr-date-header-pos)
          (end-of-line)
          (let* ((next-date-header-pos (text-property-any (point) (point-max) 'org-agenda-date-header t))
                 (total-effort (my/org-agenda-calculate-total-leftover-effort-today
                                (or next-date-header-pos (point-max))))
                )
            (insert-and-inherit (concat " (∑⏳ = " (org-duration-from-minutes total-effort) ")"))
          )
          (forward-line)
        )
      )
    )
  )

  (add-hook 'org-agenda-finalize-hook 'my/org-agenda-insert-total-daily-leftover-efforts)

#+end_src

*** Agenda custom commands

#+begin_src emacs-lisp :noweb yes
  ;; I wait for org-gcal because in :init of org-gcal I define vars that hold paths to files with
  ;; calendar events, and I need to know those paths so I can show events in the agenda.
  (with-eval-after-load 'org (with-eval-after-load 'org-gcal

    (defun my/make-work-diary-cmd-agenda-block-base-settings (show-daily-checklist show-other-tasks)
      "Base settings for the agenda block in my work-diary custom agenda commands."
      `((org-agenda-prefix-format " %12s %5e %?-12t")
        (org-agenda-sorting-strategy '(time-up
                                       todo-state-down
                                       priority-down
                                       scheduled-up
                                       urgency-down)
        )
        (org-super-agenda-groups
         '(
           (:discard (:todo "INBOX"))
           ,@(if show-daily-checklist
                 '(;; Repeating tasks to be done every day, including today.
                   (:name "Daily Checklist"
                          :and (:category "dc"
                                :not (:log t))
                   )
                  )
               '()
             )
           (:name "Todo (today)"
                  :and (:time-grid t :not (:log t))
           )
           (:name "        No specific time:"
                  :and (:category "task"
                        :scheduled t
                        :not (:log t))
           )
           ;; Discard "closed" logs for items scheduled for today because they will be shown
           ;; as done already above, so we don't want to repeat it.
           ;; NOTE: Due to this bug in super-agenda https://github.com/alphapapa/org-super-agenda/issues/42,
           ;;   `:scheduled today` works as you would expect only when agenda is actually focused on today,
           ;;   because today means the actual day today, not the day that agenda daily view is focusing on.
           ;;   Therefore if I look at yesterday, this discarding doesn't work and I get double done entries.
           (:discard (:and (:scheduled today :log closed)))
           (:name none
                   :and (:category "task"
                         :log closed)
           )
           (:name "Clock log"
                  :log clocked
           )
           ,@(if show-other-tasks
                 '(
                   (:name "Other (e.g. deadline w/o scheduled)"
                          :anything t
                   )
                  )
               '(
                 (:discard (:anything t))
                )
             )
         )
        )
       )
    )

    (defun my/make-work-diary-cmd-base-settings ()
      "Base settings for my work-diary custom agenda commands."
      `((org-agenda-files `("<<my/work-diary-org-path()>>"
                            ,my/calendar-events-wasp-org-file
                            ,my/calendar-events-private-org-file
                           ))

        ;; Starts agenda log mode, which means that special extra "log" entries are added to agenda,
        ;; in this logs about closing an entry and logs about clocking an entry. I could also have
        ;; added 'state' if needed. I track "closed" logs in order to ensure that entries that are
        ;; DONE but have been scheduled in the past are shown in agenda (normally they are
        ;; not). What is not great is that they are not normal but special log entries which are a
        ;; bit different, so a bit harder to organize.
        (org-agenda-start-with-log-mode '(closed clock))

        ;; Org agenda shows both scheduled and deadline entries for an item, when available.
        ;; I don't want that: having duplicate entries for the same item is confusing.
        ;; With settings below, I have the following behaviour when item is both scheduled and has
        ;; deadline:
        ;;  - If it is not deadline yet, then only scheduled entry is shown (be it late or not).
        ;;  - If the deadline is today or has passed, only deadline entry is shown.
        ;; NOTE: (org-agenda-skip-deadline-prewarning-if-scheduled t) will still show both scheduled
        ;;   and deadline entry if the deadline is today. That is why we also need
        ;;   (org-agenda-skip-scheduled-if-deadline-is-shown t), to solve that case.
        (org-agenda-skip-deadline-prewarning-if-scheduled t)
        (org-agenda-skip-scheduled-repeats-after-deadline t)
        (org-agenda-skip-scheduled-if-deadline-is-shown t)
       )
    )

    ;; TODO: Ok, now I have this as first step, but the next step is actually creating a
    ;; custom custom agenda block in which I will manually display the text I want.
    ;; From what I read, this means that I need to write a lambda that writes that
    ;; text to buffer. I will also want to add text properties that are typical for org agenda,
    ;; for example marker for place in org file from which the text originated,
    ;; so I can easily jump there. I can use text-describe to see how they do it and copy it.
    ;; So I will probably want to jump to "Journal" top level heading in the file,
    ;; then go down the date tree to the correct date, and show its content, or if none,
    ;; show "no entry yet" that jumps to the right place in the org file.
    ;; This function below might change in this process, but is a nice starting point.
    ;; TODO: Implement this based on the implementation of org-ql-block . Check function
    ;; below where I started.
    (defun my/org-entry-in-todays-datetree-p ()
      "Return t if the current Org entry is under today's datetree path."
      (let ((dt-heading-today-regex (format-time-string "\\b%Y-%m-%d\\b"))
            (current-org-entry-outline-path (org-get-outline-path t)))
        (not (null
              (cl-some
               (lambda (heading) (string-match dt-heading-today-regex heading))
               current-org-entry-outline-path)
        ))
      )
    )

    ;; TODO: Implement this based on the implementation of org-ql-block .
    ;; I just implemented something very dummy for now, it renders some text,
    ;; but at the start of the agenda buffer.
    (defun my/journal-agenda-block (arg1)
      "TODO"
      (org-agenda-prepare) ; Sets up the agenda buffer for us to write in it.
      (insert (org-add-props " Journal (today)" nil 'face 'org-agenda-structure) "\n")
      (insert " - This is some dummy entry\n - And this is another one")
      ;; TODO: Open the file with the journal (get it from arg1 or hardcode it?),
      ;; jump to the "Journal" heading, get to the right day heading, show its content/entries.
      ;; I might even want to create the datetree day heading (and its parents) if it doesn't exist.
      ;; Propertize the entries with correct org props so that one can easily jump into journal.
      ;;(insert (org-agenda-finalize-entries entries))  ; not needed?
      (insert "\n")
    )

    (defun my/make-work-diary-day-cmd (cmd-key cmd-name cmd-start-day)
      `(,cmd-key ,cmd-name
         (;; The main view: a list of tasks for today.
  	(agenda ""
  		(,@(my/make-work-diary-cmd-agenda-block-base-settings t t)
                   (org-agenda-span 'day)
  		 (org-habit-show-all-today t)
                   (org-agenda-time-grid '((daily remove-match)
                                           (800 1000 1200 1400 1600 1800 2000)
                                           " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"
                                          )
                   )
  		)
  	)
          (my/journal-agenda-block)
  	(alltodo ""
  		 ((org-agenda-overriding-header "")
  		  (org-agenda-prefix-format " %5e ")
  		  (org-super-agenda-groups
  		   '((:name "Notes" :order 1 :category "note")
                       (:name "Inbox" :order 2 :todo "INBOX")
                       (:name "Epics" :order 3 :todo "EPIC")
                       (:name "To read"
                              :order 5
                              :and (:category "task" :tag "read"))
  		     (:discard (:scheduled t :deadline t :time-grid t))
                       (:name "All tasks with no schedule / deadline"
                              :order 4
  			    :category "task")
  		     (:discard (:anything t))
  		    )
  		  )
  		 )
  	)
         )
         (,@(my/make-work-diary-cmd-base-settings)
          (org-agenda-start-day ,cmd-start-day)
         )
      )
    )

    (defun my/org-time-prefix-format (time)
      (if time
          (let* ((day3 (format-time-string "%a" time))
                 (day2 (cond ((string= day3 "Mon") "Mo")
                             ((string= day3 "Tue") "Tu")
                             ((string= day3 "Wed") "We")
                             ((string= day3 "Thu") "Th")
                             ((string= day3 "Fri") "Fr")
                             ((string= day3 "Sat") "Sa")
                             ((string= day3 "Sun") "Su")))
                 (dayNum (format-time-string "%d" time))
                )
              (format "%s%s" day2 dayNum)
          )
        "    "
      )
    )


    (defun my/org-scheduled-time-prefix ()
      (my/org-time-prefix-format (org-get-scheduled-time (point)))
    )

    (defun my/org-deadline-time-prefix ()
      (my/org-time-prefix-format (org-get-deadline-time (point)))
    )

    (let (;; TODO: Pull this info (current sprint tag, maybe also start day)
          ;;   from the work-diary.org file. I could have a heading there called Sprints
          ;;   with category "sprints" where each subheading is a single sprint.
          ;;   And each of those would have properties "sprint_tag" and "sprint_start_date"
          ;;   and similar. Maybe even not those properties, but instead just a tag :s<num>:
          ;;   and SCHEDULED set? Anyway, they would have that metadata on them, and I could
          ;;   pull it in, either for the first heading, or for the one tagged with :current:,
          ;;   something like that.
          (work-diary-sprint-current-tag "s42")
          (work-diary-sprint-start-weekday 3) ; 3 is Wednesday in org agenda.
          (work-diary-sprint-length-in-weeks 2)
         )
      (setq org-agenda-custom-commands
            (list
             (my/make-work-diary-day-cmd "d" "Work Diary: today"      nil)
             (my/make-work-diary-day-cmd "D" "Work Diary: tomorrow" "+1d")

             `("w" "Work Diary: sprint calendar"
               ((agenda ""
                        (,@(my/make-work-diary-cmd-agenda-block-base-settings nil nil)
                         (org-agenda-span ,(* 7 work-diary-sprint-length-in-weeks))
                         (org-agenda-time-grid '((require-timed remove-match)
                                                 ()
                                                 " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"
                                                )
                         )
                        )
                )
               )
               (,@(my/make-work-diary-cmd-base-settings)
                ;; NOTE: `org-agenda-start-on-weekday' works only if sprint length is 7 or 14 days.
                (org-agenda-start-on-weekday ,work-diary-sprint-start-weekday)
               )
              )

             `("A" "Work Diary: all tasks"
               ((alltodo ""
                         ((org-agenda-overriding-header "")
                          (org-agenda-prefix-format
                           " %(my/org-scheduled-time-prefix) %(my/org-deadline-time-prefix) %5e ")
                          (org-agenda-sorting-strategy '(scheduled-up
                                                         deadline-up
                                                         priority-down
                                                         todo-state-down
                                                         urgency-down)
                          )
                          (org-super-agenda-groups
                           '((:name ,(concat "Current sprint (" work-diary-sprint-current-tag ") tasks" )
                                    :order 0
                                    :and (:category "task" :tag ,work-diary-sprint-current-tag))
                             (:name "Epics"
                                    :order 1
                                    :and (:category "task" :todo "EPIC"))
                             (:name "Inbox"
                                    :order 2
                                    :and (:category "task" :todo "INBOX"))
                             (:name "To read"
                                    :order 4
                                    :and (:category "task" :tag "read"))
                             (:name "Tasks"
                                    :order 3
                                    :category "task")
                             (:discard (:anything t))
                            )
                          )
                         )
               ))
               (,@(my/make-work-diary-cmd-base-settings)
               )
              )

             '("p" "Private Diary"
               (;; The main view: a list of tasks for today.
                (agenda ""
                        ((org-agenda-span 'day)
                         (org-agenda-prefix-format " %12s %5e ")
                         (org-agenda-sorting-strategy '(todo-state-down priority-down urgency-down effort-down))
                         (org-habit-show-all-today t)
                         (org-super-agenda-groups
                          '((:name "Habits"
                                   :and (:category "habit"
                                         :not (:log t))
                            )
                            ;; Tasks to be done today.
                            (:name "Todo"
                                   :and (:category "task"
                                         :scheduled t
                                         :not (:scheduled future)
                                         :not (:log t))
                            )
                            ;; Tasks that were done today.
                            (:name none
                                   :and (:category "task"
                                         :log closed)
                            )
                           )
                         )
                        )
                )
                ;; All tasks without a schedule or a deadline.
                (alltodo ""
                         ((org-agenda-overriding-header "")
                          (org-agenda-prefix-format " %5e ")
                          (org-super-agenda-groups
                           '((:discard (:scheduled t :deadline t :time-grid t))
                             (:name "All tasks with no schedule / deadline"
                                    :category "task"
                             )
                             (:discard (:anything t))
                            )
                          )
                         )
                )
               )
               ((org-agenda-files `("~/Dropbox/private-diary.org" ,my/calendar-events-private-org-file))

                (org-agenda-start-with-log-mode '(closed clock))
                (org-agenda-skip-scheduled-if-done t)
                (org-agenda-skip-deadline-if-done t)

                (org-agenda-skip-deadline-prewarning-if-scheduled t)
                (org-agenda-skip-scheduled-repeats-after-deadline t)
               )
              )
            )
      )
    )
  ))

  (defun my/work-diary-open-sprint-planning-windows ()
    "Open windows for sprint planning."
    (interactive)
    (org-toggle-sticky-agenda 1) ; This is needed to allow two agendas at the same time.
    (org-agenda nil "w")
    (delete-other-windows)
    (org-agenda nil "A")
  )
  (my/leader-keys
    "op"  '("planning view" . my/work-diary-open-sprint-planning-windows)
  )

#+end_src

*** TODO Add manual sorting of agenda entries
If I define ~org-agenda-cmp-user-defined~ then I can in ~org-agenda-sorting-strategy~ say that I use ~user-defined-up~ (or ~down~). I could define it to take a look at some custom ~order~ org property that I will define commands and keybindings to easily change in org agenda and that way I get manual sorting of entries in agenda.
I will probably want to put right after sorting by timestamp or maybe even first.
*** TODO Explore org-ql
It gives a lot of control over what I want to show in agenda. I could use it to build some very custom agenda views, for example all tasks from the sprint, or something like that. Not sure yet but I think it is worth exploring it for creating additional custom agenda commands.
** Capture templates

#+begin_src emacs-lisp :noweb yes

  (let* ((wd-path "<<my/work-diary-org-path()>>")
         (wd-tasks `(file+headline ,wd-path "Tasks"))
        )
    (setq org-capture-templates
          `(("t" "Task" entry ,wd-tasks
             "** TODO %?")
            ("T" "Task (today)" entry ,wd-tasks
             "** TODO %?\nSCHEDULED: %t")
            ("n" "Task (now)" entry ,wd-tasks
             "** TODO %?\nSCHEDULED: %t" :clock-in t :clock-keep t)
            ("i" "Task (inbox)" entry ,wd-tasks
             "** INBOX %?" :prepend t)
            ("j" "Journal" item (file+olp+datetree ,wd-path "Journal")
             "%?" :unnarrowed t)
           )
    )
  )

#+end_src

*** TODO Read more about it [0/1]
- [ ] https://www.reddit.com/r/emacs/comments/7zqc7b/share_your_org_capture_templates/
** Cheatsheet :cheatsheet:
- Shift-Tab -> cycles through expanding headers. Can be used to fold all but the current item -> Shift-Tab to fold all, then Tab to unfold current item.
- structure templates (snippets) -> type "<snippetstringTAB" to expand it to snippet. e.g. "<el". Be faster than completion or reject it first with C-g.
- org-babel is org package (comes with org) that allows execution of code blocks, sharing data between code blocks (polyglot), tangling (exporting code into file / literal programming), ... .
- When in code block, to get full support for that language (proper completion, ...), open it in separate buffer with "C-c '" and do the editing there.
* My buffer/file functions

#+begin_src emacs-lisp

  (use-package emacs
    :ensure nil
    :config
    (defun my/alternate-buffer (&optional window)
      "Switch back and forth between current and last buffer in the current window."
      (interactive)
      (cl-destructuring-bind (buf start pos)
        (or (cl-find (window-buffer window) (window-prev-buffers) :key #'car :test-not #'eq)
            (list (other-buffer) nil nil)
        )
        (if (not buf)
          (message "Last buffer not found.")
          (set-window-buffer-start-and-point window buf start pos)
        )
      )
    )

    (defun my/open-init-file ()
      "Open the init file."
      (interactive)
      (find-file user-init-file)
    )

    (defun my/open-emacs-org-file ()
      "Open the init file."
      (interactive)
      (find-file (my/emacs-org-file-path))
    )

    (defun my/emacs-org-file-path ()
      (expand-file-name (file-name-concat user-emacs-directory "Emacs.org"))
    )

    (defun my/switch-to-messages-buffer ()
      "Switch to the messages buffer."
      (interactive)
      (switch-to-buffer "*Messages*")
    )
  )

#+end_src

* Ivy, Counsel and Swiper
** ivy

#+begin_src emacs-lisp

    ;; Ivy is the main thing (nice search through list of stuff, in minibuffer and elsewhere),
    ;; while Counsel and Swiper extend its usage through more of the Emacs.

    ;; TODO: Check out Ivy hydra -> I saw it in Ivy manual but don't know how to use it (it doesn't seem to be installed?).
    ;;   Allegedly (use-package ivy-hydra :after (ivy hydra)) should do the job? Try it.
    ;; TODO: Should I set Ivy to use fuzzy search? Is that better or not?
    ;; TODO: In Spacemacs (helm), coloring of listed files on C-x C-f is richer than I have in Ivy here.
    ;; Directories have stronger contrast, hidden files are grey, symbolic links neon, ... .
    ;; I should also get Ivy to behave like this! Right now it shows dirs in too similar color uses the same
    ;; color for all the rest.
    ;;   TODO: Show this cheatsheet somehow as part of Ivy buffers? Kind of like Helm does in Spacemacs?
    (use-package ivy
      :bind (
            ;; I define some evil-ish keybindings here since neither evil not evil-connection
            ;; define these specific ones for Ivy.
            :map ivy-minibuffer-map ;; When in the minibuffer.
                  ("C-h" . ivy-backward-kill-word)
                  ("C-j" . ivy-next-line)
                  ("C-k" . ivy-previous-line)
                  ("C-l" . ivy-alt-done)
                  ("TAB" . ivy-alt-done)
            :map ivy-switch-buffer-map ; When in the buffer switching mode.
                  ("C-j" . ivy-next-line)
                  ("C-k" . ivy-previous-line)
                  ("C-l" . ivy-done)
                  ("C-d" . ivy-switch-buffer-kill)
            :map ivy-reverse-i-search-map ; When doing incremental search.
                  ("C-j" . ivy-next-line)
                  ("C-k" . ivy-previous-line)
                  ("C-l" . ivy-done)
                  ("C-d" . ivy-reverse-i-search-kill)
            )
      :custom
      (ivy-height 20)
      (ivy-use-virtual-buffers t)  ; Adds recent files and bookmarks and similar to results.
      (ivy-display-style 'fancy)
      (ivy-count-format "(%d/%d) ")  ; (num listed / total num)
      (ivy-extra-directories nil)  ; Don't show ./ and ../
      :config
      ;; ivy-format-functions-alist determines for each place where ivy is used how the output should be formatted.
      ;; t stands for default case, if there was no more specific formatting function defined.

      ;; Here, we specify which formatting function to use as a default case (t).
      ;; We choose ivy-format-functon-line, that extends the higlight of selection to the edge of the window,
      ;; not just till the end of the selected word. This is one of default choices and it looks better.
      ;; This is recommended by ivy-rich, as a setting.
      (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-arrow-line)

      ;; ivy-re-builders-alist defines which completion styles (fuzzy, in order, ...) to use for which ivy usage.
      ;; Here I define that we use ivy--regex-ignore-order for all situations, instead of the default ivy--regex-plus,
      ;; which is the same but cares about the order of words in the query, which I found to not be useful.
      (setq ivy-re-builders-alist
            '((t . ivy--regex-ignore-order)))

      ;; ivy-initial-inputs-alist defines what to start specific searches with. Default is ^ for all searches,
      ;; which makes queries start from the start of each completion candidate, but I set it to nil to avoid that.
      (setq ivy-initial-inputs-alist nil)

      ;; This will enhance specific emacs commands with ivy automatically.
      (ivy-mode 1)
    )

#+end_src

*** Cheatsheet :cheatsheet:
- M-o when in an Ivy buffer shows extra commands that can be run on selected completion item.

** counsel

#+begin_src emacs-lisp

  ;; Counsel is a package that is part of Ivy ecosystem.
  ;; It brings enhanced versions of common emacs commands, powered by Ivy.
  ;; Ivy already offers some enhanced commands, but Counsel offers more and better.
  (use-package counsel
    :config
    (setq counsel-describe-function-function 'helpful-callable)
    (setq counsel-describe-variable-function 'helpful-variable)
    (counsel-mode 1)  ; This will remap the built-in Emacs functions that have counsel replacements.
  )

#+end_src

** swiper

#+begin_src emacs-lisp

  ;; Swiper is a package that is part of Ivy ecosystem.
  ;; Better isearch (incremental search), powered by Ivy.
  (use-package swiper
    :bind (("C-s" . swiper)
           :map evil-normal-state-map
           ("/" . swiper)
           ("*" . swiper-thing-at-point)
           :map evil-motion-state-map
           ("/" . swiper)
           ("*" . swiper-thing-at-point)
          )
  )

#+end_src

** ivy-rich

#+begin_src emacs-lisp

  ;; Show more info for some usages of Ivy. Also allows easier customization of Ivy output.
  (use-package ivy-rich
    :after (ivy counsel)
    :config
    ;; This is my custom function for how Ivy shows candidates when finding a file.
    ;; Unlike default function used by ivy(-rich), here I do some additional formatting:
    ;;  - I stylize dot(files/dirs).
    ;;  - I stylize executables.
    (defun my/ivy-read-file-transformer (filename)
      "Transform candidate STR when reading files."
      (let*
        ((current-dir (or (ivy-state-directory ivy-last) default-directory))
        (filepath (expand-file-name filename current-dir))
        (is-dir (ivy--dirname-p filename))
        (is-dotfile (string-prefix-p "." filename))
        (is-exec (file-executable-p filepath))
        )
        (cond
  	((and is-dir is-dotfile) (propertize filename 'face '(:inherit (font-lock-comment-face ivy-subdir))))
  	(is-dotfile (propertize filename 'face 'font-lock-comment-face))
  	(is-dir (propertize filename 'face 'ivy-subdir))
  	(is-exec (propertize filename 'face 'font-lock-keyword-face))
  	(t filename)
        )
      )
    )

    ;; With ivy-rich-set-columns, you can add new ones or replace existing columns when ivy is used in specific commands.
    ;; For details check out ivy-rich docs and docs of ivy-rich-display-transformers-list .
    (ivy-rich-set-columns
      'counsel-find-file  ; Set columns for this command (therefore when finding file).
      '((my/ivy-read-file-transformer)  ; Use my function instead of default ivy-read-file-transformer.
        (ivy-rich-counsel-find-file-truename (:face font-lock-doc-face))  ; This I kept the same. It adds target for links.
       )
    )

    (ivy-rich-mode 1)
  )

#+end_src

* Projectile

#+begin_src emacs-lisp
  
  ;; Projectile brings the concept of "Project" to emacs, as a project on the disk.
  (use-package projectile
    :init
    ;; First thing that happens on switching to a new project.
    ;; TODO: Try without this, see if I like that better or not, or if I would like something else.
    (setq projectile-switch-project-action #'projectile-dired)
    :bind-keymap
    ("C-c p" . projectile-command-map) ; TODO: Get this behind SPC.
    :custom
    ((projectile-completion-system 'ivy))
    :config
    (projectile-mode)
  )

  ;; Provides better integration of Projectile and Counsel.
  (use-package counsel-projectile
    :config
    (defun counsel-projectile-rg-region-or-symbol ()
      "Search for selected region if active, otherwise search for symbol at point using `counsel-projectile-rg`."
      (interactive)
      (let ((counsel-projectile-rg-initial-input (projectile-symbol-or-selection-at-point)))
          (counsel-projectile-rg)
      )
    )

    (counsel-projectile-mode)
  )

#+end_src

** Cheatsheet :cheatsheet:
- Projectile recognizes projects with its heuristics (.git/, maven files, ...), but you can add .projectile file to the project root to explicitly mark it as a project.

* VC (Version Control)

#+begin_src emacs-lisp

  (my/leader-keys
    "g" '("git (version control)" . (keymap))
    "gc" '("resolve conflicts (simple)" . smerge-mode)
    "gC" '("resolve conflicts (advanced)" . smerge-ediff)
  )

#+end_src

- On diffing and merge conflict resolution in emacs ::
  - *General diffing* ::
    =diff= and =ediff= are two common ways in emacs to look at the general difference between buffers/files, =diff= being a simpler option, and =ediff= being a complex one. E.g. there is ~diff~ to check diff between two files, ~diff-buffer-with-file~ to check buffer against file, ... .
  - *Merge conflict resolution* ::
    - =smerge-mode= and =smerge-ediff= are two popular, emacs built-in, ways to resolve merge conflicts, so you don't have to edit the file with conflicts completely manually.
      - =smerge-mode= is simple to use and enough for most of the use cases. It highlights the diffs in the file and offers useful commands for resolving them easily, while letting you manually edit them as normally. So it is not invasive, more like extra capabilities added on top of completely manual workflow, it doesn't introduce its own "view".
      - =smerge-ediff= is more powerful but also quite more complex. It takes you into its own "view" where is visually shows the diff via two buffers + introduces its own keybindings for resolving the conflicts that you then have to use to work with it. I am not sure if you can do manual edits from =ediff='s view or you have to go out of it. People say it is really powerful, but also often overkill and hard to figure out.
    - There is also =vdiff= as a third-party alternative, which also takes over with its own view, similar like =ediff=, but in that view it let's you normally edit the buffers + does more detailed highlighting of changes (allegedly) + is more intuitive to use / has nicer DX. It sounds like a compelling alternative to =ediff=.
    - In =magit=, in its status buffer, if there is a file with merge conflict, pressing ENT will take us to file and open it with =smerge-mode=, while pressing =e= on it will take us to =smerge-ediff= mode. It adds a bit of etra niceties to these in that workflow.
    - Here is also a nice link to magit docs, where they explain /resolving conflicts/ at a high level + show how to do it in =magit=: https://magit.vc/manual/magit/Resolving-Conflicts.html .

** TODO Add a hydra for smerge-mode, to make it easy to run smerge commands in it. Search online for it.
- https://www.reddit.com/r/emacs/comments/a5dmbm/the_fastest_mergeconflict_resolver_in_emacsland/
  - https://github.com/alphapapa/unpackaged.el?tab=readme-ov-file#hydra
- https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-diff.el#L181

** TODO Configure ediff to work nicer
- found this on reddit:
  #+begin_src emacs-lisp
    '(ediff-split-window-function (quote split-window-horizontally))
    '(ediff-window-setup-function (quote ediff-setup-windows-plain))
  #+end_src
- search for more

** TODO Consider setting up vdiff (as an alternative to ediff)
- https://github.com/justbur/emacs-vdiff
- Allegedly it makes more sense, you can more normally edit the buffers and DX is more intuitive.
  If you also add a hydra, you get the best DX.

** gitstatus.el

=gitstatus.el= gives us an easy way to generate a nice git status message for specific directory.
It is basically a wrapper that calls =gitstatusd= program in the background.

#+begin_src emacs-lisp

  (use-package gitstatus
    :custom
    (gitstatusd-exe "~/.local/bin/gitstatusd")
    (gitstatus-prefix nil)
  )

#+end_src

*** Installing =gitstatusd= on your machine :manual_setup:
Ensure =gitstatus= (which provides =gitstatusd= binary) is installed on your machine.
If it isn't already, you can download the latest binary from the [[https://github.com/romkatv/gitstatus][Github releases]] and e.g. put it into =~/.local/bin/= dir.
Then, make sure that ~gitstatusd-exe~ is set to the path to that binary.
TODO: Figure out why default value of ~gitstatusd-exe~, which is just ~gitstatusd~, doesn't work even when the binary is in PATH, and instead I have to set the exact path. Because if I can make that work that is great, I don't have to adjust the path above manually then.

** Magit

#+begin_src emacs-lisp

  ;; NOTE: I installed transient not because I use it directly, but because magit
  ;;   needs a newer version of it than what comes with emacs by default, and this
  ;;   takes care of it. If magit at some point stops needing it, I can remove this.
  (use-package transient)

  ;; Magit is all you need to work with git.
  ;; TODO: I had to explicitly install new transient above to get magit to work because
  ;;   it expects a newer version than what emacs ships with. Once I update emacs
  ;;   or magit, drop the :after transient and remove (use-package transient) unless
  ;;   I also use it for something else.
  (use-package magit
    :after transient
    :defer t
  )
  ;; I define this outside of (use-package magit) because later is deferred.
  (my/leader-keys
    "gg" 'magit
  )

#+end_src

*** Cheatsheet                                                 :cheatsheet:
Some key combos I often use in magit:
- ~S~ -> stage all changes.
- ~c c~ -> commit all staged changes. ~C-c C-c~ to save commit message while editing it.
- ~h P u~ -> push to origin.

** Highlight lines
=diff-hl= package highlights lines that were modified (compared to versioned state of the file).
It adds indicator to the left margin/side of the window.

#+begin_src emacs-lisp

  (use-package diff-hl
    :config
    (global-diff-hl-mode)
    (my/leader-keys
      "gn" '("next change" . diff-hl-next-hunk)
      "gp" '("previous change" . diff-hl-previous-hunk)
      "gr" '("set ref rev (global)" . diff-hl-set-reference-rev) ;; NOTE: It sets this globally, so in other projects it will cause weird behaviour!
      "gR" '("reset ref rev (global)" . diff-hl-reset-reference-rev)
    )
  )

#+end_src

*** Cheatsheet :cheatsheet:
- ~diff-hl-set-reference-rev~ allows you to define against what are differences shown. E.g. you can set it to =master= to see what changes feature branch branching from =master= introduced.
* Company

#+begin_src emacs-lisp

  ;; TODO: Fix highlight and search faces in tooltip/popup, or have theme that makes them nice. Company has faces that we can customize.
  ;; TODO: Either make scroll more visible, or use lines instead.
  (use-package company
    :custom
    (company-idle-delay 0.2)
    (company-minimum-prefix-length 1)
    (company-selection-wrap-around t)
    (company-format-margin-function 'company-text-icons-margin)
    (company-text-face-extra-attributes '(:weight semi-light :slant italic))
    ;; I found default icons (be it vscode or text) to be too hard to understand,
    ;; so I made my own mapping here that provides more info. For the context, icons are
    ;; short descriptions left of the completion candidates in the popup.
    (company-text-icons-mapping
    '((array          "   []" font-lock-type-face)
      (boolean        " bool" font-lock-builtin-face)
      (class          "class" font-lock-type-face)
      (color          "color" success)
      (constant       "const" font-lock-constant-face)
      (constructor    "cnstr" font-lock-function-name-face)
      (enum-member    "enumv" font-lock-builtin-face)
      (enum           " enum" font-lock-builtin-face)
      (field          "field" font-lock-variable-name-face)
      (file           " file" font-lock-string-face)
      (folder         "  dir" font-lock-doc-face)
      (interface      " intf" font-lock-type-face)
      (keyword        "  kwd" font-lock-keyword-face)
      (method         " mthd" font-lock-function-name-face)
      (function       " func" font-lock-function-name-face)
      (module         "  mdl" font-lock-type-face)
      (numeric        "  num" font-lock-builtin-face)
      (operator       "   op" font-lock-comment-delimiter-face)
      (property       " prop" font-lock-variable-name-face)
      (reference      "  ref" font-lock-doc-face)
      (snippet        " snip" font-lock-string-face)
      (string         "  str" font-lock-string-face)
      (struct         "strct" font-lock-variable-name-face)
      (text           " text" shadow)
      (type-parameter "typep" font-lock-type-face)
      (unit           " unit" shadow)
      (value          "  val" font-lock-builtin-face)
      (variable       "  var" font-lock-variable-name-face)
      (t              "    ." shadow))
    )
    :config
    (global-company-mode 1)
  )

#+end_src

** TODO Find a way to also show additional docs next to each item. E.g. company-box
But company-box currently overrides my setting for company-text-icons-mapping with its icons and is for some reason slow.

** Cheatsheet :cheatsheet:
- C-s to search among the candidates. C-M-s to not just highlight but also filter. C-g to quit search mode.
  
* Terminal (shell)

There are different ways to use terminal / shell in Emacs. There are implementations that are completely done in elisp, there are implementations that support all that normal terminal does, and then there are does that don't support ncurses / TUI or all ansi codes.

I chose ~vterm~ because it uses external ~libvterm~ implementation of a terminal in C, which means it is fast, stable, and supports everything that a terminal should. It is also very popular and well supported.

#+begin_src emacs-lisp

  ;; Requires some stuff like cmake, support for modules in emacs, libtool-bin, but most systems /
  ;; emacses have all those ready, so usually you don't have to think about it.
  (use-package vterm
    ;; hl-line highlight flickers in vterm, so we turn it off.
    ;; Relevant github issue: https://github.com/akermu/emacs-libvterm/issues/432 .
    :hook (vterm-mode . (lambda () (setq-local global-hl-line-mode nil)))
    :config
    (defun my/vterm-new ()
      (interactive)
      (vterm t)
    )
    (my/leader-keys
      "\"" '("new terminal" . my/vterm-new)
    )
    (evil-define-key 'normal vterm-mode-map (kbd "C-p") 'vterm-send-up)
    (evil-define-key 'normal vterm-mode-map (kbd "C-n") 'vterm-send-down)
  )

  ;; Allows easy toggling of terminal(vterm) window.
  (use-package vterm-toggle
    :after (vterm)
    :config
    (my/leader-keys
      "'" '("toggle terminal" . vterm-toggle)
    )
    ;; If I press C-return after toggling to terminal window, it will insert `cd` command that takes
    ;; me to dir of previous buffer! Very useful.
    (define-key vterm-mode-map [(control return)] #'vterm-toggle-insert-cd)
  )

#+end_src

** My custom hook that triggers on prompt in vterm

#+begin_src emacs-lisp

  (with-eval-after-load 'vterm
    (defvar my/vterm-prompt-hook nil "A hook that runs each time the prompt is printed in vterm.")

    (defun my/run-vterm-prompt-hooks ()
      "Runs my/vterm-prompt-hook hooks."
      (run-hooks 'my/vterm-prompt-hook)
    )

    (with-eval-after-load 'vterm
      ;; If OSC sequence "prompt" is printed in the terminal, `my/run-vterm-prompt-hook'
      ;; will be run.
      (add-to-list 'vterm-eval-cmds '("prompt" my/run-vterm-prompt-hooks))
    )
  )

#+end_src

*** Adding special OSC sequence to the prompt :manual_setup:
In order for us to be able to detect the prompt and run the hooks based on it, terminal prompt needs to contain the OSC sequence ~\[\e]51;Eprompt\a\]~.
Check [[*Shell-side configuration for vterm]] below for exact details.

** My custom header line in vterm (git status, path)

On vterm mode (so effectively for any new vterm buffer), I set a header line for that buffer that shows current working directory and its git status.
In Emacs, header line refreshes on every buffer change, and its ~:eval~ forms are evaluated every time.
Since calculation of git status is both somewhat expensive and done asynchronously (by =gitstatusd=), I don't do it directly in the ~:eval~ form.
Instead, I use an intermediary variable ~my/vterm-git-status-string~ that is evaled/read in header line via ~:eval~, and is separately updated by the git status calculation, which is run only on every new prompt in the terminal.

#+begin_src emacs-lisp

  (with-eval-after-load 'vterm
    (defvar-local my/vterm-git-status-string nil
      "A pretty string that shows git status of the current working directory in vterm.")

    ;; TODO: Sometimes, vterm hides top line under the header-line. But not always. It starts in right
    ;; place, and commands like "go to first line" work correctly, but I press enter and new line in
    ;; vterm appears, whole buffer shifts for one line up and the first line becomes hidden. Figure
    ;; out how to fix this.
    (defun my/vterm-set-header-line ()
      "Display the header line that shows vterm's current dir and git status.
  It gets git status string from `my/vterm-git-status-string' variable each time it renders."
      (setq header-line-format
            '((:eval (when my/vterm-git-status-string (concat " " my/vterm-git-status-string " ❯ ")))
              (:propertize
               (:eval (abbreviate-file-name default-directory))
               face font-lock-comment-face
              )
             )
      )
      ;; Setting :box of header line to have an "invisible" line (same color as background) is the trick
      ;; to add some padding to the header line.
      (face-remap-add-relative
       'header-line
       `(:box (:line-width 6 :color ,(face-attribute 'header-line :background nil t)))
      )
    )
    (add-hook 'vterm-mode-hook 'my/vterm-set-header-line)

    (with-eval-after-load 'gitstatus
      (defun my/obtain-vterm-git-status-string ()
        "Obtains the git status for the current directory of the vterm buffer.
  It builds a pretty string based showing it and stores it in `my/vterm-git-status-string' var.
  It uses external `gitstatusd' program to calculate the actual git status."
        (gitstatusd-get-status
         default-directory
         (lambda (res)
           (let ((status-string (gitstatus-build-str res)))
             (when (not (equal my/vterm-git-status-string status-string))
               (setq my/vterm-git-status-string (gitstatus-build-str res))
               (force-mode-line-update)
             )
           )
         )
        )
      )
      (add-hook 'my/vterm-prompt-hook 'my/obtain-vterm-git-status-string)
    )
  )

#+end_src

** Shell-side configuration for vterm :manual_setup:

Some of the most useful vterm features require us to do a bit of configuration of the shell on our system. We can do without it, but we will be missing some of the functionality.
=vterm= brings that config, for our convenience, as one .sh file that we need to load in our .bashrc.
This can be done with the snippet below, by putting it into =.bashrc= (as per vterm docs).
It assumes vterm's =etc/= dir is next to where vterm is installed. This was true for me when installing it via Elpaca.

#+begin_src bash :tangle no

  if [[ "$INSIDE_EMACS" = 'vterm' ]] \
      && [[ -n ${EMACS_VTERM_PATH} ]] \
      && [[ -f ${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh ]]; then
          source ${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh
  fi

#+end_src

To override the default prompt to be much simpler (since I show info from it in the header line, check [[*My custom header line in vterm (git status, path)]]), add the following snippet into =.bashrc=, somewhere after the prompt (~PS1~) definition:
*NOTE*: This ~\[\e]51;Eprompt\a\]~ at the end is OSC sequence I added to detect the prompt and to be able then to run functions based on its appearance (check ~vterm-eval-cmds~, and ~my/vterm-prompt-hook~). For more details check [[*My custom hook that triggers on prompt in vterm]] .

#+begin_src bash :tangle no

  if [ "$INSIDE_EMACS" = 'vterm' ]; then
    export PS1="${Bold}${Purple}Ɛ ∷ ${Color_Off}\[\e]51;Eprompt\a\]"
  fi

#+end_src

*** TODO Might be cool if I could tangle these code snippets directly into .bashrc, or a separate file that .bashrc will load. Then this would become real part of emacs config instead of a manual step.
** Cheatsheet :cheatsheet:
- After toggling to terminal window, press C-return to cd into parent dir of previous buffer.
- To execute commands like Ctrl-C or Ctrl-D, prefix them with `C-c`, so e.g. `C-c C-c` or `C-c C-d`.


** TODO Try "eat" terminal
** TODO Explore multi-vterm package.

* Spell checking
Flyspell is a builtin spell-checking frontend for Emacs, but there are also popular community packages, one of the lately most popular being Jinx, which I use here.

Main concept with all spell-checking frontends is that you have to install an actual spell-checker, that is not emacs-specific, on your system, and they use it as a backend. Most popular are Aspell and Hunspell, while Enchant is a wrapper on top of all these that does some extra smart stuff. Jinx uses Enchant.

** Jinx

Jinx uses Enchant program on your machine, which uses spelling backends like hunspell and/or aspell, which use their dictionaries for specific languages.

#+begin_src emacs-lisp

  (use-package jinx
    :config
    (setq jinx-languages "en_us")
    (my/leader-keys
      "tc"  '("spell checking" . jinx-mode)
    )
  )

#+end_src

*** Manual setup                                             :manual_setup:

On Arch, install ~enchant~ and ~pkgconf~.
Enchant needs to use some spelling backend, so also install e.g. ~hunspell~ (and make sure it is using it when I expect, file =/usr/share/enchant-2/enchant.ordering= on Arch defines that).
Finally, that backend needs dictionaries for the languages I want to spell-check, so e.g. if I want english, I should install ~hunspell-en_us~.
I can check backend and dictionaries that Enchant is picking up by running ~enchant-lsmod-2 -list-dicts~.

*** Cheatsheet :cheatsheet:

Run ~jinx-correct~ to correct the word at point.

* Syntax/error checking
** Flycheck

Flycheck is the central package for syntax checking, a "frontend" for code-related errors.
Given backend(s) (e.g. LSP, linter, ...) that supply errors (and warnings, info, ...), it collects errors from them and visualizes and manipulates them in a unified way.
It marks the affected piece of code visually (squigly lines), gives a way to move through the errors quickly, ... .
By default, it shows full error message(s) in the minibuffer when cursor is at the place of the error.

I currently configured it in the following way:
- I configure backends per language, but most often it is LSP.
- Instead of showing full error(s) in minibuffer when point/cursor is at the place of error, Flycheck shows short error message (1 line) via the sideline.
- If I want to see the full error message at point/cursor, I have a command (and keybinding) I can invoke to do so.

#+begin_src emacs-lisp

  (use-package flycheck
    :init (global-flycheck-mode)
    :custom
    (flycheck-display-errors-delay 0) ; Default value is 0.9.
    :config
    (my/leader-keys
      "en"  '("next" . flycheck-next-error)
      "ep"  '("previous" . flycheck-previous-error)
      "el"  '("list" . flycheck-list-errors)
    )
  )

#+end_src

#+begin_src emacs-lisp

  ;; Shows flycheck errors/warnings in a popup, instead of a minibuffer which is default.
  ;; I configured it so it doesn't show them on cursor, as is default, but on request.
  (use-package flycheck-posframe
    :after flycheck
    :custom
    (flycheck-posframe-border-width 10)
    (flycheck-posframe-prefix nil)
    ;; Don't show errors automatically on cursor, since below we define a manual way to invoke
    ;; showing of errors at point. I do it this way because I configured automatic showing of first
    ;; line of errors in the sideline, so I don't need to also see the whole error all the time,
    ;; instead I will rather invoke it manually when I want to see the whole of it.
    (flycheck-display-errors-function nil)
    :config
    (set-face-attribute 'flycheck-posframe-warning-face nil :inherit 'warning)
    (set-face-attribute 'flycheck-posframe-error-face nil :inherit 'error)
    ;; TODO: Make the posframe(popup) visually nicer.

    (defun my/show-flycheck-errors-posframe-at-point ()
      (interactive)
      (let* ((errs (flycheck-overlay-errors-at (point))))
        (flycheck-posframe-show-posframe errs)
      )
    )
    (my/leader-keys
      "ee" '("(un)expand" . my/show-flycheck-errors-posframe-at-point)
    )
  )

#+end_src

*** Show errors inline                                              :inactive:

While I got this to work quite nicely, I found that code inline can be pretty confusing, as it keeps popping in and out and moving the code you are reading, even when you don't care about the error at that moment.
Showing just one line by default helped, but I still didn't like it, and ended up going instead for the sideline for 1 line and then posframe for the full error.

#+begin_src emacs-lisp :tangle no

  ;; Shows flycheck errors/warnings inline (in code, below the cursor), instead of a minibuffer which is default.
  (use-package flycheck-inline
    :after (quick-peek)
    :hook (flycheck-mode . flycheck-inline-mode)
    :config

    ;;; Below I configure stuff quite heavily!
    ;;; We display only first line for each error + define a command for (un)expanding errors under the cursor/point.
    ;;; We use quick-peek for nice borders around the overlay.

    (defvar my/expanded-flycheck-errors nil
      "List of flycheck errors that are to be shown with a full message.")

    (defun my/toggle-flycheck-errors-expansion-at-point ()
      "Adds flycheck errors at point to the list of expanded errors if not already expanded.
       If already in the list, it removes them from the list."
      (interactive)
      (let* ((errs (flycheck-overlay-errors-at (point))))
        (setq my/expanded-flycheck-errors (if (cl-intersection errs my/expanded-flycheck-errors) nil errs))
      )
    )
    (my/leader-keys
      "ee" '("(un)expand" . my/toggle-flycheck-errors-expansion-at-point)
    )

    (defun my/shorten-flycheck-error-message (msg)
      "Shorten the error message MSG to the first line, adding ellipsis if so."
      (let ((lines (split-string msg "\n")))
        (if (> (length lines) 1)
            (concat (car lines) (propertize " …" 'face 'bold))
          (car lines)
        )
      )
    )

    ;; Use quick-peek to show errors in a nicer way (with bars).
    ;; If error is in the my/expanded-flycheck-errors list, I show its full message,
    ;; if not, I show shortened version of it.
    (setq flycheck-inline-display-function (lambda (msg pos err)
  					   (let* ((ov (quick-peek-overlay-ensure-at pos))
  						  (contents (quick-peek-overlay-contents ov))
                                                    (show-full-msg (member err my/expanded-flycheck-errors))
  						 )
  					     (setf (quick-peek-overlay-contents ov)
  						   (concat contents
  							   (when contents "\n")
  							   (if show-full-msg msg (my/shorten-flycheck-error-message msg)))
  					     )
  					     (quick-peek-update ov)
                                             )
  					 )
  	flycheck-inline-clear-function 'quick-peek-hide
    )
  )

#+end_src

** Flymake                                                          :inactive:

Im not using it for now since I managed to set up Flycheck quite well, but I might want to try it out in the future again.

#+begin_src emacs-lisp :tangle no

  (use-package flymake
    :ensure nil ; It already comes with emacs, so we tell elpaca not to install it.
    :hook (prog-mode . flymake-mode)
    :custom
    (flymake-no-changes-timeout 0.2)
    :config
    (my/leader-keys
      "en"  '("next" . flymake-goto-next-error)
      "ep"  '("previous" . flymake-goto-prev-error)
      "el"  '("list (buffer)" . flymake-show-buffer-diagnostics)
      "eL"  '("list (project)" . flymake-show-project-diagnostics)
    )
  )

  (use-package flymake-posframe
    :ensure (:host github :repo "Ladicle/flymake-posframe")
    :hook (flymake-mode . flymake-posframe-mode)
  )

#+end_src

* Sideline

=sideline= package shows information (e.g. errors) inline with the code, but on the right (or left) edge of the screen.
It shows that infomation in a smart way, to minimally disrupt the existing code.

You can plug in multiple backends into it, and it will display the information uniformly.

#+begin_src emacs-lisp

  (use-package sideline
    :hook ((flycheck-mode lsp-mode) . sideline-mode)
    :init
    ;; `up` means it is shown above the line where cursor is, `down` means beneath it.
    (setq sideline-backends-right '((sideline-flycheck . up)
  				  (sideline-lsp . down)))
  )

  (use-package sideline-flycheck 
    :hook (flycheck-mode . sideline-flycheck-setup)
    :custom
    ;; I want to show only short version of errors, otherwise it becomes a mess.
    ;; If I need to see the full error, I have other methods to do that (e.g. flycheck-posframe).
    (sideline-flycheck-max-lines 1)
    :config
    (set-face-attribute 'sideline-flycheck-error nil
  		      :slant 'italic
  		      :background "black")
    (set-face-attribute 'sideline-flycheck-warning nil
  		      :weight 'light
  		      :slant 'italic
  		      :background "black")
    (set-face-attribute 'sideline-flycheck-success nil
  		      :weight 'light
  		      :slant 'italic
  		      :background "black")
    ;; TODO: Somehow define following prefixes ✖ ⓘ ⚠ for errors / warning / success?
  )

  ;; From LSP directly, I show only code actions in the sideline.
  ;; The rest of the information I show in other way (via flycheck, via minibuffer, popups, ...).
  ;; Note that flycheck again sends some of that information to sideline though.
  (use-package sideline-lsp
    :custom
    ;; By setting this to nil, lsp diagnostics (errors, warnings) get sent to flycheck, which we prefer since
    ;; it is a more standard / specific way to do it.
    (sideline-lsp-show-diagnostics nil)
    (sideline-lsp-show-hover nil) ; This I already show in minibuffer (eldoc) or in popup (lsp-ui-doc).
    (sideline-lsp-show-symbol nil) ; This I didn't find useful.
    (sideline-lsp-show-code-actions t) ; But I do find it useful to see code actions.
    (sideline-lsp-code-actions-prefix "✎ ")
    (sideline-lsp-actions-kind-regex "quickfix.*") ; Show only quickfix code actions, otherwise it is too much noise.
    :config
    (set-face-attribute 'sideline-lsp-code-action nil
                        :inherit 'shadow
                        :weight 'light
  		      :slant 'italic
  		      :background "black")
  )

#+end_src

* Folding

#+begin_src emacs-lisp

  (use-package hideshow
    :ensure nil ; emacs built-in
    :hook (prog-mode . hs-minor-mode)
  )

#+end_src

** Cheatsheet                                                   :cheatsheet:
- =hideshow= works by default with evil keybindings for folding:
  - ~z a~ to (un)fold at point
  - ~z r~ to unfold all
  - ~z m~ to fold all
  - ~z 0~ to unfold recursively
  - ...
** TODO Try some richer package for folding, e.g. origami or treesit-fold
* Development
** LSP
LSP (Language Server Protocol) enables editors to use language servers (that usually come with the language itself) to answer all kinds of questions about the code in that language, with full semantic understanding of the project.

LSP as a general protocol has some of its own nomenclature. Some of it that is useful to know to better understand the config below, is how they name the most important information that LS returns.
 - =hover= info: Documentation about the symbol/function/thing under the cursor that LS sends.
 - =diagnostics=: Errors, warnings, info, that LS reports.
 - =code actions=: actions that LS suggests and that you can then ask it to execute. E.g. add missing import.

Rough summary how my configuration currently displays all this info:
 - Parts of code with diagnostics are marked with **squiggly lines** (by Fly(check/make)).
 - **Short version of hover** info for a symbol is shown on cursor/mouse, in the minibuffer (by ~eldoc~).
 - **Full version of hover** info for a symbol under cursor is displayed in a popup, on demand, which I trigger with "K" or "?" (by ~lsp-ui-doc~).
 - Short info / **diagnostics** for thing/error under the cursor is shown on the right side of the screen, next to the code (sideline), including errors (just one line), warnings and **code actions**.
 - Full info for thing/eror under the cursor is shown by ~fly(check/make)~, in a popup, on request.

One functionality that LSP also defines are =semantic tokens=, where LS returns semantic information about specific tokens, which is then usually used by the editor for very detailed and smart syntax highlighting.
It is important to notice here that it doesn't return this information for every single token in the code, but only for specific types of tokens, meaning it can't be used to fully highlight the code. Instead, it is intended to be used as an additional, detailed syntax highlighting that is applied on top of some other, more basic syntax highlighting (i.e. usually implemented via regexes, textmate grammar, or recently treesitter). Additionally, LSP semantic token syntax highlighting is usually slower and less robust to syntax errors than other more basic methods, but those are secondary reasons.
Therefore, for optimal experience, we should customize the faces used for semantic tokens to be aligned with the faces used for basic highlighting, per language if needed.
**NOTE**: For stacking of syntax highlights to happen correctly, it is important that basic syntax highlighting (e.g. treesitter) is applied first, and then lsp semantic token syntax highlighting after it.

#+begin_src emacs-lisp

  (use-package lsp-mode
    :init
    (setq lsp-keymap-prefix ",")
    (setq lsp-use-plists t) ; Recommended performance optimization. Requires setting env var (check early-init.el block below).
    :hook (lsp-mode . lsp-enable-which-key-integration)
    :commands (lsp lsp-deferred)
    :custom
    ;; lsp-modeline is about showing "stats" in the modeline: number of errors, warnings, code actions.
    ;; Useful for languages where compilation might be broken due to errors in other files (e.g. Java, Haskell).
    (lsp-modeline-diagnostics-enable t) ; Show info about diagnostics (errors, warnings, ...) in the modeline.
    (lsp-modeline-diagnostics-scope :workspace) ; Whole project and not just this file.
    (lsp-modeline-code-actions-enable t) ; Show info about code actions in the modeline.

    ;; eldoc is the most "native" way for emacs to display docs for a thing under cursor.
    ;; It displays information about the thing under cursor/mouse in the minibuffer.
    ;; Here we tell lsp-mode to use eldoc to display "hover" lsp info (which is docs for function/symbol).
    (lsp-eldoc-enable-hover t)
    ;; Don't show all the info in minibuffer on hover, instead show only most basic info (what it is, type).
    ;; Otherwise, there is too much noise and jumping of minibuffer up and down.
    ;; If I want full docs for a thing under cursor, I will rather summon it manually: I use lsp-ui-docs-toggle for that and have bound it to "?" -> check lsp ui config for details.
    (lsp-eldoc-render-all nil)

    ;; At the top of the file, show info about the position of the cursor (path, module, symbol, ...).
    (lsp-headerline-breadcrumb-enable t)
    (lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))

    ;; Turned off for now, I found it to bee too much of a "rainbow soup".
    ;;(lsp-semantic-tokens-enable t) ; Richer highlighting (e.g. differentiates function symbol from var symbol).
    :config
    (general-define-key :states '(normal)
                        :keymaps 'lsp-mode-map
                        "," lsp-command-map
    )
  )

#+end_src

#+begin_src emacs-lisp :tangle ./early-init.el

  (setenv "LSP_USE_PLISTS" "true") ; Recommended performance optimization. Also neccessary for lsp-booster below to work.

#+end_src

*** lsp-ui

Official extension for lsp-mode that brings the nice UI features, mostly for displaying info returned by LS.
It is common to use it next to lsp-mode.
It can show information in two main ways: via ~lsp-ui-doc~ popup, or inline via ~lsp-ui-sideline~.

#+begin_src emacs-lisp

  (use-package lsp-ui
    :after (lsp-mode evil)
    :commands lsp-ui-mode
    :custom
    ;; Show "hover" documentation for a thing under cursor/pointer in a popup.
    (lsp-ui-doc-enable t)
    ;; I don't want it to popup constantly as I move around, instead I want to summon it when I need it.
    ;; That is why below I define "?" as a key for toggling it.
    (lsp-ui-doc-show-with-cursor nil)
    ;; If I hover with a mouse, then do show the docs, that is not too intrusive.
    (lsp-ui-doc-show-with-mouse t)
    ;; Show the docs next to the cursor/point.
    (lsp-ui-doc-position 'at-point)
    (lsp-ui-doc-include-signature t)
    (lsp-ui-doc-max-height 30)

    ;; lsp-ui-sideline shows info that you want (e.g. diagnostics, code actions, ...)  on the right
    ;; side of the window, inline with the code.  We set it to nil here though, because we control
    ;; it from another package, sideline + sideline-lsp.
    (lsp-ui-sideline-enable nil)
    :config
    (general-define-key :states '(normal visual)
                        :keymaps 'lsp-mode-map
                        "?" 'lsp-ui-doc-glance ; TODO: This is sometimes being overshadowed with ? from evil mode, fix that.
                        "F" 'lsp-ui-doc-focus-frame
    ) 
    (setq evil-lookup-func 'lsp-ui-doc-glance)
  )

#+end_src

*** lsp-booster

Both =lsp-mode= and =elgot= in emacs have the issue where emacs can get frozen when dealing with large amounts of data coming from / going to some language server.
Solution to this is =lsp-booster=: standalone binary that serves as a proxy in between emacs and language servers and buffers the traffic as needed (and is multi-threaded).
To get it to work we need to both install the binary (check "manual setup" below) and to wrap the language server calls in emacs to work with this proxy (which does the elisp code below).

I copied the code below exactly as it is from the =lsp-booster= Github's README (~v0.2.1~):

#+begin_src emacs-lisp

  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
    (when (equal (following-char) ?#)
      (let ((bytecode (read (current-buffer))))
        (when (byte-code-function-p bytecode)
          (funcall bytecode))))
    (apply old-fn args)))
  (advice-add (if (progn (require 'json)
                        (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
              (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
              lsp-use-plists
              (not (functionp 'json-rpc-connection))  ;; native json-rpc
              (executable-find "emacs-lsp-booster"))
          (progn
            (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
              (setcar orig-result command-from-exec-path))
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))
  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)

#+end_src

**** Manual setup :manual_setup:
I followed instructions from the =lsp-booster= Github's README:
- Downloaded the latest binary from the Github releases and made it available on =PATH= (I put it into =~/opt= dir).

*** Misc

#+begin_src emacs-lisp

  ;; Brings lsp-ivy-workspace-symbol that searches for a symbol in project as you type its name.
  ;; TODO: Add a keybinding, under lsp-keymap-prefix, for this command, I guess under goto? So ", g s"?
  (use-package lsp-ivy :commands lsp-ivy-workspace-symbol)

  ;; Shows list of all errors in a nice treemacs fashion.
  (use-package lsp-treemacs :commands lsp-treemacs-errors-list)

#+end_src

*** NOTE eglot vs lsp-mode
I investigated lsp-mode vs eglot. Eglot natively comes with emacs and is alternative to lsp-mode. Claims to have better code and be faster, but lsp-mode seems to be bigger and more featureful, so it is really not clear at all which is better. I think I will be sticking to lsp-mode for now, people seemed to report more issues with eglot, and lsp-mode I know works well. I can try eglot at some point.
*** TODO LSP's completion-at-point -> how to get that working with Company properly?
- https://emacs-lsp.github.io/lsp-mode/page/settings/completion/ -> useful?

** Treesitter
Treesitter is for syntax understanding of the code what LSP is for semantic understanding of the code.
Same like LSP, Treesitter removes the burden from the specific editor to implement all the logic related to dealing with syntax, and instead any editor can just leverage the one central implementation of it: Treesitter + corresponding treesitter grammar for specific language. In return, you get very good syntax highlighting, cleverer editing and movement through code, better indentation, ... -> anything that can be built with konwledge of concrete syntax tree.

Emacs 29 brings its own built-in treesitter package (~treesit~).
The only thing we need to configure is to tell it which grammars to pull in for which language.
Now we have working treesitter for those languages! It is not used anywhere yet though.

Easiest way to start using treesitter is to use one of the built-in major language modes that come with Emacs 29, that are made around using treesitter (they mostly use it for syntax highlighting): typescript-ts-mode, markdown-ts-mode, ... . We can easily check which exist by doing ~apropos~ and then ~-ts-mode$~. There are also third party major modes made with treesitter in mind (e.g. ~haskell-ts-mode~) that we can use, and additionaly, some older packages have added support for treesitter so we can toggle it there.
It't not all about syntax highligthing though, there is for example cool ~combobulate~ package that brings structural editing for multiple languages, based on treesitter.

For more details, this article is a great tutorial on treesitter support in Emacs: https://www.masteringemacs.org/article/how-to-get-started-tree-sitter .

#+begin_src emacs-lisp

  (use-package treesit
    :ensure nil ; Because it is built-in package, this tells elpaca to not try to install it.
    :preface
    (defun my/setup-install-grammars ()
      "Install Tree-sitter grammars if they are absent."
      (interactive)
      (dolist (grammar
               ;; Note the version numbers. These are the versions that with Emacs 29.
               ;; I picked those up from https://github.com/mickeynp/combobulate .
               '((css . ("https://github.com/tree-sitter/tree-sitter-css" "v0.20.0"))
                 (bash "https://github.com/tree-sitter/tree-sitter-bash")
                 (go . ("https://github.com/tree-sitter/tree-sitter-go" "v0.20.0"))
                 (html . ("https://github.com/tree-sitter/tree-sitter-html" "v0.20.1"))
                 (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript" "v0.20.1" "src"))
                 (json . ("https://github.com/tree-sitter/tree-sitter-json" "v0.20.2"))
                 (markdown . ("https://github.com/ikatyang/tree-sitter-markdown" "v0.7.1"))
                 (python . ("https://github.com/tree-sitter/tree-sitter-python" "v0.20.4"))
                 (rust . ("https://github.com/tree-sitter/tree-sitter-rust" "v0.21.2"))
                 (toml . ("https://github.com/tree-sitter/tree-sitter-toml" "v0.5.1"))
                 (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "tsx/src"))
                 (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "typescript/src"))
                 (yaml . ("https://github.com/ikatyang/tree-sitter-yaml" "v0.5.0"))
                 (haskell . ("https://github.com/tree-sitter/tree-sitter-haskell"))
                 (prisma "https://github.com/victorhqc/tree-sitter-prisma")
  	       (elisp "https://github.com/Wilfred/tree-sitter-elisp")
  	       (c "https://github.com/tree-sitter/tree-sitter-c")
                 (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
                 (cmake . ("https://github.com/uyha/tree-sitter-cmake" "v0.5.0" "src"))
  	     ))
        (add-to-list 'treesit-language-source-alist grammar)
        ;; Only install `grammar' if we don't already have it installed.
        ;; However, if we update a grammar version above then this won't update it since it is already installed,
        ;; I should instead run `treesit-install-language-grammar' manually for it.
        (unless (treesit-language-available-p (car grammar))
          (treesit-install-language-grammar (car grammar))))
    )
    :config
    (customize-set-variable 'treesit-font-lock-level 4) ; Use maximum details (4/4) when doing syntax highlighting.
    (my/setup-install-grammars)
  )

#+end_src

*** Cheatsheet :cheatsheet:
- Cool commands are ~treesit-explore-mode~ and ~treesit-inspect-mode~: they allow inspecting the concrete syntax tree in a buffer!

** Haskell

#+begin_src emacs-lisp
  (defun my/lsp-haskell-local-face-setup ()
    ;; semhl stands for "semantic highlight" -> faces with "semhl" are faces for lsp semantic tokens.
    ;; By default, lsp-face-semhl-operator just inherits lsp-face-semhl-function, which I found to be a shame.
    ;; By setting them to keyword face, operators are nicely visible.
    (face-remap-add-relative 'lsp-face-semhl-operator '(:foregrund unspecified :inherit lsp-face-semhl-keyword))
    ;; I don't want to differentiate class methods from functions by color, that is just confusing.
    (face-remap-add-relative 'lsp-face-semhl-method '(:foreground unspecified :inherit lsp-face-semhl-function))
    ;; haskell-operator-face is used for stuff like `::`, `->` and similar. By default they were the same as
    ;; variables, I didn't like that so I made them same as other operators, which is keyword face.
    (face-remap-add-relative 'haskell-operator-face '(:foreground unspecified :inherit font-lock-keyword-face))
    ;; By default haskell keywords (import, where, ...) already are set to font-lock-keyword-face,
    ;; I just added :weight semi-bold to make them stand out a bit.
    (face-remap-add-relative 'haskell-keyword-face '(:weight semi-bold :inherit font-lock-keyword-face))
  )

  (defun my/haskell-mode-setup ()
    (lsp-deferred)
    (ormolu-format-on-save-mode)
    (face-remap-add-relative 'font-lock-operator-face '(:foreground unspecified :inherit font-lock-keyword-face))
    (add-hook 'lsp-after-open-hook 'my/lsp-haskell-local-face-setup nil t)
  )

  ;; NOTE: Requires ormolu to be installed on the machine.
  (use-package ormolu)

  (use-package haskell-mode
    :hook
    (haskell-mode . my/haskell-mode-setup)
    (haskell-literate-mode . my/haskell-mode-setup)
  )

  ;; ;; TODO: Some current problems:
  ;; ;;  - Doesn't highlight as much stuff as I would like it to (https://codeberg.org/pranshu/haskell-ts-mode/issues/7).
  ;; ;;    - actually it does apply font-lock-operator-face but I guess it is just white -> make that one interesting, e.g. use keyword face.
  ;; ;;    - I used treesit-explore-mode and it is great, I can see exactly how it understand the code, and it knows so much! So it does know a ton about the code, but we are not using it! WHy is that so? Beacause haskell-ts-mode is just not applying font lock faces to all these tokens, it seems so. It really should! Can I customize that myself, or do I need to make a PR on the haskell-ts-mode package?
  ;; ;;  - Is too smart while highlighting signature.
  ;; ;;  - Can't get it to be default mode becuase haskell-mode still gets pulled in with lsp-haskell.
  ;; ;;    I need to either make sure it doesn't get pulled in, or remove it from loading for .hs files.
  ;; ;;  - What is with literate mode?
  ;; (use-package haskell-ts-mode
  ;;   :load-path "~/git/haskell-ts-mode" ; NOTE: This is for using my local fork of the package, for dev purposes. Remove this line to use public version of the package.
  ;;   :mode (("\\.hs\\'" . haskell-ts-mode))
  ;;   :hook
  ;;   (haskell-ts-mode . my/haskell-mode-setup)
  ;;   ;;(haskell-literate-mode . my/haskell-mode-setup) ; What about literate mode?
  ;;   :config
  ;;   (setq haskell-ts-highlight-signature nil)
  ;;   (setq haskell-ts-font-lock-level 4) ; Maximum syntax highlighting.
  ;; )

  ;; Teaches lsp-mode how to find and launch HLS (Haskell Language Server).
  (use-package lsp-haskell
    :after lsp-mode 
    :custom
    ;; This takes syntax highlighting to the maximum of detail. It is a bit slow though!
    (lsp-haskell-plugin-semantic-tokens-global-on t)
  )


#+end_src

*** Cheatsheet :cheatsheet:
- haskell-mode brings interactive mode where you get a ghci session in which you can easily load specific files and run stuff from them. To start it, run `interactive-haskell-mode`. File is added to it by ~haskell-process-load-file~ while in a Haskell file buffer.
- Haskell mode registers its keymap under "C-c", so check that for common commands.


*** TODO Try using haskell-ts-mode instead of haskell-mode
haskell-mode doesn't know how to use treesitter, and haskell-ts-mode, which is a new mode that somebody made that should replace haskell-mode but with ts support, has much less features than haskell-mode and is less mature. But maybe that is ok and worth trying? Do I use any of advanced haskell-mode features anyway? I don't think so.
  - https://codeberg.org/pranshu/haskell-ts-mode

** TypeScript / Javascript
NOTE: I chose ts-ls as a language server, when asked.

#+begin_src emacs-lisp

  (defun my/add-jsdoc-in-typescript-ts-mode ()
    "Add jsdoc treesitter rules to typescript as a host language."
    ;; I copied this code from js.el (js-ts-mode), with minimal modifications.
    (when (treesit-ready-p 'typescript)
      (when (treesit-ready-p 'jsdoc t)
        (setq-local treesit-range-settings
                    (treesit-range-rules
                      :embed 'jsdoc
                      :host 'typescript
                      :local t
                      `(((comment) @capture (:match ,(rx bos "/**") @capture)))))
        (setq c-ts-common--comment-regexp (rx (or "comment" "line_comment" "block_comment" "description")))

        (defvar my/treesit-font-lock-settings-jsdoc
          (treesit-font-lock-rules
          :language 'jsdoc
          :override t
          :feature 'document
          '((document) @font-lock-doc-face)

          :language 'jsdoc
          :override t
          :feature 'keyword
          '((tag_name) @font-lock-constant-face)

          :language 'jsdoc
          :override t
          :feature 'bracket
          '((["{" "}"]) @font-lock-bracket-face)

          :language 'jsdoc
          :override t
          :feature 'property
          '((type) @font-lock-type-face)

          :language 'jsdoc
          :override t
          :feature 'definition
          '((identifier) @font-lock-variable-face)
          )
        )
        (setq-local treesit-font-lock-settings
                    (append treesit-font-lock-settings my/treesit-font-lock-settings-jsdoc))
      )
    )
  )

  ;; This is a built-in package that brings major mode(s) that use treesitter for highlighting.
  ;; It defines typescript-ts-mode and tsx-ts-mode.
  (use-package typescript-ts-mode
    :ensure nil ; Built-in, so don't install it via package manager.
    :mode (("\\.[mc]?[jt]s\\'" . typescript-ts-mode)
           ("\\.[jt]sx\\'" . tsx-ts-mode)
          )
    :hook (((typescript-ts-mode tsx-ts-mode) . lsp-deferred))
    :hook (((typescript-ts-mode tsx-ts-mode) . #'my/add-jsdoc-in-typescript-ts-mode))
  )

#+end_src

*** TODO Customize LSP semantic token faces to be aligned with treesitter highlighting.

*** LSP ESLint

This will also run eslint language server next to the other language servers if there is an eslint config file in the project.

#+begin_src emacs-lisp

  (use-package lsp-eslint
    :ensure nil ;; Don't install since it comes built-in with lsp-mode.
    :after lsp-mode
  )
  
#+end_src

**** Manual setup :manual_setup:
- =M-x lsp-install-server RET eslint RET=
  
** Web (HTML, CSS, ...)
Emacs comes with built-in =html=, =mhtml=, and =css= mode, so I am just relying on those for now, they seem to work well enough for my purposes.
Also popular is =web-mode=, so I might want to look into that one day, but I haven't had the need so far so decided to keep it light.
** YAML

#+begin_src emacs-lisp

  ;; Built-in YAML major mode with treesitter highlighting.
  (use-package yaml-ts-mode
    :ensure nil ; Built-in, so don't install it via package manager.
    :mode ("\\.ya?ml\\'" . yaml-ts-mode)
    :hook (yaml-ts-mode . lsp-deferred)
  )

#+end_src

** Markdown

#+begin_src emacs-lisp

  (use-package markdown-mode
    :config
    ;; Set headers to have different sizes.
    (dolist (face '((markdown-header-face-1 . 1.5)
                    (markdown-header-face-2 . 1.3)
                    (markdown-header-face-3 . 1.2)
                    (markdown-header-face-4 . 1.1)
                    (markdown-header-face-5 . 1.1)
                    (markdown-header-face-6 . 1.1)))
      (set-face-attribute (car face) nil :height (cdr face))
    )
  )

#+end_src

* AI
** Overview of popular packages
Last updated: <2024-12-23 Mon>

Quick summary:
For now I will go with gpt.el (for general usage), copilot.el (for completion) and copilot-chat.el (for general usage). gpt.el and copilot-chat.el are overlapping in what they can do, so I have to figure out which I like better. gpt.el however can use any model, while copilot-chat has to use copilot, but is free for me.
Out of higher-level models, I think Ellama and aider.el might be worth trying out for me. Elisa is also interesting, although it might be better if I just set up PrivateGPT and use it with gpt.el.
I might also want to try out chatgpt-shell at some point, it is similar to gptel uses different approach.

*** High level
- [[https://github.com/s-kostyaev/ellama][Ellama]]
  Has cmds to ask llm to summarize, translate, complete, code review, use CoT, ... . A lot of very specific commands for specific tasks.
  Seems to me like I can do most of this with gpt.el directly with just a bit more work, so I will skip trying out Ellama for now, and maybe try it once I feel that I want more from gpt.el and Ellama offers it.
- [[https://github.com/tninja/aider.el][aider.el]]
  Makes it easy to use Aider from emacs, for the current project, and send it buffers and similar.
  Has nice transient menu.
  Certainly worth trying if using Aider.
- [[https://github.com/daedsidog/evedel][Evedel]]
  Uses gpt.el as a backend and needs it installed.
  Introduces unique workflow for working with LLM where you add instructions(directives) and references in the text/code in your buffer and that is sent to the LLM in order to modify it.
  Sounds powerful, but for now I don't need that level of control over how LLM refactors piece of my code.
- [[https://github.com/s-kostyaev/elisa][Elisa]]
  Implementation of RAG to be used in your emacs.
  Combines local files/dirs, Emacs info manuals, and web search -> all these are added to "collection(s)".
  And then you can ask questions about it.
  Sounds awesome for working on specific projects with specific knowledge, but is a bit limited in the way that it can do only chatting. Probably it is better for me to sure PrivateGPT then, as a backend for gpt.el.
- [[https://github.com/lanceberge/elysium][elysium]]
  Uses gpt.el as backend and needs it installed.
  Narrow-focused: given the query, it applies changes directly to the selected code. But I believe gpt.el can also do that?
*** Mid-level
- [[https://github.com/karthink/gptel][gptel]]
  Allows for chatting with llm of choice anywhere in Emacs, with a lot of care about DX and being inobtrusive.
  Quite flexible, allows a lot of customization on the fly with nice transient menu.
  Also has commands for stuff like rewriting a piece of code, adding buffers to the context, ... .
  Has support for multi-modal: specifically images.
  Most popular emacs LLM package at the moment.
- [[https://github.com/copilot-emacs/copilot.el][copilot.el]]
  Brings copilot completion to Emacs.
- [[https://github.com/chep/copilot-chat.el][copilot-chat.el]]
  Brings copilot-chat capabilities to Emacs. Similar to gptel in what it can do, but only for copilot as a backend.
- [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]]
  Similar to gptel, but as a comint shell, which is a kind of specific emacs's mechanism for prompts / convos.
*** Low-level
- [[https://github.com/ahyatt/llm][llm]]

** GPTel
=gptel= is a "mid-level" LLM package for emacs. It doesn't prescribe specific opinionated workflows but instead offers an easy, integrated way to interact with LLM from any emacs buffer.

*** General config
#+begin_src emacs-lisp
  (use-package gptel
    :config

    ;; I decided to go with prefixes (You, AI) that are not org/md headings, but just normal text
    ;; that I style separately.
    ;; I did that for the main reason of us not being able to control what level of headings will
    ;; LLM return -> it doesn't listen even if explicitly told and it might include any heading level
    ;; in its response. This is a problem because if it returns the heading of the same or higher level
    ;; as what I use for prefixes, then the structure of the docs gets messed up. The only solution for that
    ;; is to tell LLM not to use headings + rewrite any that it adds by accident.
    ;; But if LLM can't return headings, than me using headings for prefixes also doesn't do much,
    ;; since I don't need the doc to be structured in that fashion, I would rather then use headings
    ;; to structure it per conversation topics or something like that.
    ;; Therefore, I do non-heading prefixes + ensure LLM can't return headings. Author of gptel,
    ;; karthink, is doing the same, I got the idea from him.
    (let ((my/gptel-prompt-prefix "@You:\n\n")
          (my/gptel-response-prefix "@AI:\n\n")
         )
      (setq gptel-prompt-prefix-alist `((markdown-mode . ,my/gptel-prompt-prefix)
                                        (org-mode . ,my/gptel-prompt-prefix)
                                        (text-mode . ,my/gptel-prompt-prefix)))
      (setq gptel-response-prefix-alist `((markdown-mode . ,my/gptel-response-prefix)
                                          (org-mode . ,my/gptel-response-prefix)
                                          (text-mode . ,my/gptel-response-prefix)))
      (defface my/gptel-prompt-response-prefix-face
        `((t (:foreground ,(face-attribute 'font-lock-keyword-face :foreground)
              :weight bold
              :height 1.2
              :inverse-video t
        )))
        "Gptel prompt/response prefix face"
      )
      (defun my/gptel-setup-font-lock ()
        "Setup font-lock for gptel."
        (font-lock-add-keywords
         nil
         `((,(concat "^" (string-trim-right my/gptel-prompt-prefix) "\s*$")
            . 'my/gptel-prompt-response-prefix-face)
           (,(concat "^" (string-trim-right my/gptel-response-prefix) "\s*$")
            . 'my/gptel-prompt-response-prefix-face)
         )
        )
      )
      (add-hook 'gptel-mode-hook #'my/gptel-setup-font-lock)
    )
    (defun my/gptel-transform-headings (beg end)
      "Turn any org heading in the current buffer between BEG and END into just text."
      (when (derived-mode-p 'org-mode)
        (save-excursion
          (goto-char beg)
          (while (re-search-forward org-heading-regexp end t)
            (forward-line 0)
            (delete-char (1+ (length (match-string 1))))
            (insert-and-inherit (concat (make-string (length (match-string 1)) ?🔷) " *"))
            (end-of-line)
            (skip-chars-backward " \t\r")
            (insert-and-inherit "*"))
        )
      )
    )
    (add-hook 'gptel-post-response-functions #'my/gptel-transform-headings)
    ;; ---------------

    (setq gptel-default-mode 'org-mode)
    (setq gptel-api-key 'gptel-api-key-from-auth-source) ; Will pull the API keys from ~/.authinfo .
    ;; On response, move cursor to the next prompt.
    (add-hook 'gptel-post-response-functions 'gptel-end-of-response)

    (setq gptel-expert-commands t)

    ;; Customize default directive used to provide extra context in certain situations.
    ;; TODO: This currently isn't used till I pick it manually as a system message!
    ;;   I guess I set it here too late, it already read info from gptel-directives and doesn't
    ;;   care about what I did here. Figure out how to make this default directive.
    (defun my/gptel-default-directive ()
      (concat
        ;; The original default directive.
        "You are a large language model living in Emacs and a helpful assistant. Respond concisely."
        (when gptel-mode
          (format " Take into account that we are currently in the %s major mode. DO NOT use headings (e.g. #, ##, ### in md or *, **, *** in org) in your response, or you will mess up the doc structure."
                  (symbol-name major-mode)
        ))
      )
    )
    (setf (alist-get 'default gptel-directives) #'my/gptel-default-directive)


    (my/leader-keys
      "ii"  '("[gptel] menu" . gptel-menu)
      "ic"  '("[gptel] chat" . gptel)
      "is"  '("[gptel] send to chat" . gptel-send)
      "ir"  '("[gptel] rewrite" . gptel-rewrite)
      "ix"  '("[gptel] +/- ctxt" . gptel-add)
      "i!"  '("[gptel] summarize chat" . my/gptel-chat-summarize-and-replace)
    )

    ;; OpenAI (with ChatGPT) is the default backend.

    ;; Register Claude as one of the backends.
    (setq my/gptel-claude-backend (gptel-make-anthropic "Claude" :stream t :key gptel-api-key))

    ;; Set default model.
    (setq gptel-model 'claude-sonnet-4-20250514 gptel-backend my/gptel-claude-backend)
    ;(setq gptel-model 'gpt-4.1)
  )
#+end_src

*** My command for chat summarization
#+begin_src emacs-lisp
  (with-eval-after-load 'gptel
    (defun my/gptel-chat-summarize-and-replace ()
      "Summarize the current gptel chat and replace it with the summary."
      (interactive)
      (unless gptel-mode (user-error "Can't summarize gptel chat: not in a gptel buffer."))
      (let* ((chat-content (buffer-substring-no-properties (point-min) (point-max)))
             (major-mode-name (symbol-name major-mode))
             (system-prompt
              (format "You are a chat summarizer. Please provide a concise summary of the conversation so far in %s format (IMPORTANT: don't use md if in org, and vice versa), preserving key technical details and context, and general conversation formatting style so far. Use bullet points non-sparingly, but DO NOT use headings as they mess up the doc structure. Start with a line \"%s\", then follow up with the actual summary underneath that line, and finish with the line \"%s\". Instead of \"the user\", say \"you\". Start summary by mentioning that this is the summary of the conversation so far."
                      major-mode-name
                      (cdr (assoc major-mode gptel-response-prefix-alist))
                      (cdr (assoc major-mode gptel-prompt-prefix-alist))
              )
             )
             (prompt (format "EVERYTHING BELOW THIS LINE IS OLD CONVERSATION FOR YOU TO SUMMARIZE:\n\n%s" chat-content))
             (gptel-use-tools nil)
            )
        (message "Summarizing gptel chat %s ..." (buffer-name (current-buffer)))
        (erase-buffer)
        (gptel-request prompt
          :stream t
          :system system-prompt
          :callback
          (lambda (response info)
            (cond
             ((stringp response)
              (with-current-buffer (plist-get info :buffer)
                (insert response)
              )
             )
             ((eq response t)
              (message "Gptel chat summarized!")
             )
             (t
              (message
               "Gptel chat summarization failed with unexpected response. Response: %s. Status: %s."
               response
               (plist-get info :status)
              )
             )
            )
          )
        )
      )
    )
  )
#+end_src

*** Presets
#+begin_src emacs-lisp
  (with-eval-after-load 'gptel
    (gptel-make-preset 'coding
      :description "A preset optimized for coding tasks"
      :backend "Claude"
      :model 'claude-3-7-sonnet-20250219
      :system "You are an expert coding assistant. Your role is to provide high-quality code solutions, refactorings, and explanations."
      :tools '("read_buffer" "modify_buffer" "emacs_eval" "emacs_docs"))
  )
#+end_src

*** Tools
#+begin_src emacs-lisp
  (with-eval-after-load 'gptel
    (gptel-make-tool
     :name "read_buffer"
     :description "Return the contents of an emacs buffer."
     :category "emacs"
     :args (list '(:name "buffer"
                   :type string
                   :description "the name of the buffer whose contents are to be retrieved"))
     :function (lambda (buffer)
                 (unless (buffer-live-p (get-buffer buffer))
                   (error "error: buffer %s is not live." buffer))
                 (with-current-buffer buffer
                   (buffer-substring-no-properties (point-min) (point-max))))
    )

    (gptel-make-tool
     :name "modify_buffer"
     :description "Replace the contents of an existing buffer with new content."
     :category "emacs"
     :confirm t
     :args (list '(:name "buffer"
                   :type string
                   :description "the name of the buffer to modify")
                 '(:name "new-content"
                   :type string
                   :description "the new content of the buffer"))
     :function (lambda (buffer new-content)
                 (unless (buffer-live-p (get-buffer buffer))
                   (error "error: buffer %s is not live." buffer))
                 (with-current-buffer buffer
                   (erase-buffer)
                   (insert new-content)))
    )

    (gptel-make-tool
     :name "read_url"
     :description "Fetch and read the contents of a URL"
     :category "web"
     :args (list '(:name "url"
                   :type "string"
                   :description "The URL to read"))
     :function (lambda (url)
                 (with-current-buffer (url-retrieve-synchronously url)
                   (goto-char (point-min)) (forward-paragraph)
                   (let ((dom (libxml-parse-html-region (point) (point-max))))
                     (run-at-time 0 nil #'kill-buffer (current-buffer))
                     (with-temp-buffer
                       (shr-insert-document dom)
                       (buffer-substring-no-properties (point-min) (point-max))))))
    )

    (gptel-make-tool
     :name "emacs_eval"
     :description "Evaluate an elisp expression"
     :category "emacs"
     :confirm t
     :args (list '(:name "expr-string"
                   :type string
                   :description "elisp expression to evaluate"))
     :function
     (lambda (expr-string)
       (let ((result (eval (read expr-string))))
         (if (stringp result) result (prin1-to-string result))
       )
     )
    )

    (gptel-make-tool
     :name "emacs_docs"
     :description "Fetch all available documentation for an Emacs symbol"
     :category "emacs"
     :include t
     :args (list '(:name "symbol-name"
                   :type string
                   :description "the name of the Emacs symbol to document"))
     :function
     (lambda (symbol-name)
       (let ((symbol (intern-soft symbol-name)))

         (unless symbol (error "Symbol '%s' not found" symbol-name))

         (let ((function-doc
                (if (fboundp symbol)
                    (let ((doc (documentation symbol))
                          (args (help-function-arglist symbol t)))
                      (concat "<FUNCTION>\n"
                              "Arglist: " (prin1-to-string args) "\n"
                              (or doc "") "\n</FUNCTION>\n\n"))
                  ""))

               (variable-doc
                (if (boundp symbol)
                    (let ((doc (documentation-property symbol 'variable-documentation))
                          (val (symbol-value symbol)))
                      (concat "<VARIABLE>\n"
                              "Value: " (prin1-to-string val) "\n"
                              (or doc "") "\n</VARIABLE>\n\n"))
                  ""))

               (face-doc
                (if (facep symbol)
                    (let ((doc (documentation-property symbol 'face-documentation)))
                      (concat "<FACE>\n"
                              (or doc "") "\n</FACE>\n\n"))
                  ""))
              )

           (let ((all-docs (string-trim (concat function-doc variable-doc face-doc))))
             (concat "Documentation for: " symbol-name "\n\n"
                     (replace-regexp-in-string "^" "  " all-docs))
           )
         )
       )
     )
    )
  )
#+end_src

*** Setting up the API keys                                  :manual_setup:
- Set the API keys for the LLM providers (OpenAI, Anthropic, ...) in the =~/.authinfo= file (check the gptel docs for detail
*** Cheatsheet :cheatsheet:
- Use ~gptel-send~ to send text to LLM.
- ~gptel-menu~ also sends but offers options and is the main way to configure =gptel=.
- =C-c RET= is for sending the query to AI when in the Gptel chat buffer.
- Gptel chat buffer is nothing super special, more of a convenience thing.
  The main concept is not the chat buffer, but sending text to the point / in region.
- When using ~gpt-rewrite~, result will be shown in an overlay that is not normal text. I then need to move cursor to its start and hit =RET=, and then I can choose if I want to accept that piece of code, rewrite it again, diff it, ... . Most often I will want to accept it or rewrite it.
- To save the convo, I can just save the chat to a file, open it later and turn on ~gptel-mode~.
- Run ~gptel-tools~ to select the tools to use (from the ones we defined). Or do it via gptel transient menu.
- *Sending media*: If I add link as a "standalone" thing (alone on the line, blank lines above and below), and I enable "Sending media", then it will be sent as part of chat. It needs to be proper Org link (so in [] brackets) and should point to a file (image, text file, ...) on the disk (so start with ~file:/~).
- I can use ~gptel-request~ function to write my custom functions that use =gptel=.
- I can override ~gptel-directives~ with my custom directives, changing how certain =gptel= commands requests are composed (e.g. "rewrite").
- ~gptel-org-branching-context~ makes it so that only current headings branch in org are supplied as context/chat. Allowing for branching chats.
*** TODO How can I use evil kbs in gptel minibuffer?
Is the problem in the fact that I disabled evil-collection in the minibuffer?
*** TODO Open an issue about confusing DX with the rewrite result overlay
How can one know he needs to press enter on it? It is quite non-intuitive. It should come with some instructions on top I think, e.g. "press Enter". Also cursor jumps around it a bit weirdly, but maybe that is ok.
*** TODO Look into gptel-directives (enrich "rewrite")
I can write my own gptel-directives, therefore controlling how e.g. rewrite is done.
They are dynamic -> functions -> so I can enrich the request any way I want. E.g. I could fetch the location of current region for the "rewrite" and pass that, if I implement my own "rewrite" directive.
Here is reddit answer https://www.reddit.com/r/emacs/s/5FYxlNZVCZ which contains this example: https://paste.karthinks.com/67b98a11-gptel-rewrite-with-context.html .
He basically takes default value of "rewrite" directive (its a fuction) and creates his own based on it.
- I could also look into collecting the errors/warnings in the buffer and sending that to the LLM. That shouldn't be hard. Maybe as a part of rewrite, but also as a part of just chatting with the LLM? Meaning even as "ask" or just sending to chat hm. I can just collect errors as reported by flymake/check probably? That would be cool.
- When adding errors/warnings, I can add them with org drawers so they are collapsed but there.
*** TODO Look into gptel-context-wrap-function
*** TODO Look into defining custom gptel commands
- https://github.com/karthink/gptel/wiki/Defining-custom-gptel-commands
- Useful if I want to write my own rewrite and ask commands with gptel-request?
*** DONE Write a function that summarizes the current chat.
I could maybe combine this with that "org branching gptel" feature, so that the whole history of the convo is still kept, but it also gets branched with context or something. Ok I probably don't need that though hah.
Btw I should look online for "summarizing" prompt, I am sure people have figured out some good prompts.
*** TODO Set up tool usage via MCP (check gptel's docs)
*** TODO Add https://github.com/karthink/gptel-quick ?
*** TODO Look up into using gptel for completion at point, there is a package for it
- https://www.reddit.com/r/emacs/s/eRJhgE0NxT
- It is cool because it already has the context I was building up.
*** TODO Look into gptel-prompts
https://www.reddit.com/r/emacs/comments/1lcc1hy/fun_with_gptel_gptelprompts/
** Copilot

*** copilot.el

I have it off by default because I find it intrusive. I however defined a keybinding for toggling copilot-mode easily.

#+begin_src emacs-lisp

  (use-package copilot
    :ensure (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
    :config
    (define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
    (my/leader-keys
      "i TAB" '("toggle copilot" . copilot-mode)
    )
  )

#+end_src

**** Manual setup                                           :manual_setup:
- install the copilot server: ~M-x copilot-install-server~
- login to copilot with ~M-x copilot-login~


*** copilot-chat.el

Has big overlap with gptel but I have both for now, to see which I like better, or maybe I can mix and match.

Besides basic chat in which you can add/remove buffers into context, it also has some convenience commands for reviewing/fixing/optimizing code, writing tests and similar.

Most straightforward way to use it is to run ~copilot-chat-transient~ since that shows all the possible things one can do. All the reviewing/fixing/testing code commands are under =code= option.

#+begin_src emacs-lisp

  (use-package copilot-chat
    :config
    (my/leader-keys
      "i I" '("copilot chat" . copilot-chat-transient))
  )

#+end_src

**** TODO When in buffer list, its special keybindings (RET, g, ...) don't work, I believe because of evil, fix that.

** TODOs
*** TODO Learn/configure gptel
- Here is a bit more on effectively using gptel: https://www.reddit.com/r/emacs/s/O7Kh4Z9uNV .
- About tool use + translation RAG in emacs using gptel and a super crappy LLM: https://www.reddit.com/r/emacs/s/IbQJijOHHZ .
*** TODO Lean how to use Aider
- There is Aidermacs, try it.
- A bit about using Aider in Emacs, and other stuff, to get closer to Cursor experience: https://www.reddit.com/r/emacs/comments/1ikdb5c/how_is_cursor_ai_better_than_emacs/?share_id=-3XEqsEXmq65_vdCzFM6H&utm_content=1&utm_medium=android_app&utm_name=androidcss&utm_source=share&utm_term=10
- There is aider.el, I might want to look into that one, or I can just use Aider directly form the terminal. https://github.com/tninja/aider.el
- Aidermacs: another package for using aider in emacs, allegedly it is cool: https://www.reddit.com/r/emacs/s/ej9qMsblZq .
*** TODO Try other stuff (Elysium? Evedel? Others?)
* Formatting
** Whitespaces

=whitespace-mode= is a built-in emacs package whose main purpose is to *visualize all whitespaces*.

#+begin_src emacs-lisp

  (use-package whitespace
    :ensure nil ; Don't install as it is built-in with emacs.
    :config
    ; Don't highlight too-long lines, because it is too noisy and we use another package for that anyway.
    (setq whitespace-style (delq 'lines whitespace-style))

    ; Default faces are not visible enough (grey), so I set all the faces to something more visible.
    (dolist (face '(whitespace-big-indent
                    whitespace-empty
                    whitespace-hspace
                    whitespace-indentation
                    whitespace-line
                    whitespace-missing-newline-at-eof
                    whitespace-newline
                    whitespace-space
                    whitespace-space-after-tab
                    whitespace-space-before-tab
                    whitespace-tab
                    whitespace-trailing))
      (set-face-attribute face nil :foreground "dark red")
    )

    (my/leader-keys
      "t w" '("whitespaces" . whitespace-mode)
    )
  )

#+end_src

=ethan-wspace-mode= takes care of *redundant/trailing* whitespaces (removal, highlighting).
It operates on the principle of clean/dirty files:
 - If file is clean (has no redundant whitespaces) then it removes any new redundant whitespace on save.
 - If file is dirty then it only highlights any redundant whitespace.
Therefore, once file becomes clean, you can't add any redundant whitespaces.
If that is an issue and you do want to make add a redundant whitespace (e.g. in markdown file), then you
can turn off =ethan-mode= for a bit to add them. That will make the file dirty and stop removing whitespaces, only highlight them.

#+begin_src emacs-lisp

  (use-package ethan-wspace
    :init
    (setq mode-require-final-newline nil)
    :config
    (global-ethan-wspace-mode 1)
    ;; There is ethan-wspace-face if I want to configure what it looks like.
  )

#+end_src

*** Cheatsheet :cheatsheet:
- ~M-x ethan-wspace-clean-all~ to remove all redundant whitespace and therefore turn the file into a clean one.


** Long lines

=column-enforce-mode= highlights lines that are too long (the part that goes over the max column).

Common advice these days is to use =whitespace-mode= for this, as it can be configured that it shows only highlights too long parts of lines when mode is on.
However, I don't like that approach as it means I can't easily use whitespace for its main purpose, which is toggling it on and off to inspect all the whitespaces.
Instead, it would have to be on all the time and I would need to configure what it highlights when I want to see more, which feels hacky.
That is why I instead I use this dedicated mode that does just this: highlights too longs parts of lines.

#+begin_src emacs-lisp

  (use-package column-enforce-mode
    :hook (prog-mode . column-enforce-mode)
    :config
    (setq column-enforce-column fill-column)
    (set-face-attribute 'column-enforce-face nil
                        :inherit nil
                        :background "black"
                        :underline '(:style wave :color "purple")
    )
  )

#+end_src

* Misc

#+begin_src emacs-lisp

  (use-package recentf
    :ensure nil  ;; built-in
    :custom
    (recentf-max-saved-items 50)
    :config
    (recentf-mode 1)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Primarily supposed to be used with visual-line-mode (which is emacs builtin that soft wraps the line at window end).
  ;; visual-fill-column, when used with visual-line-mode, modifies the wrapping to happen at the fixed (by default fill-column) width,
  ;; instead of at the window end.
  ;; It can also center the text.
  ;; Useful for making the buffer look "document" like.
  (use-package visual-fill-column)

#+end_src

#+begin_src emacs-lisp

  ;; This makes copy/paste properly work when emacs is running via the terminal.
  (use-package xclip
    :config
    (xclip-mode 1)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Allows fast jumping inside the buffer (to word, to line, ...).
  (use-package avy)

#+end_src

#+begin_src emacs-lisp

  ;; Allows jumping to any window by typing just a single letter.
  (use-package ace-window)

#+end_src

#+begin_src emacs-lisp

  ;; This package gives me commands to jump to a window with specific number (ace-window doesn't do that).
  (use-package winum
    :config
    (winum-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Remembers last used commands and puts them on top of M-x's list of commands.
  ;; Integrates seamlessly with Ivy/Counsel, Ido and some other.
  (use-package amx)

#+end_src

#+begin_src emacs-lisp

  ;; Highlight TODO and similar keywords in comments and strings.
  (use-package hl-todo
    :config
    (global-hl-todo-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Utility package that provides nice icons to be used in emacs, by other packages.
  ;; NOTE: The first time you load your config on a new machine, you'll have to
  ;; run the following command interactively:
  ;; M-x all-the-icons-install-fonts
  (use-package all-the-icons)

#+end_src

#+begin_src emacs-lisp

  ;; Enhances built-in Emacs help with more information: A "better" Emacs *Help* buffer.
  (use-package helpful
    :defer t
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    (([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key)
    ("C-h h" . helpful-at-point)
    )
  )

#+end_src

#+begin_src emacs-lisp

  ;; Colorizes color names in buffers.
  ;; Works better than clasical rainbow-mode, which would mess up Help buffer for me.
  (use-package colorful-mode
    :config
    (add-to-list 'global-colorful-modes 'help-mode)
    (global-colorful-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; It colors each pair of parenthesses into their own color.
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Brings functions for converting buffer text and decorations to html.
  (use-package htmlize)

#+end_src

#+begin_src emacs-lisp

  ;; This introduces redundancy, because we exactly replicate the content of dir local vars that we want to allow automatically,
  ;; but on the other hand it is the recommended/official way to be sure that we are ok with execution of that code, and not have
  ;; emacs keep asking us if we want to execute them.
  (setq safe-local-variable-values
    '((eval with-eval-after-load 'lsp-mode
  	  (add-to-list 'lsp-file-watch-ignored-directories "/e2e-test/test-outputs\\'")))
  )

#+end_src

* Cheatsheet :cheatsheet:

- M-: -> eval in echo buffer

- check-parens -> find unbalanced parenthesses in the buffer

- C-h -> help! find out about v (variable), f (function), face, ... .
- C-h h -> help for symbola at point.

- m <char> -> set mark
- ` <char> -> go to mark
- ` ` -> go to last mark

- C-x TAB -> indent-rigidly: allows indenting region one by one space via transient menu

Troubleshooting:
- package couldn't be found (upon install) -> local packages archive is old, run `list-packages` to update it.

* TODO
** A must
*** TODO Pin down package versions (lockfile / freezing) [1/2]
Elpaca now has some support for it, look into that:
 - [ ] I could version control the =elpaca/= directory: https://github.com/progfolio/elpaca/issues/151#issuecomment-2601038260 . Probably use Git-lfs for that. I only wonder if having this public could be security issue in any way.
 - [X] Use the rudimentary support for lock files that was freshly added: https://github.com/progfolio/elpaca/issues/151#issuecomment-2629560507 .
I might even want to use both hm! Gotta figure it out.

** Should do
*** TODO Look into workgroups
*** TODO I will want some way to easily restore where I stopped working.

Maybe some presets -> e.g. quick loading of waspc project with certain file opened. Or maybe just from where I stopped.

*** TODO Go through my spacemacs config and copy stuff I liked from there.
*** TODO Smooth scrolling
- Enable that new smooth/pixel scroll setting in emacs?
- https://github.com/jdtsmith/ultra-scroll -> external package
*** TODO Try org roam, what is it about?
** Going beyond
*** TODO Set up RSS feeds following in emacs ([[https://www.reddit.com/r/emacs/s/bOnWC7cv44][reddit]])
*** TODO Read [[https://www.reddit.com/r/emacs/s/mnpkOjzbOT][Article with nice explanation of IDE packages (lsp, dap, ...)]]
*** TODO Check out Prot's basic [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/][emacs config]]
*** TODO Try using command pallete
Similar to what VSCode has, and Sublime Text made popular. Also similar to vim telescope.
So instead of showing everything down there in the minibuffer, show some stuff in the command pallete at the top / middle of the screen.
I am not sure if I will like this or not, but I think it is worth trying it out.
- ivy-posframe package -> just for ivy completions
- emacs-miniframe -> for anything happening in the minibuffer
*** TODO Try Nano theme.
- Some additional work by Rougier that is interesting: https://www.reddit.com/r/emacs/comments/1hoehaa/boxes_everywhere/?share_id=H0m8UzpeWYzXfvp6dOXXu&utm_content=1&utm_medium=android_app&utm_name=androidcss&utm_source=share&utm_term=10
*** TODO Use smartparens or electric-pair-mode?
*** TODO Take a look at dogears.el -> sounds potentially useful, not sure though.
*** TODO symbol-overlay, multiple-cursors, and their [[https://lmno.lol/alvaro/its-all-up-for-grabs-and-it-compounds][combo]].
*** TODO Make is so that init.el and early-init.el are read only by default?
I could, in org-mode-hook, check buffer-file-name, and if it is one of these two files,
make them read only by default.
*** TODO Check out how System Crafters organized their Emacs.org
*** TODO Learn some Org keybindings / tricks
- [ ] How can I easily hide / fold / show current header and its parents?
- [ ] How can I easily navigate through headers?
- [ ] How can I increase/decreaese level of whole hierarchy/region of headers?
      A: Seems like that is done with M-<left> or M-<right>
*** TODO Improve my Org faces / look.
- [ ] Better way to communicate that header is collapsed (something more visible than three dots).
- [ ] Give a try at non-monospace font for not-code (check System Crafters video).
   - Fixed-pitch font: JetBrains Mono, light weight.
   - Variable-pitch font: Iosevka Aile, light weight.
- [ ] Play with toggling org-indent and org-bullets.
*** TODO Add "SPC j" prefix for "jump" and then put jump/goto commands under that?.
Or, go for "SPC g" and move magit to "SPC a g"? I think I should move magit there in any case, to free up "SPC g".
Stuff I could put under "SPC j" (or "SPC g") is avy/ace jumping around the file/window, stuff like "counsel-imenu" that lets me move around the definitions in file, ... .
Hm or it could even be "SPC n" for navigation? Maybe that is the best one, it is broad and niche enough at the same time.
Of course I would still keep some specific navigation like window or buffer under buffer/window prefixes, while I would put more general stuff here.
Or, maybe I don't need "SPC j" and I should just organize navigating by domain? So jumping around file -> under "SPC f". Jumping around the window -> under "SPC w". Counsel-imenu -> under "SPC b" or "SPC f".

*** TODO Look into [[https://github.com/karthink/popper][popper]] -> specify which buffers should appear in a popup
*** TODO Does emacs have this thing where you can easily get a list of keybindings to do stuff specific for current major mode?
I think it is something like "." or ","? If yes, copy that if I can, if not, it would be nice to have that, or if not that, then some other way where I can easily figure out the main commands for this major mode (e.g. org). I konw there is C-h m, but that has too much noise for me usually.
I know that some modes (e.g. Org) have keymaps, and I see Orgs keymap mapped to C-c. Maybe that is it, the convention? I just need to add additional map to what C-c maps to?

*** TODO Check this emacs eyecandy post for good ideas
https://lmno.lol/alvaro/my-emacs-eye-candy
*** TODO Hint system
I would love to show some kind of hints in certain situations. Couple of useful keybindings when I am in some context. Kind of like Helm in Spacemacs shows it at that footer it has. Maybe some text also.
But for Ivy. Also, for stuff like company when in completion popup, to remind me of C-s and C-M-s. What if I had an area in my emacs where contextual tips are shown as you do some actions?
For example they get shown when you open completion popup, or when you start using Ivy? Could I make this a universal mechanism? Maybe I can expand it then for a bit more info if I want,
for my custom cheasheet? It would be kind of a "publish" mechanism I guess.
Btw I started, in this org document, having headers with :cheatsheet: tag, where I collect these "cheatsheets".

Ok, so refinement of the idea:
- I implement logic that, at current moment, determines what the context is. Looks at buffer name, thing at point, major mode, couple of things like that. This is the core of things.
- Then, I allow them to connect pieces of .org markup with specific contexts. For example, they can say "this piece of .org markup will be a hint for any context with this buffer name (and or this major mode, this minor mode, ...)". How do they do that? I imagine that in some .org file, they put a property under PROPERTIES that describes to which context does this header attach. I could imagine they can specify it narrower or wider: each condition they add is combined via AND with the rest of the conditions that describe a context.
  This also means they would need to specify which org file(s) to search in for these hints.
- I implement a command `hints-show` that recognizes current context and based on it displays relevant hints. They are using .org markup so I imagine it would show them in a readonly org buffer, that was somehow produced by adding all hints that are connected with this context.
- For easier usage, I should also implement a function `hints-add` that recognizes current context, and then based on it creates a new entry in the .org file that is used for hints (if there are multiple, it can ask which one you want to add this to). I can also ask if you want to reuse existing entry, if such entry exists. This would make it easier to add new hints easily, exactly in the situation where you want to see them. I wonder if orgs capture templates would be of any help here.
- Might also be convenient to have `hints-context` which just shows current context. It could be useful in some situations, when debugging.
- Possible fun name for package: intel! Intel for the context. int.el .
  
*** TODO Try replacing Ivy, Counsel, Swiper, and Company even, with Vertico, Marginalia, Orderless, Embark, Corfu, ...
Vertico is alternative to Ivy, the rest are supporting packages for it same like Counsel and Swiper are for Ivy, and then Corfu is a replacement for Company.
Seems like a lot of people like Vertico, ... , Corfu and the rest. Allegedly they using more of native Emacs stuff, so are simpler but also make more sense? Hm.
Embark seems great, it is a quite unique package: the idea is that you have a keybinding for it and then whenever you are doing something, you hit that keybinding and Embark
offers you actions that you can do in that situation / with that thing. It does however work best if Marginalia is used, because it gives it more context on stuff, and Marginalia
works best with the rest of the stuff above, so it kind of pulls one another hm, so it probably makes sense to try to go for all of it at once.

*** TODO To figure out what packages to install, I should take a look at what Doomemacs, Spacemacs (and their layers), Emacs-bedrock, and others, use, for inspiration, and how they have it configured.

- [ ] Check out bedrock emacs, simple starting config but has good stuff allegedly: https://sr.ht/~ashton314/emacs-bedrock/ .
- [ ] Check out config by this Prot guy, people say it is good: https://protesilaos.com/emacs/dotemacs .
- [ ] Another emacs config to check out, kickstarter for neovimers, might have some good stuff for evil: https://github.com/LionyxML/emacs-kick . I also saw it uses vertico, marginalia, ... .
- [ ] Check out Zuzic's emacs config: https://mail.google.com/mail/u/0/#all/KtbxLwHDghsHQDzKGkxWCWmFZsNSCGcHQq

*** TODO Learn more about Avy: https://karthinks.com/software/avy-can-do-anything/ .
*** TODO Read more about other [[https://www.reddit.com/r/emacs/comments/1gux2bi/org_search_vs_organization/?share_id=f51nt5J93w5gxGj6rjjqm&utm_content=1&utm_medium=android_app&utm_name=androidcss&utm_source=share&utm_term=10][people's org workflows]]:
