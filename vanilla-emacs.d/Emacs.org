#+TITLE: My Vanilla Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes :results none
#+STARTUP: fold

* README (Intro)
Whenever this file is saved from my emacs, =init.el= and =early-init.el= are automatically generated based on it. Check [[*Automatically tangle this file (Emacs.org)]] for logic that does this.

Even though =init.el= and =early-init.el= are generated, I still keep them in version control (git), because it helps me avoid the situation where I don't have them on disk (maybe I deleted them, or I did fresh checkout) and can't easily start emacs and evaluate this very org file in order to generate them! By keeping them in version control, I have easy access to them, and I can even more easily see the diffs that were done.

Sometimes manual setup is needed for certain parts of this config to work, for example installing external dependencies or setting up API keys -> settings local to the machine. In such case, you will find instructions how to do it spread through this file, and they will be labeled with =manual_setup= org label.

** NOTE: Splitting (use-package) declarations into multiple org code blocks
This can be useful in order to nicely group and document the code. In this case, best way to do this is to use =(with-eval-after-load 'packagename <code that would normally go under :config>)=, for code that would go under =:config=, which is usually what we need, this is better then having multiple =(use-package ...)= declarations for the same package, because those can allegedly mess up with each other then.

* Preamble (must go first)
** Lexical binding
This has to be first line in the file (in this case init.el) for lexical binding to be enabled!

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

** Timestamps
I am actually not sure how useful is this but I found it fun.

#+name: timestamp
#+begin_src emacs-lisp :tangle no :results value none
  (format-time-string "%Y-%m-%d %H:%M:%S %Z")
#+end_src

#+begin_src emacs-lisp :tangle ./early-init.el :noweb yes
  ;; NOTE: This file was generated from Emacs.org on <<timestamp()>>, don't edit it manually.

#+end_src

#+begin_src emacs-lisp :tangle ./init.el :noweb yes
  ;; NOTE: This file was generated from Emacs.org on <<timestamp()>>, don't edit it manually.

#+end_src

* Package management
** Tutorial
*** package.el vs use-package vs elpaca

There are three important "packages" to understand here: package.el, use-package, and elpaca.

- **package.el** is a default package manager (like e.g. cabal for Haskell) that comes with emacs.
- **use-package** is a third-party package that allows for nicer, declarative and performant way to define your package configurations.
  It uses package.el in the background to install packages, but it is not a package manager, instead it is a layer above it that is focused on loading and configuring packages (and not installing, that it delegates to package manager).
- **elpaca** is a third-party package that is a package manager, a direct alternative to package.el, but more powerful / performant. Instead of downloading tarballs from .e.g melpa, it pulls package sources directly from their git repos.

In this config I use elpaca + use-package (package.el is not even loaded).

*** Installing vs loading vs configuring packages

- Installing package means downloading (and building) the package to your machine, so it can be loaded when you want.
  This is what package manager does for you.
- Loading package means importing/requiring it in our emacs config (init.el), so it can be used. It needs to be installed first in order to be loaded (unless it comes with emacs already).
  This is what use-package takes care of.
- Configuring means exactly that: adapting the package to your needs by defining variables, key bindings, hooks, ... .
  use-package also helps with this, giving us structure and reducing boilerplate.

*** Lifecycle of a package

1. Installation typically happens when you start emacs for first time on new machine, or when you update packages or add new package.
2. Loading typically happens each time you start emacs, and it can happen immediately on init, or it can happen later, on demand,
   when package is needed (in lazy fashion), depending on how you set it up for that package.
3. Configuration typically happens right after loading.

*** use-package

The idea is that you organize all your code in `(use-package <package-name> ...)` declarations.
There is even `(use-package emacs ...)` where `emacs` is a special "package" that won't trigger any installation or loading, allowing you to put general emacs config under it (e.g. `(column-number-mode)`).

use-package has a bunch of keywords that you can use to configure your package or define how it is loaded / installed.
Mostly you will use keywords that come with use-package, but other packages can also extend use-package with their own keywords.
I will quickly explain some of the more important/confusing ones:
- :ensure -> This is really an interface toward package manager (who does package installation). Any value passed to :ensure is passed to the package manager as instructions for installation, e.g. `:ensure (:host "github" :repo "user/repo")`.
    Therefore, its behaviour depends on the package manager used. But generally, `:ensure nil` will not allow package installation, while `:ensure t` or any other value will try to do install package if not installed yet. Should be really named :ensure-installed hah.
    Normally you will want `:ensure t` for most of the packages, in which case you can (I do) configure use-package to have it be `t` by default.
    When using elpaca, you can pass elpaca recipe to :ensure.
- :defer -> `:defer t` tells use-package to postpone loading of the package till it is needed (lazy). See "deferred loading" below.
    Alternatively, you can pass it a number of seconds emacs needs to be idle before package is loaded.
- :demand -> Opposite of defer, `:demand t` tells use-package to load package now. Useful when using autoload keywords (see "deferred loading" below).
- :init -> happens right before package is loaded.
- :config -> happens right after package is loaded.
- ...

**** Deferred loading 

It is generally recommended to postpone/defer loading of packages till they are needed (if applicable), for faster emacs startup.

use-package will defer loading of packages if `:defer <non-nil>` is set, or if any of the keywords with the "autoloading side effect" are used (e.g. `bind`, `command`, `hook`, ... : these all will make use-package defer loading and then autoload package once corresponding binding / command / hook / ... has happeend).

If you use any of the "autoload" keywords but don't want use-package to be "smart" and assume you want autoloading, you can use `:demand t`.

It can be good practice to add `:defer t` even when autoloading keywords are used, to be explicit about the intention.

*** elpaca
Elpaca can install package directly: `(elpaca some-package (message "this happens after package is installed"))`, but we use it via use-package.
In the background, a call to `(use-package some-package :ensure t :some-keyword <smth>)` becomes `(elpaca some-package (use-package some-package :some-keyword <smth>))`.

Compared to native package.el, that pulls in tarballs from package repos, Elpaca (and also Straight) work in a different way -> they pull package sources directly from their github repos, based on the "recipes", which say for each package where to pull from (and optionally how to build them).

**** Recipes

Elpaca allows you to define how the package should be installed via a `recipe`, which is provided as an argument to `:ensure` if using `use-package`.
Example of a recipe: `(some-package :host github :repo "user/example")`.

**** Deferred installing

Elpaca, unlike package.el, doesn't install packages immediately, instead it waits for emacs init to finish, and then installs them asynchronously, in parallel for fast, non-blocking installations.

To prevent this behaviour and make elpaca install package right now, when the corresponding `use-package` declaration is evaluated, one can pass `:wait t` keyword do the elpaca recipe: `:ensure (:wait t ...)`.
This can be useful for packages that e.g. add keywords to use-package, since you need those installed and loaded first.

Due to elpaca's deffered installing, instead of installing and loading happening during init phase (evaluation of init.el), we have following order of events: init -> installation of packages -> loading packages.
Exception are packages with `:wait t` in their recipe, those will get installed / loaded at init.
That also means that `after-init-hook` is often not the right choice any more, and we should instead use `elpaca-after-init-hook`, which will guarantee packages are installed / loaded.

** Config
*** Disable package.el (in early-init.el)

#+begin_src emacs-lisp :tangle ./early-init.el

  (setq package-enable-at-startup nil) ; Elpaca requires this.

#+end_src

*** Install and set up Elpaca (in init.el)

#+begin_src emacs-lisp

  ;; Install and set up Elpaca. 
  (defvar elpaca-installer-version 0.9)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1 :inherit ignore
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                    ,@(when-let* ((depth (plist-get order :depth)))
                                                        (list (format "--depth=%d" depth) "--no-single-branch"))
                                                    ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))

#+end_src
  
*** Install and set up use-package (with Elpaca as backend)

#+begin_src emacs-lisp

  (elpaca elpaca-use-package (elpaca-use-package-mode)) ; Install/setup use-package.
  (setq use-package-always-ensure t) ; Tells use-package to have :ensure t by default for every package it manages.

#+end_src

* Utils
** Packages

#+begin_src emacs-lisp

  (require 'cl-lib) ;; Common utilities and functions, e.g. cl-some, cl-loop, ... .

  ;; Package for displaying content in a nice inline overlay.
  ;; I use it in the rest of the config in some place(s).
  (use-package quick-peek)

#+end_src

** Vars

#+begin_src emacs-lisp

  (defun my/var-state (var)
    "Returns the value of a variable with specified name, or 'my/var-unbound if it is not bound."
    (if (boundp var) (symbol-value var) 'my/var-unbound)
  )

  (defun my/local-var-state (var)
    "Returns the value of a buffer-local variable with specified name, or 'my/var-unbound if it is not bound."
    (if (local-variable-p var) (symbol-value var) 'my/var-unbound)
  )

  (defun set-local (var value)
    "Like setq-local but takes a var symbol (analogous to setq and set)."
    (set (make-local-variable var) value)
  )

#+end_src

*** Saving and restoring buffer-local vars

#+begin_src emacs-lisp

  (defun my/save-local-var-state (var)
    "Save the current state of buffer-local VAR (symbol) and return a lambda that restores VAR to its original state.
  USAGE:
    (let ((restore-foo (my/save-local-var-state 'foo)))
      ...
      (funcall restore-foo)
    )"
    (let ((og-state (my/local-var-state var)))
      (lambda ()
        (if (eq og-state 'my/var-unbound)
  	(kill-local-variable var)
        (set-local var og-state)
      )
      )
    )
  )

  (defun my/save-local-vars-state (vars)
    "Like my/save-local-var-state but takes a list of vars.
  USAGE:
    (let ((restore-vars (my/save-local-vars-state '(foo bar buzz))))
      ...
      (funcall restore-vars)
    )"
    (let ((restore-fns (mapcar #'my/save-local-var-state vars)))
      (lambda () (dolist (restore-fn restore-fns) (funcall restore-fn)))
    )
  )

  (defun my/set-local-vars-with-restore (vars-and-values)
    "Set each variable in VARS-AND-VALUES as a buffer-local variable with the specified value.
  Returns a lambda that, when called, restores each variable to its original buffer-local state.
  VARS-AND-VALUES should be a list of (VAR . VALUE) pairs.
  USAGE:
    (let ((restore-vars (my/save-local-vars-with-restore '((foo . 42) (bar .  t)))))
      ...
      (funcall restore-vars)
    )"
    (let* ((vars (mapcar #'car vars-and-values))
  	 (restore-fn (my/save-local-vars-state vars)))
      (dolist (var-and-value vars-and-values)
        (let ((var (car var-and-value))
  	    (value (cdr var-and-value)))
  	(set-local var value)
        )
      )
      restore-fn
    )
  )

#+end_src

** Modes
*** Saving and restoring

#+begin_src emacs-lisp

  (defun my/save-mode-state (mode)
    "Save the current state (enabled or disabled) of MODE (symbol) and return a lambda that restores MODE to its original state.
  USAGE:
    (let ((restore-evil-local-mode (my/save-mode-state 'evil-local-mode)))
      ...
      (funcall restore-evil-local-mode)
    )"
    (let ((og-mode-var-state (my/var-state mode)))
      (lambda ()
        (when (not (eq og-mode-var-state 'my/var-unbound))
          (funcall mode (if (eq og-mode-var-state nil) -1 1))
        )
      )
    )
  )

  (defun my/save-modes-state (modes)
    "Like my/save-mode-state but takes a list of modes.
  USAGE:
    (let ((restore-modes (my/save-modes-state '(evil-local-mode org-tidy-mode))))
      ...
      (funcall restore-modes)
    )"
    (let ((restore-fns (mapcar #'my/save-mode-state modes)))
      (lambda () (dolist (restore-fn restore-fns) (funcall restore-fn)))
    )
  )

  (defun my/set-modes-with-restore (modes-and-values)
    "Set each mode in MODES-AND-VALUES with the specified value.
  Returns a lambda that, when called, restores each mode to its original state (enabled/disabled).
  MODES-AND-VALUES should be a list of (MODE . VALUE) pairs.
  USAGE:
    (let ((restore-modes (my/save-modes-with-restore '((evil-local-mode . -1) (org-tidy-mode . 1)))))
      ...
      (funcall restore-modes)
    )"
    (let* ((modes (mapcar #'car modes-and-values))
  	 (restore-fn (my/save-modes-state modes)))
      (dolist (mode-and-value modes-and-values)
        (let ((mode (car mode-and-value))
  	    (value (cdr mode-and-value)))
  	(funcall mode value)
        )
      )
      restore-fn
    )
  )

#+end_src

** List

#+begin_src emacs-lisp

  (defun random-atom (xs)
    "Returns a random atom from the given list."
    (nth (random (length xs)) xs)
  )

#+end_src

** Quotes

#+begin_src emacs-lisp

  (defvar my-motivational-quotes
    '("\"You have power over your mind – not outside events. Realize this, and you will find strength.\" – Marcus Aurelius"
      "\"First say to yourself what you would be; and then do what you have to do.\" – Epictetus"
      "\"Waste no more time arguing about what a good man should be. Be one.\" - Marcus Aurelius"
      "\"No man is free who is not master of himself.\" – Epictetus"
      "\"Well-being is attained by little and little, and nevertheless is no little thing itself.\" – Zeno of Citium"
      "\"Don’t explain your philosophy. Embody it.\" - Epictetus"
      "\"No great thing is created suddenly.\" – Epictetus"
      "\"Begin at once to live, and count each separate day as a separate life.\" – Seneca"
      "\"Dwell on the beauty of life. Watch the stars, and see yourself running with them.\" – Marcus Aurelius"
      "\"Nulla dies sine linea.\" - Pliny the Elder"
      )
  )

#+end_src

* Basic Emacs config

#+begin_src emacs-lisp

  (use-package emacs
    :ensure nil
    :config
    (setq inhibit-startup-message t)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (menu-bar-mode -1)
    (setq ring-bell-function 'ignore)
    (set-fringe-mode 10)
    (setq-default fill-column 100)
    (column-number-mode) ; Show row:column in mode line.
    (visual-line-mode 1) ; Treat wrapped lines as multiple lines when moving around.
    (global-hl-line-mode 1) ; Highlights the line in which cursor is.
    (global-auto-revert-mode t) ; Automatically reload files if they change on disk (will ask if conflict).
    (add-hook 'window-setup-hook 'toggle-frame-fullscreen t) ; Start in fullscreen.

    (setq gc-cons-threshold 100000000) ; Default is low, so we set it to 100mb. Helps with e.g. lsp-mode.
    (setq read-process-output-max (* 1024 1024)) ;; Default is low, so we set it to 1mb. Helps with e.g. lsp-mode.

    (setq initial-major-mode 'org-mode) ; Start Scratch buffer with Org mode.
    (setq initial-scratch-message (concat "# " (random-atom my-motivational-quotes) "\n\n"))

    (global-subword-mode) ; Makes vim motions treat subwords in camelCase as individual words.
  )

#+end_src

* Theme

#+begin_src emacs-lisp

  ;; doom-themes have nice, high quality themes.
  (use-package doom-themes
    :ensure (:wait t) ; Too ensure theme gets loaded as early as possible, so there is no white scren.
    :config
    ;; I went with dracula for now. palenight is also nice.
    ;; TODO: Figure out where and how is the best way to do theme customization. I am guessing it shoudl be happening in a central place,
    ;;   even if it is about other packages faces, and that it should happen next to loading of the theme?
    (load-theme 'doom-moonlight t)
  )

#+end_src

* Modeline

#+begin_src emacs-lisp

  ;; TODO: Configure better or use some other modeline.
  (use-package doom-modeline
    :config
    (setq doom-modeline-height 40)
    (doom-modeline-mode 1)
  )

#+end_src

* Undo
** Increase undo memory limits

#+begin_src emacs-lisp

  (use-package emacs
    :ensure nil
    :config
    ;; Default emacs undo limits are quite low so we increase them here.
    (setq undo-limit         50000000) ; ~50mb.
    (setq undo-strong-limit 100000000) ; ~100mb.
    (setq undo-outer-limit  300000000) ; ~300mb.
  )

#+end_src

** undo-fu: "normal" undo behaviour

**undo-fu** is a simple package that brings undo/redo commands that behave in a simple, linear fashion, like you would expect.
However, it still keeps emacs' undo/redo complex system intact with all the state it keeps, these commands just serve as a simpler interface toward it, so you can still interact with it if you wish (e.g. with vundo which visualizes the undo state as tree).
I don't set any keybindings here because it is enough to set undo-fu as evil's undo system (check my evil config) and then evil uses it.

#+begin_src emacs-lisp

  (use-package undo-fu
    :config
    (setq undo-fu-ignore-keyboard-quit t) ; I don't want C-g to trigger normal emacs undo behavior.
  )

#+end_src

** vundo: undo tree

#+begin_src emacs-lisp

  ;; Displays undo history as a tree and lets you move through it.
  (use-package vundo
    :defer t
    :config
    (setq vundo-glyph-alist vundo-unicode-symbols)

    ;;;;;; Vundo Live Diff ;;;;;;
    ;; In vundo, you have to manually mark one node and call diff on another node to get their diff.
    ;; Here we extend vundo to have "live diff mode", that always shows diff between current node and its parent.
    ;; I turn it on by default. It can be toggled by pressing "F".
    (defun vundo-live-diff-post-command ()
      "Post command hook function for live diffing."
      (when (not (memq this-command '(vundo-quit vundo-confirm)))
        (progn
          (vundo-diff-mark (vundo-m-parent (vundo--current-node vundo--prev-mod-list)))
          (vundo-diff)
        )
      )
    )
    (define-minor-mode vundo-live-diff-mode
      "Shows live diff between the current node and its parent."
      :lighter nil
      (if vundo-live-diff-mode
        (add-hook 'post-command-hook #'vundo-live-diff-post-command 0 t)
        (remove-hook 'post-command-hook #'vundo-live-diff-post-command t)
      )
    )
    (evil-define-key 'normal vundo-mode-map (kbd "F") #'vundo-live-diff-mode)
    (add-hook 'vundo-mode-hook (lambda () (vundo-live-diff-mode 1)))
    ;;;;;/ Vundo Live Diff ;;;;;;
  )

#+end_src

** TODO Install undo-fu-session?
Do I need persistent undo between the emacs sessions? I think not?
** TODO Install undo-hl (highlights changes by undo in buffer)?
Seems to not be on any package manager though, so I need straight.el probably.

* Keybindings
** general.el

#+begin_src emacs-lisp

  ;; general.el provides convenient, unified interface for key definitions.
  ;; It can do many cool things, one of them is specifying leader key and prefixes.
  ;; For best results, you should do all/most of the key defining via general (e.g. `general-define-key`).
  ;; NOTE: I found general.el to be really complex, and I haven't invested the time to properly understand it.
  ;;   Therefore, I don't completely understand if the config below is written in the best way, but
  ;;   it was recommended by others and it seems to work.
  (use-package general
    :ensure (:wait t) ; Load it immediately, so that I can use :general keyword in use-package declarations below if I want.
    :config
    (general-evil-setup t)

    ;; Here we use the following two expressions to create a function ~my/leader-keys~ that we can then use to created
    ;; new keys that all start with SPC prefix (leader key).
    (general-define-key
      :prefix-map 'my/leader-map
      :states '(motion normal insert visual emacs)
      :keymaps 'override ; Override any other keymaps with same keybindings. Otherwise I get issues with the `motion` and SPC, since `motion` already defines keybindings for SPC.
      :prefix "SPC" ; This will be active only in "normal"-like states (so `normal`, `motion` and `emacs`).
      :global-prefix "C-SPC" ; This will be always active.
    )
    (general-create-definer my/leader-keys
      :keymaps 'my/leader-map)

    ;; TODO: Also, should I use :general keyword in use-package? Figure this out, the best way to define keybindings with SPC prefix,
    ;;   should they all be here, or in their respective packages, or what.
    (my/leader-keys
      "SPC" '("M-x (exec cmd)" . counsel-M-x)
      "TAB" '("previous buffer" . my/alternate-buffer)
      "RET" '("work diary" . (lambda () (interactive) (org-agenda nil "w")))

      "0"   '("jump to window 0" . winum-select-window-0)
      "1"   '("jump to window 1" . winum-select-window-1)
      "2"   '("jump to window 2" . winum-select-window-2)
      "3"   '("jump to window 3" . winum-select-window-3)
      "4"   '("jump to window 4" . winum-select-window-4)

      ;; TODO: When inside counsel-projectile-rg, you can do C-c C-o to persist the search results in a special buffer,
      ;;   and then in that buffer you can press enter on any of them and jump to that location.
      ;;   This is awesome, but how will I remember this? Somehow help myself remember this. Another candidate for "hint"/"help" zone?
      ;;   Btw Helm (in Spacemacs) has this bar at the bottom where it shows which command was just run and some hints (C-z for actions, ...).
      ;;   Is this something I can replicate, at least for Ivy?
      "/"   '("search in project" . counsel-projectile-rg)
      "*"   '("search in project w/input" . counsel-projectile-rg-region-or-symbol)

      "t"   '("toggles" . (keymap)) ; This is how prefix is defined.
      "tt"  '("choose theme" . counsel-load-theme)
      "ts"  '("scale text" . hydra-text-scale/body)

      "a"   '("apps" . (keymap))
      "au"  '("undo tree" . vundo)

      "af"  '("fun" . (keymap))
      "afa" 'animate-birthday-present
      "afb" 'blackbox
      "afc" 'butterfly
      "afd" 'doctor
      "afe" 'bubbles
      "aff" 'dunnet
      "afg" 'gnugo
      "afh" 'hanoi
      "afi" 'gomoku
      "afj" 'solitaire
      "afl" 'life
      "afp" 'pong
      "afs" 'snake
      "aft" 'tetris
      "afx" '5x5
      "afz" 'zone

      "q"   '("quit" . (keymap))
      "qq"  '("quit" . save-buffers-kill-terminal)
      "qr"  '("restart" . restart-emacs)

      "w"   '("windows" . (keymap))
      "ww"  '("other window" . ace-window)
      "wd"  '("delete window" . delete-window)
      "wx"  '("delete window and buffer" . kill-buffer-and-window)
      "w/"  '("split vertically" . split-window-right)
      "w-"  '("split horizontally" . split-window-below)
      "wr"  '("resize window" . hydra-window-resize/body)
      "wm"  '("move window" . hydra-window-move/body)
      "w."  '("focus window" . delete-other-windows)
      "w="  '("balance window sizes" . balance-windows)

      "b"   '("buffers" . (keymap))
      "bb"  '("switch buffer" . ivy-switch-buffer)
      "bd"  '("kill buffer" . kill-this-buffer)
      "bs"  '("go to scratch" . scratch-buffer)
      "bm"  '("go to messages" . my/switch-to-messages-buffer)
      "bp"  '("previous buffer" . hydra-buffer-next-prev/previous-buffer)
      "bn"  '("next buffer" . hydra-buffer-next-prev/next-buffer)
      "br"  '("reload buffer" . revert-buffer)

      "e"   '("errors" . (keymap))

      "f"   '("files" . (keymap))
      "fj"  '("jump in file" . avy-goto-char-timer)
      "ff"  '("find file" . counsel-find-file)
      "fs"  '("save" . save-buffer)
      "fr"  '("recent files" . counsel-recentf)

      "fe"  '("emacs" . (keymap))
      "feo" '("open Emacs.org file" . my/open-emacs-org-file)
      "fei" '("open init.el file" . my/open-init-file)

      "i"   '("ai" . (keymap))
      "ii"  '("interactive menu" . gptel-menu)
      "ic"  '("chat" . gptel)
      "is"  '("send (point/selection)" . gptel-send)
      "ir"  '("rewrite" . gptel-rewrite)
      "ia"  '("add to context (region/buffer)" . gptel-add)
      "if"  '("add to context (file)" . gptel-add)

      "v"   '("eval (elisp)" . (keymap))
      "vl"  '("last-sexp" . eval-last-sexp)
      "vv"  '("top-level form" . eval-defun)
      "vr"  '("region" . eval-region)

      "o"   '("org" . (keymap))
      "oa"  '("agenda" . org-agenda)
      "oc"  '("capture" . org-capture)
      "ol"  '("store link" . org-store-link)

      "p"   '("projects" . (keymap))
      "pf"  '("find file" . counsel-projectile-find-file)
      "pd"  '("find dir" . projectile-find-dir)
      "pb"  '("switch buffer" . projectile-switch-to-buffer)
      "pp"  '("switch project" . counsel-projectile-switch-project)
      "pr"  '("find and replace" . projectile-replace)
      "p."  '("all commands" . projectile-command-map)
    )

    (general-define-key
      :states '(normal visual)
      :keymaps 'override
      "p" 'my/paste-after-then-hydra
      "P" 'my/paste-before-then-hydra
    )
  )

#+end_src

** which-key

#+begin_src emacs-lisp

  (use-package which-key
    :config
    (setq which-key-idle-delay 0.5)
    (setq which-key-add-column-padding 2)
    (setq which-key-min-display-lines 5)
    (which-key-mode)
  )

#+end_src

** hydras

Hydra enables you to define a small "menu", which when you activate, activates transient unique keybindings (which you also defined) that you can use only then, and lists them in the minibuffer in a nice menu.

It is convenient when you need to spam a lot of very specific commands, e.g. scale text (in / out), or resize window (left / right / up / down), or iterate through kill ring, or something like that.
So then you go into "text scale resizing mode" to put it that way, and you can easily resize it with e.g. one letter commands.

#+begin_src emacs-lisp

  (use-package hydra
    :config
    (defhydra hydra-text-scale ()
      "Scale text"
      ("j" text-scale-decrease "out")
      ("k" text-scale-increase "in")
      ("r" (progn (text-scale-increase 0)) "restore")
      ("q" nil "quit" :exit t)
    )

    (defhydra hydra-buffer-next-prev ()
      "Next/previous buffer"
      ("p" previous-buffer "previous")
      ("n" next-buffer "next")
      ("q" nil "quit" :exit t)
    )

    (defhydra hydra-paste ()
      "Choose what to paste from the kill ring"
      ("C-j" evil-paste-pop "previous")
      ("C-k" evil-paste-pop-next "next")
      ("/" (progn
            (evil-undo-pop) ; Undo last paste.
            ;; NOTE: Ideally, I would put the new paste (about to be selected by counsel-yank-pop)
            ;; starting exactly from the same place as previous paste, as e.g. evil-paste-pop does,
            ;; but I haven't found a simple way to implement that, so I do a more simplistic
            ;; approach, below that is a bit less precise (e.g. adds redundant newline). However I
            ;; don't think that is a big problem if one decided to browse kill ring visually, you
            ;; care less about speed / formatting then.
            (goto-char (nth 2 evil-last-paste)) ; Put cursor back where it was before the last paste.
            (if (eq last-command 'evil-paste-before)
                (evil-insert-newline-above)
                (evil-insert-newline-below)
            )
            (counsel-yank-pop) ; Browse kill ring, pick entry and paste it.
          )
          "browse"
      )
      ("q" nil "quit" :exit t)
    )
    (defun my/paste-after-then-hydra ()
      (interactive)
      (call-interactively 'evil-paste-after)
      (hydra-paste/body)
      ;; This way this command is recognized as evil-paste-after, making evil-paste-after a last-command,
      ;; which is a requirement for evil-paste-pop functions from hydra-paste to be able to be executed
      ;; after this one.
      (setq this-command 'evil-paste-after)
    )
    (defun my/paste-before-then-hydra ()
      (interactive)
      (call-interactively 'evil-paste-before)
      (hydra-paste/body)
      (setq this-command 'evil-paste-before)
    )

    (defhydra hydra-window-resize (:hint nil)
      "
    Resize window
    -------------
                _h_: ⇾ ⇽          ↑        ↓
                              _k_:     _j_:
                _l_: ⇽ ⇾          ↓        ↑
    "
      ("h" shrink-window-horizontally)
      ("j" shrink-window)
      ("k" enlarge-window)
      ("l" enlarge-window-horizontally)
      ("q" nil "quit" :exit t)
    )

    (defhydra hydra-window-move (:hint nil)
      "
    Move window
    -----------
                        _k_: top
                _h_: left       _l_: right
                        _j_: bottom
    "
      ("h" evil-window-move-far-left)
      ("j" evil-window-move-very-bottom)
      ("k" evil-window-move-very-top)
      ("l" evil-window-move-far-right)
      ("q" nil "quit" :exit t)
    )
  )

#+end_src

** Evil

#+begin_src emacs-lisp
  
  ;; CHEATSHEET: C-z puts us into `emacs` mode, which is normal situation without evil.
  (use-package evil
    :init
    (setq evil-want-integration t)  ; Required by evil-collection.
    (setq evil-want-keybinding nil) ; Required by evil-collection.
    (setq evil-undo-system 'undo-fu)
    ;; C-u-scroll needs explicit enabling because in Emacs C-u is important, it is
    ;; universal argument. But I don't use it much, so I rather go with vi's
    ;; scroll, which I use a lot.
    (setq evil-want-C-u-scroll t)
    :custom
    (evil-shift-width 2) ; When shifting text left or right with < or >, do it for 2 spaces.
    :config
    (evil-mode 1)
    (define-key evil-motion-state-map (kbd "SPC") nil) ; To avoid conflict with me using SPC as leader key (defined via general.el).
  )

#+end_src

#+begin_src emacs-lisp

  (use-package evil-escape
    :after evil
    :custom
    (evil-escape-key-sequence "fd")
    :config
    (evil-escape-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Sets evil keybindings in many more parts of emacs than evil-mode does by default,
  ;; and in a better way than evil does.
  (use-package evil-collection
    :after evil
    :custom (evil-collection-setup-minibuffer nil)  ; If set to `t` it messes up / overrides my custom keybindings for Ivy (e.g. C-k).
    :config (evil-collection-init)
  )

#+end_src

* Org mode
** Basic setup (org)

#+begin_src emacs-lisp

  (use-package org
    :defer t
    :hook
    (org-mode . (lambda ()
      (org-indent-mode) ; Enforces correct indentation under each heading.
      (visual-line-mode 1)
      (setq evil-auto-indent nil)
    ))
    :config
    ;; Set headers to have different sizes.
    (dolist (face '((org-level-1 . 1.5)
                    (org-level-2 . 1.3)
                    (org-level-3 . 1.2)
                    (org-level-4 . 1.1)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :height (cdr face))
    )

    (setq org-log-into-drawer t)
    (setq org-habit-graph-column 60)

    (setq org-ellipsis "…")

    (add-to-list 'org-modules
  	'org-habit
    )
  )

  ;; Replace stars (*) with nice bullets.
  (use-package org-bullets
    :after (org)
    :defer t
    :hook (org-mode . org-bullets-mode)
  )

  ;; Org Tempo expands snippets to structures defined in org-structure-template-alist and org-tempo-keywords-alist.
  (use-package org-tempo
    :after (org)
    :ensure nil ; Comes with org already.
  )

  ; Colors tags in org mode with "random" colors based on their string hash.
  (use-package org-rainbow-tags
    :after (org)
    :hook (org-mode . org-rainbow-tags-mode)
    :custom
    (org-rainbow-tags-extra-face-attributes
     ;; Default is '(:weight 'bold)
     '(:inverse-video t :weight 'bold))
  )

  ;; Display "prettified" pieces of text in their raw shape when point is on them.
  ;; E.g. links or superscript.
  (use-package org-appear
    :hook (org-mode . org-appear-mode)
    :custom
    (org-appear-autoemphasis t)
    (org-appear-autolinks t)
    (org-appear-autosubmarkers t)
    (org-appear-autoentities t)
    (org-appear-autokeywords t)
    (org-appear-inside-latex t)
    (org-appear-trigger 'always)
    ;; Make bold and italic and similar nice, since we now have org-appear
    ;; to show them as raw when needed.
    (org-hide-emphasis-markers t)
  )

#+end_src

** evil-org
#+begin_src emacs-lisp

  (use-package evil-org
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
  )

#+end_src

** Code blocks (org-babel)

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    ;; Here we define our custom structure templates (snippets) for quickly creating code blocks.
    ;; Typing e.g. "<elTAB" will expand it to snippet.
    (dolist (key-to-block-type '(("sh" . "src shell")
                                 ("el" . "src emacs-lisp")
  			       ("py" . "src python")))
      (add-to-list 'org-structure-template-alist key-to-block-type)
    )
    
    ;; Define which languages can be evaluated/executed in org files.
    ;; Org will load support for them.
    (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (python . t))
    )

    (setq org-confirm-babel-evaluate nil) ; Don't ask for confirmation when evaluation a block.
  )

#+end_src

** Calendar sync

Two most popular emacs packages for pulling in calendar events into org file are https://github.com/dengste/org-caldav and https://github.com/kidd/org-gcal.el . I decided to go with the later one, but for no strong reason except for it being specific for gcal.

#+begin_src emacs-lisp

  (use-package org-gcal
    :init
    ;; Get calendar credentials from .authinfo file and use them.
    (let* ((gcal-auth-info (car (auth-source-search :host "gcal" :max 1 :require '(:user :secret))))
           
  	)
      (setq org-gcal-client-id (plist-get gcal-auth-info :user)
            org-gcal-client-secret ((lambda (x) (if (functionp x) (funcall x) x)) (plist-get gcal-auth-info :secret))
      )
    )
    ;; First elements of the pairs here are ids of google calendars.
    (setq my/calendar-events-wasp-org-file "~/Dropbox/calendar-events-wasp.org")
    (setq my/calendar-events-private-org-file "~/Dropbox/calendar-events-private.org")
    (setq org-gcal-fetch-file-alist `(("martin@wasp-lang.dev" . ,my/calendar-events-wasp-org-file)
  				    ("sosic.martin@gmail.com" . ,my/calendar-events-private-org-file)
  				    ))
    :config
    (setq org-gcal-recurring-events-mode 'nested)
    ;; So that it doesn't constantly ask me for the password. TODO: I wonder if I should make this a general setting, not org-gcal specific?
    (setq plstore-cache-passphrase-for-symmetric-encryption t)
  )

#+end_src

NOTE: It saves some stuff (secrets/passwords) locally with ~plist~. I followed intructions in README of org-gcal regarding it, to create an empty file if I get some issues, and also to add that one line in the config that tells it not to constantly ask for the password.

*** TODO Make fetching of events automatic (check org-gcal [[https://github.com/kidd/org-gcal.el?tab=readme-ov-file#sync-automatically-at-regular-times][README]])
*** Providing credentials                                    :manual_setup:
We need to create an OAuth 2.0 client id on our Google Developer Console for a project that gives access to the calendar, and then provide the client id and secret to org-gcal in order for it to be able to work with the calendar.

Detailed instructions on how to do this the Google side are provided in the org-gcal README.

As for storing client secret (and id) in safe manner, I decided to keep them in the ~/.authinfo file.
This is the manual setup part here: I need to make sure there is a line in that file of this format:
~machine gcal login <client-id> password <client-secret>~

In the config above I then fetch those credentials from .authinfo and provide them to org-gcal.

*** Cheatsheet                                                 :cheatsheet:
- ~org-gcal-fetch~ updates the events in all files in the alist, by pulling the info from the gcalendar.
  This is the command I will most often want to run.
- ~org-gcal-sync-tokens-clear~ clears the sync tokens (which is gcalendar concept). If they are not cleared, ~org-gcal-fetch~ will be fetching only changes after the time of the last fetch! This is ok if we kept all the events stored, but if we maybe deleted files with events and want to fetch them again, there want to do full sync -> we should run this command first.
** org-agenda
*** General setup
#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (setq org-agenda-scheduled-leaders '("-> " "-%dd -> "))
    (setq org-agenda-deadline-leaders '("! " "+%dd ! " "-%dd ! "))
    ;; Make the current time in the time-grid (<- now --------) stand out.
    (set-face-attribute 'org-agenda-current-time nil :inherit 'font-lock-constant-face :weight 'bold)
  )

#+end_src

*** org-super-agenda

Org-super-agenda allows both easier and smarter grouping of entries under a day/week org agenda view.
Each org-super-agenda group "consumes" entries it shows, leaving the next group with less entries, kind of like a parser. Whatever is left at the end is shown at the end of agenda as "Other items".

#+begin_src emacs-lisp

  (use-package org-super-agenda
    :after org
    :init 
    ;; org-super-agenda-header-map is keymap for super agenda headers and normally it just copies keybindings
    ;; from org-agenda-mode-map, but since I modify those later with evil-org, then I don't want
    ;; org-super-agenda-header-map sticking to the old keybindings and having super agenda headers behave
    ;; in default, non-evil way (e.g. "j" when on them doesn't move down but opens calendar).
    ;; I haven't managed to figure out how to update it to behave in an evil fashion, so I ended up just disabling
    ;; it completely, and that works great.
    (setq org-super-agenda-header-map nil)
    (setq org-super-agenda-keep-order t) ; Can degrade performance, which is why it isn't enabled by default.
    :config
    (org-super-agenda-mode)
  )

#+end_src

*** Evil keybindings

#+begin_src emacs-lisp

  (with-eval-after-load 'evil
    ;; TODO: I am basing these keybindings on the evil-org-agenda-set-keys function from
    ;;   evil-org-agenda.el (from evil-org package), but I copied them directly here so I can easily modify
    ;;   them as I wish.

    (evil-set-initial-state 'org-agenda-mode 'motion)

    (evil-define-key 'motion org-agenda-mode-map
      ;; Opening org file.
      (kbd "<tab>") 'org-agenda-goto
      (kbd "RET") 'org-agenda-switch-to
      (kbd "M-RET") 'org-agenda-recenter

      ;; Motion.
      "j" 'org-agenda-next-line
      "k" 'org-agenda-previous-line
      "gH" 'evil-window-top
      "gM" 'evil-window-middle
      "gL" 'evil-window-bottom
      (kbd "C-j") 'org-agenda-next-item
      (kbd "C-k") 'org-agenda-previous-item
      (kbd "[[") 'org-agenda-earlier
      (kbd "]]") 'org-agenda-later

      ;; manipulation
      ;; We follow standard org-mode bindings (not org-agenda bindings):
      ;; <HJKL> change todo items and priorities.
      ;; M-<jk> drag lines.
      ;; M-<hl> cannot demote/promote, we use it for "do-date".
      "J" 'org-agenda-priority-down
      "K" 'org-agenda-priority-up
      "H" 'org-agenda-do-date-earlier
      "L" 'org-agenda-do-date-later
      "t" 'org-agenda-todo
      (kbd "M-j") 'org-agenda-drag-line-forward
      (kbd "M-k") 'org-agenda-drag-line-backward
      (kbd "C-S-h") 'org-agenda-todo-previousset ; Original binding "C-S-<left>"
      (kbd "C-S-l") 'org-agenda-todo-nextset ; Original binding "C-S-<right>"

      ;; undo
      "u" 'org-agenda-undo

      ;; actions
      "dd" 'org-agenda-kill
      "dA" 'org-agenda-archive
      "da" 'org-agenda-archive-default-with-confirmation
      "ct" 'org-agenda-set-tags
      "ce" 'org-agenda-set-effort
      "cT" 'org-timer-set-timer
      "i" 'org-agenda-diary-entry
      "a" 'org-agenda-add-note
      "A" 'org-agenda-append-agenda
      "C" 'org-agenda-capture
      "e" 'org-agenda-tree-to-indirect-buffer

      ;; mark
      "m" 'org-agenda-bulk-toggle
      "~" 'org-agenda-bulk-toggle-all
      "*" 'org-agenda-bulk-mark-all
      "%" 'org-agenda-bulk-mark-regexp
      "M" 'org-agenda-bulk-unmark-all
      "x" 'org-agenda-bulk-action

      ;; refresh
      "gr" 'org-agenda-redo
      "gR" 'org-agenda-redo-all

      ;; quit
      "ZQ" 'org-agenda-exit
      "ZZ" 'org-agenda-quit

      ;; display
      "gD" 'org-agenda-view-mode-dispatch
      "ZD" 'org-agenda-dim-blocked-tasks

      ;; clock
      "I" 'org-agenda-clock-in ; Original binding
      "O" 'org-agenda-clock-out ; Original binding
      "cg" 'org-agenda-clock-goto
      "cc" 'org-agenda-clock-cancel
      "cr" 'org-agenda-clockreport-mode

      ;; go and show
      "." 'org-agenda-goto-today
      "gc" 'org-agenda-goto-calendar
      "gC" 'org-agenda-convert-date
      "gd" 'org-agenda-goto-date
      "gh" 'org-habit-stats-view-habit-at-point-agenda
      "gm" 'org-agenda-phases-of-moon
      "gs" 'org-agenda-sunrise-sunset
      "gt" 'org-agenda-show-tags
      "ge" 'org-agenda-entry-text-mode

      "p" 'org-agenda-date-prompt
      "P" 'org-agenda-show-the-flagging-note

      "+" 'org-agenda-manipulate-query-add
      "-" 'org-agenda-manipulate-query-subtract
    )
  )

#+end_src

*** Agenda custom commands

#+begin_src emacs-lisp

  ;; I wait for org-gcal because in :init or org-gcal I define vars that hold paths to files with calendar events,
  ;; and I need to know those paths so I can show events in the agenda.
  (with-eval-after-load 'org (with-eval-after-load 'org-gcal
    (defun make-work-diary-command (cmd-key cmd-name cmd-start-day)
      `(,cmd-key ,cmd-name
         (;; The main view: a list of tasks for today.
  	(agenda ""
  		((org-agenda-span 'day)
  		 (org-agenda-prefix-format " %12s %5e %?-12t")
  		 (org-agenda-sorting-strategy '(time-up todo-state-down priority-down scheduled-up urgency-down))
                   (org-agenda-time-grid '((daily today remove-match)
  					 (800 1000 1200 1400 1600 1800 2000)
                                           " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"
  			                )
                   )
  		 (org-habit-show-all-today t)
  		 (org-super-agenda-groups
  		  '(;; Repeating tasks to be done every day, including today.
  		    (:name "Daily Checklist"
  			    :and (:category "dc"
  				  :not (:log t))
  		    )
                      (:name "Todo (today)"
  		            :and (:time-grid t :not (:log t))
  		    )
  		    (:name "                   ----"
  			    :and (:category "task"
  				  :scheduled t
  				  :not (:log t))
  		    )
                      ;; Discard "closed" logs for items scheduled for today because they will be shown
  		    ;; as done already above, so we don't want to repeat it.
  		    ;; NOTE: Due to this bug in super-agenda https://github.com/alphapapa/org-super-agenda/issues/42,
  		    ;;   `:scheduled today` works as you would expect only when agenda is actually focused on today,
  		    ;;   because today means the actual day today, not the day that agenda daily view is focusing on.
                      ;;   Therefore if I look at yesterday, this discarding doesn't work and I get double done entries.
                      (:discard (:and (:scheduled today :log closed)))
  		    (:name none
  			    :and (:category "task"
  				  :log closed)
  		    )
  		    (:name "Clock log"
  	                   :log clocked
  		    )
                      (:name "Other (e.g. deadline w/o scheduled)"
                             :anything t
                      )
  		   )
  		 )
  		)
  	)
  	(alltodo ""
  		 ((org-agenda-overriding-header "")
  		  (org-agenda-prefix-format " %5e ")
  		  (org-super-agenda-groups
  		   '((:name "Notes"
    			    :category "note"
    		     )
  		     (:discard (:scheduled t :deadline t :time-grid t))
  		     (:name "All tasks with no schedule / deadline"
  			    :category "task"
  		     )
  		     (:discard (:anything t))
  		    )
  		  )
  		 )
  	)
         )
         ((org-agenda-files `("~/Dropbox/work-diary.org" ,my/calendar-events-wasp-org-file ,my/calendar-events-private-org-file))

  	(org-agenda-start-day ,cmd-start-day)

  	;; Starts agenda log mode, which means that special extra "log" entries are added to agenda, in this logs about closing an entry and logs about clocking an entry. I could also have added 'state' if needed. I track "closed" logs in order to ensure that entries that are DONE but have been scheduled in the past are shown in agenda (normally they are not). What is not great is that they are not normal but special log entries which are a bit different, so a bit harder to organize.
  	(org-agenda-start-with-log-mode '(closed clock))

  	;; Org agenda shows both scheduled and deadline entries for an item, when available.
  	;; I don't want that, so this way I avoid having both.
  	;; Instead, if before deadline, scheduled item is shown, but deadline warning is not.
  	;; And if after deadline, only item with deadline delay is shown, not the one with scheduled delay.
  	;; The only thing there was no way to configure is to avoid showing both scheduled and deadline entries
  	;; on the day of the deadline itself, so in that case both are shown, but ok I can live with that.
  	(org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  	(org-agenda-skip-scheduled-repeats-after-deadline t)

          (org-todo-keyword-faces
           '(("EPIC" . (:foreground "orchid" :weight bold))
             ("CANCELED" . (:foreground "dim gray" :weight bold :strike-through t))
             ("CANCELED[EPIC]" . (:foreground "dim gray" :weight bold :strike-through t))
             ("CHKL" . (:foreground "grey" :weight bold))
             ("NOTE" . (:foreground "white" :weight bold))
  	  )
          )
         )
      )
    )

    (setq org-agenda-custom-commands
  	(list
  	 (make-work-diary-command "W" "Work Diary (tomorrow)" "+1d")

  	 (make-work-diary-command "w" "Work Diary"            nil)

           '("p" "Private Diary"
  	   (;; The main view: a list of tasks for today.
  	    (agenda ""
  		    ((org-agenda-span 'day)
                       (org-agenda-prefix-format " %12s %5e ")
  		     (org-agenda-sorting-strategy '(todo-state-down priority-down urgency-down effort-down))
  		     (org-habit-show-all-today t)
                       (org-super-agenda-groups
  		      '((:name "Habits"
                                 :and (:category "habit"
                                       :not (:log t))
  			)
  			;; Tasks to be done today.
                          (:name "Todo"
                                 :and (:category "task"
  				     :scheduled t
  				     :not (:scheduled future)
  				     :not (:log t))
  			)
  			;; Tasks that were done today.
                          (:name none
                                 :and (:category "task"
                                       :log closed)
  			)
  		       )
                       )
  		    )
              )
              ;; All tasks without a schedule or a deadline.
              (alltodo ""
                       ((org-agenda-overriding-header "")
                        (org-agenda-prefix-format " %5e ")
  		      (org-super-agenda-groups
                         '((:discard (:scheduled t :deadline t :time-grid t))
                           (:name "All tasks with no schedule / deadline"
                                  :category "task"
                           )
  			 (:discard (:anything t))
  		        )
  		      )
                       )
  	    )
  	   )
  	   ((org-agenda-files `("~/Dropbox/private-diary.org" ,my/calendar-events-private-org-file))

  	    (org-agenda-start-with-log-mode '(closed clock))
              (org-agenda-skip-scheduled-if-done t)
              (org-agenda-skip-deadline-if-done t)

              (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
              (org-agenda-skip-scheduled-repeats-after-deadline t)
  	   )
  	  )
  	 )
    )
  ))

#+end_src

** org-tidy

#+begin_src emacs-lisp

  (use-package org-tidy)

#+end_src

** org-present

Turns any org document into a presentation! Each top-level header is one slide.

#+begin_src emacs-lisp

  (use-package org-present
    :after (org visual-fill-column org-tidy)
    :bind (
      :map org-present-mode-keymap
             ("q" . org-present-quit)
    )
    :config

    ;; TODO: I should make it work with evil-mode.
    ;;   Then I could not probably even need to go read-only.

    (defun my/on-presentation-start ()
      (let ((restore-local-vars
  	      (my/save-local-vars-state
  	        '(visual-fill-column-width
  		  visual-fill-column-center-text
  		  org-tidy-properties-style
  		  org-tidy-general-drawer-flag
  		  org-tidy-general-drawer-name-whitelist)))
            (restore-modes
                (my/save-modes-state
                  '(evil-local-mode
  		  visual-line-fill-column-mode
                    org-tidy-mode)))
  	 )

        (when (featurep 'evil)
          (evil-local-mode -1) ; Otherwise evil messes up org-present.
        )

        (org-present-big)
        (org-display-inline-images)
        (org-present-hide-cursor)
        (org-present-read-only)

        ;; Soft wraps the text at fixed width while also centering it.
        ;; TODO: I could get decent fixed width only with value of 20 when `(org-present-big)`
        ;;   is used above, while I would normally expect 80 to do it.
        ;;   Figure out why is that so -> does usage of `(text-scale-increase)` in `(org-present-big)`
        ;;   uses somehow mess things up? This is because it is after inline-images!
        ;; TODO: There also seems to be some weird interaction between this mode and (org-display-inline-images).
        ;;   If this happens before inlining images, then ATTR_ORG :width behaves weird.
        (setq-local visual-fill-column-width 20
                    visual-fill-column-center-text t)
        (visual-line-fill-column-mode 1)

        ;; Hide org drawers (:PROPERTY: and :NOTES:).
        (setq-local org-tidy-properties-style 'invisible
  		  org-tidy-general-drawer-flag t
  		  org-tidy-general-drawer-name-whitelist '("NOTES"))
        (org-tidy-mode 1)

        (defun my/on-presentation-quit ()
  	(org-present-small)
  	(org-remove-inline-images)
  	(org-present-show-cursor)
  	(org-present-read-write)

  	(funcall restore-local-vars)
  	(funcall restore-modes)

  	(remove-hook 'org-present-mode-quit-hook 'my/on-presentation-quit)
        )
        (add-hook 'org-present-mode-quit-hook 'my/on-presentation-quit)
      )
    )
    (add-hook 'org-present-mode-hook 'my/on-presentation-start)

    (defun my/org-present-eval-print-last-sexp ()
      "Evaluate and print (in buffer) the last sexp while in presentation mode."
      (interactive)
      (org-present-read-write)
      (eval-print-last-sexp)
      (org-present-read-only)
    )
  )

#+end_src

*** Cheatsheet :cheatsheet:
- `org-present` to go into presentation mode.
- left and right arrow take you to previous or next header (which is actually now a slide).
- "q" to exit the presentation.
- I configured it so that it hides :NOTES: org drawer, so you can use it to add speaker notes to each slide.

** Automatically tangle this file (Emacs.org)

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (defun my/org-babel-tangle-no-confirm ()
      (let ((org-confirm-babel-evaluate nil)) (org-babel-tangle))
    )
    (defun my/when-emacs-org-file-tangle-on-save ()
      (when (and buffer-file-name (file-equal-p buffer-file-name (my/emacs-org-file-path)))
        (add-hook 'after-save-hook 'my/org-babel-tangle-no-confirm nil 'local)
      )
    )
    (add-hook 'org-mode-hook 'my/when-emacs-org-file-tangle-on-save)
  )

#+end_src

** Cheatsheet :cheatsheet:
- Shift-Tab -> cycles through expanding headers. Can be used to fold all but the current item -> Shift-Tab to fold all, then Tab to unfold current item.
- structure templates (snippets) -> type "<snippetstringTAB" to expand it to snippet. e.g. "<el". Be faster than completion or reject it first with C-g.
- org-babel is org package (comes with org) that allows execution of code blocks, sharing data between code blocks (polyglot), tangling (exporting code into file / literal programming), ... .
- When in code block, to get full support for that language (proper completion, ...), open it in separate buffer with "C-c '" and do the editing there.

* My buffer/file functions

#+begin_src emacs-lisp

  (use-package emacs
    :ensure nil
    :config
    (defun my/alternate-buffer (&optional window)
      "Switch back and forth between current and last buffer in the current window."
      (interactive)
      (cl-destructuring-bind (buf start pos)
        (or (cl-find (window-buffer window) (window-prev-buffers) :key #'car :test-not #'eq)
            (list (other-buffer) nil nil)
        )
        (if (not buf)
          (message "Last buffer not found.")
          (set-window-buffer-start-and-point window buf start pos)
        )
      )
    )

    (defun my/open-init-file ()
      "Open the init file."
      (interactive)
      (find-file user-init-file)
    )

    (defun my/open-emacs-org-file ()
      "Open the init file."
      (interactive)
      (find-file (my/emacs-org-file-path))
    )

    (defun my/emacs-org-file-path ()
      (expand-file-name (file-name-concat user-emacs-directory "Emacs.org"))
    )

    (defun my/switch-to-messages-buffer ()
      "Switch to the messages buffer."
      (interactive)
      (switch-to-buffer "*Messages*")
    )
  )

#+end_src

* Ivy, Counsel and Swiper
** ivy

#+begin_src emacs-lisp

    ;; Ivy is the main thing (nice search through list of stuff, in minibuffer and elsewhere),
    ;; while Counsel and Swiper extend its usage through more of the Emacs.

    ;; TODO: Check out Ivy hydra -> I saw it in Ivy manual but don't know how to use it (it doesn't seem to be installed?).
    ;;   Allegedly (use-package ivy-hydra :after (ivy hydra)) should do the job? Try it.
    ;; TODO: Should I set Ivy to use fuzzy search? Is that better or not?
    ;; TODO: In Spacemacs (helm), coloring of listed files on C-x C-f is richer than I have in Ivy here.
    ;; Directories have stronger contrast, hidden files are grey, symbolic links neon, ... .
    ;; I should also get Ivy to behave like this! Right now it shows dirs in too similar color uses the same
    ;; color for all the rest.
    ;;   TODO: Show this cheatsheet somehow as part of Ivy buffers? Kind of like Helm does in Spacemacs?
    (use-package ivy
      :bind (
            ;; I define some evil-ish keybindings here since neither evil not evil-connection
            ;; define these specific ones for Ivy.
            :map ivy-minibuffer-map ;; When in the minibuffer.
                  ("C-h" . ivy-backward-kill-word)
                  ("C-j" . ivy-next-line)
                  ("C-k" . ivy-previous-line)
                  ("C-l" . ivy-alt-done)
                  ("TAB" . ivy-alt-done)
            :map ivy-switch-buffer-map ; When in the buffer switching mode.
                  ("C-j" . ivy-next-line)
                  ("C-k" . ivy-previous-line)
                  ("C-l" . ivy-done)
                  ("C-d" . ivy-switch-buffer-kill)
            :map ivy-reverse-i-search-map ; When doing incremental search.
                  ("C-j" . ivy-next-line)
                  ("C-k" . ivy-previous-line)
                  ("C-l" . ivy-done)
                  ("C-d" . ivy-reverse-i-search-kill)
            )
      :custom
      (ivy-height 20)
      (ivy-use-virtual-buffers t)  ; Adds recent files and bookmarks and similar to results.
      (ivy-display-style 'fancy)
      (ivy-count-format "(%d/%d) ")  ; (num listed / total num)
      (ivy-extra-directories nil)  ; Don't show ./ and ../
      :config
      ;; ivy-format-functions-alist determines for each place where ivy is used how the output should be formatted.
      ;; t stands for default case, if there was no more specific formatting function defined.

      ;; Here, we specify which formatting function to use as a default case (t).
      ;; We choose ivy-format-functon-line, that extends the higlight of selection to the edge of the window,
      ;; not just till the end of the selected word. This is one of default choices and it looks better.
      ;; This is recommended by ivy-rich, as a setting.
      (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-arrow-line)

      ;; ivy-re-builders-alist defines which completion styles (fuzzy, in order, ...) to use for which ivy usage.
      ;; Here I define that we use ivy--regex-ignore-order for all situations, instead of the default ivy--regex-plus,
      ;; which is the same but cares about the order of words in the query, which I found to not be useful.
      (setq ivy-re-builders-alist
            '((t . ivy--regex-ignore-order)))

      ;; ivy-initial-inputs-alist defines what to start specific searches with. Default is ^ for all searches,
      ;; which makes queries start from the start of each completion candidate, but I set it to nil to avoid that.
      (setq ivy-initial-inputs-alist nil)

      ;; This will enhance specific emacs commands with ivy automatically.
      (ivy-mode 1)
    )

#+end_src

*** Cheatsheet :cheatsheet:
- M-o when in an Ivy buffer shows extra commands that can be run on selected completion item.

** counsel

#+begin_src emacs-lisp

  ;; Counsel is a package that is part of Ivy ecosystem.
  ;; It brings enhanced versions of common emacs commands, powered by Ivy.
  ;; Ivy already offers some enhanced commands, but Counsel offers more and better.
  (use-package counsel
    :config
    (setq counsel-describe-function-function 'helpful-callable)
    (setq counsel-describe-variable-function 'helpful-variable)
    (counsel-mode 1)  ; This will remap the built-in Emacs functions that have counsel replacements.
  )

#+end_src

** swiper

#+begin_src emacs-lisp

  ;; Swiper is a package that is part of Ivy ecosystem.
  ;; Better isearch (incremental search), powered by Ivy.
  (use-package swiper
    :bind
    (("C-s" . swiper)
      :map evil-normal-state-map
        ("/" . swiper)
    )
  )

#+end_src

** ivy-rich

#+begin_src emacs-lisp

  ;; Show more info for some usages of Ivy. Also allows easier customization of Ivy output.
  (use-package ivy-rich
    :after (ivy counsel)
    :config
    ;; This is my custom function for how Ivy shows candidates when finding a file.
    ;; Unlike default function used by ivy(-rich), here I do some additional formatting:
    ;;  - I stylize dot(files/dirs).
    ;;  - I stylize executables.
    (defun my/ivy-read-file-transformer (filename)
      "Transform candidate STR when reading files."
      (let*
        ((current-dir (or (ivy-state-directory ivy-last) default-directory))
        (filepath (expand-file-name filename current-dir))
        (is-dir (ivy--dirname-p filename))
        (is-dotfile (string-prefix-p "." filename))
        (is-exec (file-executable-p filepath))
        )
        (cond
  	((and is-dir is-dotfile) (propertize filename 'face '(:inherit (font-lock-comment-face ivy-subdir))))
  	(is-dotfile (propertize filename 'face 'font-lock-comment-face))
  	(is-dir (propertize filename 'face 'ivy-subdir))
  	(is-exec (propertize filename 'face 'font-lock-keyword-face))
  	(t filename)
        )
      )
    )

    ;; With ivy-rich-set-columns, you can add new ones or replace existing columns when ivy is used in specific commands.
    ;; For details check out ivy-rich docs and docs of ivy-rich-display-transformers-list .
    (ivy-rich-set-columns
      'counsel-find-file  ; Set columns for this command (therefore when finding file).
      '((my/ivy-read-file-transformer)  ; Use my function instead of default ivy-read-file-transformer.
        (ivy-rich-counsel-find-file-truename (:face font-lock-doc-face))  ; This I kept the same. It adds target for links.
       )
    )

    (ivy-rich-mode 1)
  )

#+end_src

* Projectile

#+begin_src emacs-lisp
  
  ;; Projectile brings the concept of "Project" to emacs, as a project on the disk.
  (use-package projectile
    :init
    ;; First thing that happens on switching to a new project.
    ;; TODO: Try without this, see if I like that better or not, or if I would like something else.
    (setq projectile-switch-project-action #'projectile-dired)
    :bind-keymap
    ("C-c p" . projectile-command-map) ; TODO: Get this behind SPC.
    :custom
    ((projectile-completion-system 'ivy))
    :config
    (projectile-mode)
  )

  ;; Provides better integration of Projectile and Counsel.
  (use-package counsel-projectile
    :config
    (defun counsel-projectile-rg-region-or-symbol ()
      "Search for selected region if active, otherwise search for symbol at point using `counsel-projectile-rg`."
      (interactive)
      (let ((counsel-projectile-rg-initial-input (projectile-symbol-or-selection-at-point)))
          (counsel-projectile-rg)
      )
    )

    (counsel-projectile-mode)
  )

#+end_src

** Cheatsheet :cheatsheet:
- Projectile recognizes projects with its heuristics (.git/, maven files, ...), but you can add .projectile file to the project root to explicitly mark it as a project.

* VC (Version Control)

#+begin_src emacs-lisp

  (my/leader-keys
    "g" '("git (version control)" . (keymap))
  )

#+end_src

** Magit

#+begin_src emacs-lisp

  ;; NOTE: I installed transient not because I use it directly, but because magit
  ;;   needs a newer version of it than what comes with emacs by default, and this
  ;;   takes care of it. If magit at some point stops needing it, I can remove this.
  (use-package transient)

  ;; Magit is all you need to work with git.
  ;; TODO: I had to explicitly install new transient above to get magit to work because
  ;;   it expects a newer version than what emacs ships with. Once I update emacs
  ;;   or magit, drop the :after transient and remove (use-package transient) unless
  ;;   I also use it for something else.
  (use-package magit
    :after transient
    :defer t
  )
  ;; I define this outside of (use-package magit) because later is deferred.
  (my/leader-keys
    "gg" 'magit
  )

#+end_src

** Highlight lines
=diff-hl= package highlights lines that were modified (compared to versioned state of the file).
It adds indicator to the left margin/side of the window.

#+begin_src emacs-lisp

  (use-package diff-hl
    :config
    (global-diff-hl-mode)
    (my/leader-keys
      "gn" '("next change" . diff-hl-next-hunk)
      "gp" '("previous change" . diff-hl-previous-hunk)
    )
  )

#+end_src
* Company

#+begin_src emacs-lisp

  ;; TODO: Fix highlight and search faces in tooltip/popup, or have theme that makes them nice. Company has faces that we can customize.
  ;; TODO: Either make scroll more visible, or use lines instead.
  (use-package company
    :custom
    (company-idle-delay 0.2)
    (company-minimum-prefix-length 1)
    (company-selection-wrap-around t)
    (company-format-margin-function 'company-text-icons-margin)
    (company-text-face-extra-attributes '(:weight semi-light :slant italic))
    ;; I found default icons (be it vscode or text) to be too hard to understand,
    ;; so I made my own mapping here that provides more info. For the context, icons are
    ;; short descriptions left of the completion candidates in the popup.
    (company-text-icons-mapping
    '((array          "   []" font-lock-type-face)
      (boolean        " bool" font-lock-builtin-face)
      (class          "class" font-lock-type-face)
      (color          "color" success)
      (constant       "const" font-lock-constant-face)
      (constructor    "cnstr" font-lock-function-name-face)
      (enum-member    "enumv" font-lock-builtin-face)
      (enum           " enum" font-lock-builtin-face)
      (field          "field" font-lock-variable-name-face)
      (file           " file" font-lock-string-face)
      (folder         "  dir" font-lock-doc-face)
      (interface      " intf" font-lock-type-face)
      (keyword        "  kwd" font-lock-keyword-face)
      (method         " mthd" font-lock-function-name-face)
      (function       " func" font-lock-function-name-face)
      (module         "  mdl" font-lock-type-face)
      (numeric        "  num" font-lock-builtin-face)
      (operator       "   op" font-lock-comment-delimiter-face)
      (property       " prop" font-lock-variable-name-face)
      (reference      "  ref" font-lock-doc-face)
      (snippet        " snip" font-lock-string-face)
      (string         "  str" font-lock-string-face)
      (struct         "strct" font-lock-variable-name-face)
      (text           " text" shadow)
      (type-parameter "typep" font-lock-type-face)
      (unit           " unit" shadow)
      (value          "  val" font-lock-builtin-face)
      (variable       "  var" font-lock-variable-name-face)
      (t              "    ." shadow))
    )
    :config
    (global-company-mode 1)
  )

#+end_src

** TODO Find a way to also show additional docs next to each item. E.g. company-box
But company-box currently overrides my setting for company-text-icons-mapping with its icons and is for some reason slow.

** Cheatsheet :cheatsheet:
- C-s to search among the candidates. C-M-s to not just highlight but also filter. C-g to quit search mode.
  
* Terminal (shell)

There are different ways to use terminal / shell in Emacs. There are implementations that are completely done in elisp, there are implementations that support all that normal terminal does, and then there are does that don't support ncurses / TUI or all ansi codes.

I chose ~vterm~ because it uses external ~libvterm~ implementation of a terminal in C, which means it is fast, stable, and supports everything that a terminal should. It is also very popular and well supported.

#+begin_src emacs-lisp

  ;; Requires some stuff like cmake, support for modules in emacs, libtool-bin, but most systems /
  ;; emacses have all those ready, so usually you don't have to think about it.
  (use-package vterm)

  ;; Allows easy toggling of terminal(vterm) window.
  (use-package vterm-toggle
    :config
    (my/leader-keys
      "'" '("toggle terminal" . vterm-toggle)
    )
    ;; If I press C-return after toggling to terminal window, it will insert `cd` command that takes
    ;; me to dir of previous buffer! Very useful.
    (define-key vterm-mode-map [(control return)] #'vterm-toggle-insert-cd)
  )

#+end_src

** Shell-side configuration for vterm :manual_setup:

Some of the most useful vterm features require us to do a bit of configuration of the shell on our system. We can do without it, but we will be missing some of the functionality.
=vterm= brings that config, for our convenience, as one .sh file that we need to load in our .bashrc.
This can be done with the snippet below, by putting it into =.bashrc= (as per vterm docs).
It assumes vterm's =etc/= dir is next to where vterm is installed. This was true for me when installing it via Elpaca.

#+begin_src bash :tangle no

  if [[ "$INSIDE_EMACS" = 'vterm' ]] \
      && [[ -n ${EMACS_VTERM_PATH} ]] \
      && [[ -f ${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh ]]; then
          source ${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh
  fi

#+end_src

*** TODO Might be cool if I could tangle this code snippet directly into .bashrc, or a separate file that .bashrc will load. Then this would become real part of emacs config instead of a manual step.


** Cheatsheet :cheatsheet:
- After toggling to terminal window, press C-return to cd into parent dir of previous buffer.
- To execute commands like Ctrl-C or Ctrl-D, prefix them with `C-c`, so e.g. `C-c C-c` or `C-c C-d`.


** TODO Try "eat" terminal
* Spell checking
Flyspell is a builtin spell-checking frontend for Emacs, but there are also popular community packages, one of the lately most popular being Jinx, which I use here.

Main concept with all spell-checking frontends is that you have to install an actual spell-checker, that is not emacs-specific, on your system, and they use it as a backend. Most popular are Aspell and Hunspell, while Enchant is a wrapper on top of all these that does some extra smart stuff. Jinx uses Enchant.

** Jinx

Jinx uses Enchant program on your machine, which uses spelling backends like hunspell and/or aspell, which use their dictionaries for specific languages.

#+begin_src emacs-lisp

  (use-package jinx
    :config
    (setq jinx-languages "en_us")
    (my/leader-keys
      "tc"  '("spell checking" . jinx-mode)
    )
  )

#+end_src

*** Manual setup                                             :manual_setup:

On Arch, install ~enchant~ and ~pkgconf~.
Enchant needs to use some spelling backend, so also install e.g. ~hunspell~ (and make sure it is using it when I expect, file =/usr/share/enchant-2/enchant.ordering= on Arch defines that).
Finally, that backend needs dictionaries for the languages I want to spell-check, so e.g. if I want english, I should install ~hunspell-en_us~.
I can check backend and dictionaries that Enchant is picking up by running ~enchant-lsmod-2 -list-dicts~.

*** Cheatsheet :cheatsheet:

Run ~jinx-correct~ to correct the word at point.

* Syntax/error checking
** Flycheck

Flycheck is the central package for syntax checking, a "frontend" for code-related errors.
Given backend(s) (e.g. LSP, linter, ...) that supply errors (and warnings, info, ...), it collects errors from them and visualizes and manipulates them in a unified way.
It marks the affected piece of code visually (squigly lines), gives a way to move through the errors quickly, ... .
By default, it shows full error message(s) in the minibuffer when cursor is at the place of the error.

I currently configured it in the following way:
- I configure backends per language, but most often it is LSP.
- Instead of showing full error(s) in minibuffer when point/cursor is at the place of error, Flycheck shows short error message (1 line) via the sideline.
- If I want to see the full error message at point/cursor, I have a command (and keybinding) I can invoke to do so.

#+begin_src emacs-lisp

  (use-package flycheck
    :init (global-flycheck-mode)
    :custom
    (flycheck-display-errors-delay 0) ; Default value is 0.9.
    :config
    (my/leader-keys
      "en"  '("next" . flycheck-next-error)
      "ep"  '("previous" . flycheck-previous-error)
      "el"  '("list" . flycheck-list-errors)
    )
  )

#+end_src

#+begin_src emacs-lisp

  ;; Shows flycheck errors/warnings in a popup, instead of a minibuffer which is default.
  ;; I configured it so it doesn't show them on cursor, as is default, but on request.
  (use-package flycheck-posframe
    :after flycheck
    :custom
    (flycheck-posframe-border-width 10)
    (flycheck-posframe-prefix nil)
    ;; Don't show errors automatically on cursor, since below we define a manual way to invoke
    ;; showing of errors at point. I do it this way because I configured automatic showing of first
    ;; line of errors in the sideline, so I don't need to also see the whole error all the time,
    ;; instead I will rather invoke it manually when I want to see the whole of it.
    (flycheck-display-errors-function nil)
    :config
    (set-face-attribute 'flycheck-posframe-warning-face nil :inherit 'warning)
    (set-face-attribute 'flycheck-posframe-error-face nil :inherit 'error)
    ;; TODO: Make the posframe(popup) visually nicer.

    (defun my/show-flycheck-errors-posframe-at-point ()
      (interactive)
      (let* ((errs (flycheck-overlay-errors-at (point))))
        (flycheck-posframe-show-posframe errs)
      )
    )
    (my/leader-keys
      "ee" '("(un)expand" . my/show-flycheck-errors-posframe-at-point)
    )
  )

#+end_src

*** Show errors inline                                              :inactive:

While I got this to work quite nicely, I found that code inline can be pretty confusing, as it keeps popping in and out and moving the code you are reading, even when you don't care about the error at that moment.
Showing just one line by default helped, but I still didn't like it, and ended up going instead for the sideline for 1 line and then posframe for the full error.

#+begin_src emacs-lisp :tangle no

  ;; Shows flycheck errors/warnings inline (in code, below the cursor), instead of a minibuffer which is default.
  (use-package flycheck-inline
    :after (quick-peek)
    :hook (flycheck-mode . flycheck-inline-mode)
    :config

    ;;; Below I configure stuff quite heavily!
    ;;; We display only first line for each error + define a command for (un)expanding errors under the cursor/point.
    ;;; We use quick-peek for nice borders around the overlay.

    (defvar my/expanded-flycheck-errors nil
      "List of flycheck errors that are to be shown with a full message.")

    (defun my/toggle-flycheck-errors-expansion-at-point ()
      "Adds flycheck errors at point to the list of expanded errors if not already expanded.
       If already in the list, it removes them from the list."
      (interactive)
      (let* ((errs (flycheck-overlay-errors-at (point))))
        (setq my/expanded-flycheck-errors (if (cl-intersection errs my/expanded-flycheck-errors) nil errs))
      )
    )
    (my/leader-keys
      "ee" '("(un)expand" . my/toggle-flycheck-errors-expansion-at-point)
    )

    (defun my/shorten-flycheck-error-message (msg)
      "Shorten the error message MSG to the first line, adding ellipsis if so."
      (let ((lines (split-string msg "\n")))
        (if (> (length lines) 1)
            (concat (car lines) (propertize " …" 'face 'bold))
          (car lines)
        )
      )
    )

    ;; Use quick-peek to show errors in a nicer way (with bars).
    ;; If error is in the my/expanded-flycheck-errors list, I show its full message,
    ;; if not, I show shortened version of it.
    (setq flycheck-inline-display-function (lambda (msg pos err)
  					   (let* ((ov (quick-peek-overlay-ensure-at pos))
  						  (contents (quick-peek-overlay-contents ov))
                                                    (show-full-msg (member err my/expanded-flycheck-errors))
  						 )
  					     (setf (quick-peek-overlay-contents ov)
  						   (concat contents
  							   (when contents "\n")
  							   (if show-full-msg msg (my/shorten-flycheck-error-message msg)))
  					     )
  					     (quick-peek-update ov)
                                             )
  					 )
  	flycheck-inline-clear-function 'quick-peek-hide
    )
  )

#+end_src

** Flymake                                                          :inactive:

Im not using it for now since I managed to set up Flycheck quite well, but I might want to try it out in the future again.

#+begin_src emacs-lisp :tangle no

  (use-package flymake
    :ensure nil ; It already comes with emacs, so we tell elpaca not to install it.
    :hook (prog-mode . flymake-mode)
    :custom
    (flymake-no-changes-timeout 0.2)
    :config
    (my/leader-keys
      "en"  '("next" . flymake-goto-next-error)
      "ep"  '("previous" . flymake-goto-prev-error)
      "el"  '("list (buffer)" . flymake-show-buffer-diagnostics)
      "eL"  '("list (project)" . flymake-show-project-diagnostics)
    )
  )

  (use-package flymake-posframe
    :ensure (:host github :repo "Ladicle/flymake-posframe")
    :hook (flymake-mode . flymake-posframe-mode)
  )

#+end_src

* Sideline

=sideline= package shows information (e.g. errors) inline with the code, but on the right (or left) edge of the screen.
It shows that infomation in a smart way, to minimally disrupt the existing code.

You can plug in multiple backends into it, and it will display the information uniformly.

#+begin_src emacs-lisp

  (use-package sideline
    :hook ((flycheck-mode lsp-mode) . sideline-mode)
    :init
    ;; `up` means it is shown above the line where cursor is, `down` means beneath it.
    (setq sideline-backends-right '((sideline-flycheck . up)
  				  (sideline-lsp . down)))
  )

  (use-package sideline-flycheck 
    :hook (flycheck-mode . sideline-flycheck-setup)
    :custom
    ;; I want to show only short version of errors, otherwise it becomes a mess.
    ;; If I need to see the full error, I have other methods to do that (e.g. flycheck-posframe).
    (sideline-flycheck-max-lines 1)
    :config
    (set-face-attribute 'sideline-flycheck-error nil
  		      :slant 'italic
  		      :background "black")
    (set-face-attribute 'sideline-flycheck-warning nil
  		      :weight 'light
  		      :slant 'italic
  		      :background "black")
    (set-face-attribute 'sideline-flycheck-success nil
  		      :weight 'light
  		      :slant 'italic
  		      :background "black")
    ;; TODO: Somehow define following prefixes ✖ ⓘ ⚠ for errors / warning / success?
  )

  ;; From LSP directly, I show only code actions in the sideline.
  ;; The rest of the information I show in other way (via flycheck, via minibuffer, popups, ...).
  ;; Note that flycheck again sends some of that information to sideline though.
  (use-package sideline-lsp
    :custom
    ;; By setting this to nil, lsp diagnostics (errors, warnings) get sent to flycheck, which we prefer since
    ;; it is a more standard / specific way to do it.
    (sideline-lsp-show-diagnostics nil)
    (sideline-lsp-show-hover nil) ; This I already show in minibuffer (eldoc) or in popup (lsp-ui-doc).
    (sideline-lsp-show-symbol nil) ; This I didn't find useful.
    (sideline-lsp-show-code-actions t) ; But I do find it useful to see code actions.
    (sideline-lsp-code-actions-prefix "✎ ")
    (sideline-lsp-actions-kind-regex "quickfix.*") ; Show only quickfix code actions, otherwise it is too much noise.
    :config
    (set-face-attribute 'sideline-lsp-code-action nil
                        :inherit 'shadow
                        :weight 'light
  		      :slant 'italic
  		      :background "black")
  )

#+end_src

* Development
** LSP
LSP (Language Server Protocol) enables editors to use language servers (that usually come with the language itself) to answer all kinds of questions about the code in that language, with full semantic understanding of the project.

LSP as a general protocol has some of its own nomenclature. Some of it that is useful to know to better understand the config below, is how they name the most important information that LS returns.
 - =hover= info: Documentation about the symbol/function/thing under the cursor that LS sends.
 - =diagnostics=: Errors, warnings, info, that LS reports.
 - =code actions=: actions that LS suggests and that you can then ask it to execute. E.g. add missing import.

Rough summary how my configuration currently displays all this info:
 - Parts of code with diagnostics are marked with **squiggly lines** (by Fly(check/make)).
 - **Short version of hover** info for a symbol is shown on cursor/mouse, in the minibuffer (by ~eldoc~).
 - **Full version of hover** info for a symbol under cursor is displayed in a popup, on demand, which I trigger with "K" or "?" (by ~lsp-ui-doc~).
 - Short info / **diagnostics** for thing/error under the cursor is shown on the right side of the screen, next to the code (sideline), including errors (just one line), warnings and **code actions**.
 - Full info for thing/eror under the cursor is shown by ~fly(check/make)~, in a popup, on request.

One functionality that LSP also defines are =semantic tokens=, where LS returns semantic information about specific tokens, which is then usually used by the editor for very detailed and smart syntax highlighting.
It is important to notice here that it doesn't return this information for every single token in the code, but only for specific types of tokens, meaning it can't be used to fully highlight the code. Instead, it is intended to be used as an additional, detailed syntax highlighting that is applied on top of some other, more basic syntax highlighting (i.e. usually implemented via regexes, textmate grammar, or recently treesitter). Additionally, LSP semantic token syntax highlighting is usually slower and less robust to syntax errors than other more basic methods, but those are secondary reasons.
Therefore, for optimal experience, we should customize the faces used for semantic tokens to be aligned with the faces used for basic highlighting, per language if needed.
**NOTE**: For stacking of syntax highlights to happen correctly, it is important that basic syntax highlighting (e.g. treesitter) is applied first, and then lsp semantic token syntax highlighting after it.

#+begin_src emacs-lisp

  (use-package lsp-mode
    :init
    (setq lsp-keymap-prefix "C-c l") ;; TODO: Set it to ",". I tried but it didn't work, I guess evil overrides it.
    (setq lsp-use-plists t) ; Recommended performance optimization. Requires setting env var (check early-init.el block below).
    :hook (lsp-mode . lsp-enable-which-key-integration)
    :commands (lsp lsp-deferred)
    :custom
    ;; lsp-modeline is about showing "stats" in the modeline: number of errors, warnings, code actions.
    ;; Useful for languages where compilation might be broken due to errors in other files (e.g. Java, Haskell).
    (lsp-modeline-diagnostics-enable t) ; Show info about diagnostics (errors, warnings, ...) in the modeline.
    (lsp-modeline-diagnostics-scope :workspace) ; Whole project and not just this file.
    (lsp-modeline-code-actions-enable t) ; Show info about code actions in the modeline.

    ;; eldoc is the most "native" way for emacs to display docs for a thing under cursor.
    ;; It displays information about the thing under cursor/mouse in the minibuffer.
    ;; Here we tell lsp-mode to use eldoc to display "hover" lsp info (which is docs for function/symbol).
    (lsp-eldoc-enable-hover t)
    ;; Don't show all the info in minibuffer on hover, instead show only most basic info (what it is, type).
    ;; Otherwise, there is too much noise and jumping of minibuffer up and down.
    ;; If I want full docs for a thing under cursor, I will rather summon it manually: I use lsp-ui-docs-toggle for that and have bound it to "?" -> check lsp ui config for details.
    (lsp-eldoc-render-all nil)

    ;; At the top of the file, show info about the position of the cursor (path, module, symbol, ...).
    (lsp-headerline-breadcrumb-enable t)
    (lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))

    (lsp-semantic-tokens-enable t) ; Richer highlighting (e.g. differentiates function symbol from var symbol).
  )

#+end_src

#+begin_src emacs-lisp :tangle ./early-init.el

  (setenv "LSP_USE_PLISTS" "true") ; Recommended performance optimization.

#+end_src

*** LSP UI

Official extension for lsp-mode that brings the nice UI features, mostly for displaying info returned by LS.
It is common to use it next to lsp-mode.
It can show information in two main ways: via ~lsp-ui-doc~ popup, or inline via ~lsp-ui-sideline~.

#+begin_src emacs-lisp

  (use-package lsp-ui
    :after (lsp-mode evil)
    :commands lsp-ui-mode
    :custom
    ;; Show "hover" documentation for a thing under cursor/pointer in a popup.
    (lsp-ui-doc-enable t)
    ;; I don't want it to popup constantly as I move around, instead I want to summon it when I need it.
    ;; That is why below I define "?" as a key for toggling it.
    (lsp-ui-doc-show-with-cursor nil)
    ;; If I hover with a mouse, then do show the docs, that is not too intrusive.
    (lsp-ui-doc-show-with-mouse t)
    ;; Show the docs next to the cursor/point.
    (lsp-ui-doc-position 'at-point)
    (lsp-ui-doc-include-signature t)
    (lsp-ui-doc-max-height 30)

    ;; lsp-ui-sideline shows info that you want (e.g. diagnostics, code actions, ...)  on the right
    ;; side of the window, inline with the code.  We set it to nil here though, because we control
    ;; it from another package, sideline + sideline-lsp.
    (lsp-ui-sideline-enable nil)
    :config
    (general-define-key :states '(normal visual)
                        :keymaps 'lsp-mode-map
                        "?" 'lsp-ui-doc-glance ; TODO: This is sometimes being overshadowed with ? from evil mode, fix that.
                        "F" 'lsp-ui-doc-focus-frame
    ) 
    (setq evil-lookup-func 'lsp-ui-doc-glance)
  )

#+end_src

*** Misc

#+begin_src emacs-lisp

  ;; Brings lsp-ivy-workspace-symbol that searches for a symbol in project as you type its name.
  ;; TODO: Add a keybinding, under lsp-keymap-prefix, for this command, I guess under goto? So ", g s"?
  (use-package lsp-ivy :commands lsp-ivy-workspace-symbol)

  ;; Shows list of all errors in a nice treemacs fashion.
  (use-package lsp-treemacs :commands lsp-treemacs-errors-list)

#+end_src

*** TODO Use lsp-booster
- https://www.ovistoica.com/blog/2024-7-05-modern-emacs-typescript-web-tsx-config#orgf6d33f7 -> search for lsp-booster
*** TODO LSP's completion-at-point -> how to get that working with Company properly?
- https://emacs-lsp.github.io/lsp-mode/page/settings/completion/ -> useful?
** Treesitter
Treesitter is for syntax understanding of the code what LSP is for semantic understanding of the code.
Same like LSP, Treesitter removes the burden from the specific editor to implement all the logic related to dealing with syntax, and instead any editor can just leverage the one central implementation of it: Treesitter + corresponding treesitter grammar for specific language. In return, you get very good syntax highlighting, cleverer editing and movement through code, better indentation, ... -> anything that can be built with konwledge of concrete syntax tree.

Emacs 29 brings its own built-in treesitter package (~treesit~).
The only thing we need to configure is to tell it which grammars to pull in for which language.
Now we have working treesitter for those languages! It is not used anywhere yet though.

Easiest way to start using treesitter is to use one of the built-in major language modes that come with Emacs 29, that are made around using treesitter (they mostly use it for syntax highlighting): typescript-ts-mode, markdown-ts-mode, ... . We can easily check which exist by doing ~apropos~ and then ~-ts-mode$~. There are also third party major modes made with treesitter in mind (e.g. ~haskell-ts-mode~) that we can use, and additionaly, some older packages have added support for treesitter so we can toggle it there.
It't not all about syntax highligthing though, there is for example cool ~combobulate~ package that brings structural editing for multiple languages, based on treesitter.

For more details, this article is a great tutorial on treesitter support in Emacs: https://www.masteringemacs.org/article/how-to-get-started-tree-sitter .

#+begin_src emacs-lisp

  (use-package treesit
    :ensure nil ; Because it is built-in package, this tells elpaca to not try to install it.
    :preface
    (defun my/setup-install-grammars ()
      "Install Tree-sitter grammars if they are absent."
      (interactive)
      (dolist (grammar
               ;; Note the version numbers. These are the versions that with Emacs 29.
               ;; I picked those up from https://github.com/mickeynp/combobulate .
               '((css . ("https://github.com/tree-sitter/tree-sitter-css" "v0.20.0"))
                 (go . ("https://github.com/tree-sitter/tree-sitter-go" "v0.20.0"))
                 (html . ("https://github.com/tree-sitter/tree-sitter-html" "v0.20.1"))
                 (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript" "v0.20.1" "src"))
                 (json . ("https://github.com/tree-sitter/tree-sitter-json" "v0.20.2"))
                 (markdown . ("https://github.com/ikatyang/tree-sitter-markdown" "v0.7.1"))
                 (python . ("https://github.com/tree-sitter/tree-sitter-python" "v0.20.4"))
                 (rust . ("https://github.com/tree-sitter/tree-sitter-rust" "v0.21.2"))
                 (toml . ("https://github.com/tree-sitter/tree-sitter-toml" "v0.5.1"))
                 (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "tsx/src"))
                 (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "typescript/src"))
                 (yaml . ("https://github.com/ikatyang/tree-sitter-yaml" "v0.5.0"))
                 (haskell . ("https://github.com/tree-sitter/tree-sitter-haskell"))
  	     ))
        (add-to-list 'treesit-language-source-alist grammar)
        ;; Only install `grammar' if we don't already have it installed.
        ;; However, if we update a grammar version above then this won't update it since it is already installed,
        ;; I should instead run `treesit-install-language-grammar' manually for it.
        (unless (treesit-language-available-p (car grammar))
          (treesit-install-language-grammar (car grammar))))
    )
    :config
    (customize-set-variable 'treesit-font-lock-level 4) ; Use maximum details when doing syntax highlihting.
    (my/setup-install-grammars)
  )

#+end_src

*** Cheatsheet :cheatsheet:
- Cool commands are ~treesit-explore-mode~ and ~treesit-inspect-mode~: they allow inspecting the concrete syntax tree in a buffer!

** Haskell

#+begin_src emacs-lisp
  (defun my/lsp-haskell-local-face-setup ()
    ;; semhl stands for "semantic highlight" -> faces with "semhl" are faces for lsp semantic tokens.
    ;; By default, lsp-face-semhl-operator just inherits lsp-face-semhl-function, which I found to be a shame.
    ;; By setting them to keyword face, operators are nicely visible.
    (face-remap-add-relative 'lsp-face-semhl-operator '(:foregrund unspecified :inherit lsp-face-semhl-keyword))
    ;; I don't want to differentiate class methods from functions by color, that is just confusing.
    (face-remap-add-relative 'lsp-face-semhl-method '(:foreground unspecified :inherit lsp-face-semhl-function))
    ;; haskell-operator-face is used for stuff like `::`, `->` and similar. By default they were the same as
    ;; variables, I didn't like that so I made them same as other operators, which is keyword face.
    (face-remap-add-relative 'haskell-operator-face '(:foreground unspecified :inherit font-lock-keyword-face))
    ;; By default haskell keywords (import, where, ...) already are set to font-lock-keyword-face,
    ;; I just added :weight semi-bold to make them stand out a bit.
    (face-remap-add-relative 'haskell-keyword-face '(:weight semi-bold :inherit font-lock-keyword-face))
  )

  (defun my/haskell-mode-setup ()
    (lsp-deferred)
    (ormolu-format-on-save-mode)
    (face-remap-add-relative 'font-lock-operator-face '(:foreground unspecified :inherit font-lock-keyword-face))
    (add-hook 'lsp-after-open-hook 'my/lsp-haskell-local-face-setup nil t)
  )

  ;; NOTE: Requires ormolu to be installed on the machine.
  (use-package ormolu)

  (use-package haskell-mode
    :hook
    (haskell-mode . my/haskell-mode-setup)
    (haskell-literate-mode . my/haskell-mode-setup)
    :custom
    (haskell-indentation-layout-offset 4)
    (haskell-indentation-starter-offset 4)
    (haskell-indentation-left-offset 4)
    (haskell-indentation-where-pre-offset 2)
    (haskell-indentation-where-post-offset 2)
  )

  ;; ;; TODO: Some current problems:
  ;; ;;  - Doesn't highlight as much stuff as I would like it to (https://codeberg.org/pranshu/haskell-ts-mode/issues/7).
  ;; ;;    - actually it does apply font-lock-operator-face but I guess it is just white -> make that one interesting, e.g. use keyword face.
  ;; ;;    - I used treesit-explore-mode and it is great, I can see exactly how it understand the code, and it knows so much! So it does know a ton about the code, but we are not using it! WHy is that so? Beacause haskell-ts-mode is just not applying font lock faces to all these tokens, it seems so. It really should! Can I customize that myself, or do I need to make a PR on the haskell-ts-mode package?
  ;; ;;  - Is too smart while highlighting signature.
  ;; ;;  - Can't get it to be default mode becuase haskell-mode still gets pulled in with lsp-haskell.
  ;; ;;    I need to either make sure it doesn't get pulled in, or remove it from loading for .hs files.
  ;; ;;  - What is with literate mode?
  ;; (use-package haskell-ts-mode
  ;;   :load-path "~/git/haskell-ts-mode" ; NOTE: This is for using my local fork of the package, for dev purposes. Remove this line to use public version of the package.
  ;;   :mode (("\\.hs\\'" . haskell-ts-mode))
  ;;   :hook
  ;;   (haskell-ts-mode . my/haskell-mode-setup)
  ;;   ;;(haskell-literate-mode . my/haskell-mode-setup) ; What about literate mode?
  ;;   :config
  ;;   (setq haskell-ts-highlight-signature nil)
  ;;   (setq haskell-ts-font-lock-level 4) ; Maximum syntax highlighting.
  ;; )

  ;; Teaches lsp-mode how to find and launch HLS (Haskell Language Server).
  (use-package lsp-haskell
    :custom
    ;; This takes syntax highlighting to the maximum of detail. It is a bit slow though!
    (lsp-haskell-plugin-semantic-tokens-global-on t)
  )


#+end_src

*** Cheatsheet :cheatsheet:
- haskell-mode brings interactive mode where you get a ghci session in which you can easily load specific files and run stuff from them. To start it, run `interactive-haskell-mode`. File is added to it by ~haskell-process-load-file~ while in a Haskell file buffer.
- Haskell mode registers its keymap under "C-c", so check that for common commands.


*** TODO Try using haskell-ts-mode instead of haskell-mode
haskell-mode doesn't know how to use treesitter, and haskell-ts-mode, which is a new mode that somebody made that should replace haskell-mode but with ts support, has much less features than haskell-mode and is less mature. But maybe that is ok and worth trying? Do I use any of advanced haskell-mode features anyway? I don't think so.
  - https://codeberg.org/pranshu/haskell-ts-mode

** TypeScript
NOTE: I chose ts-ls as a language server, when asked.

#+begin_src emacs-lisp

  ;; This is a built-in package that brings major mode(s) that use treesitter for highlighting.
  ;; It defines typescript-ts-mode and tsx-ts-mode.
  (use-package typescript-ts-mode
    :ensure nil ; This is built-in package, so we don't want elpaca to try to install it.
    :mode (("\\.js\\'"  . typescript-ts-mode)
  	 ("\\.ts\\'"  . typescript-ts-mode)
  	 ("\\.mjs\\'" . typescript-ts-mode)
  	 ("\\.mts\\'" . typescript-ts-mode)
  	 ("\\.cjs\\'" . typescript-ts-mode)
           ("\\.tsx\\'" . tsx-ts-mode)
  	 ("\\.jsx\\'" . tsx-ts-mode)
          )
    :hook (((typescript-ts-mode tsx-ts-mode) . lsp-deferred))
  )

#+end_src

*** TODO Customize LSP semantic token faces to be aligned with treesitter highlighting.
*** TODO Follow the rest of the article
- https://www.ovistoica.com/blog/2024-7-05-modern-emacs-typescript-web-tsx-config
- I already did the most from it, but there is a bit more I think? I should check it.
  
** TODO Web (HTML, CSS, ...)
  - Check what they do in Spacemacs/Doomemacs.
- web-mode.el -> I probably want to use this for HTML / CSS.
- Doom emacs:
  - https://github.com/doomemacs/doomemacs/tree/master/modules/lang/web
    - web-mode, company-web, counsel-css, emmet-mode, haml-mode, less-css-mode, pug-mode, sass-mode, slim-mode, stylus-mode, sws-mode
    - lsp and treesitter
- Spacemacs:
  - web-mode, emmet-mode for generating HTML / CSS coding, impatient-mode, counsel-css, web-beautify.

- Sounds to me, all together, like web-mode is essential, while emmet-mode and impatient-mode might be interesting. Also company-web and counsel-css.
* AI
** Overview of popular packages
Last updated: <2024-12-23 Mon> 

Quick summary:
For now I will go with gpt.el (for general usage), copilot.el (for completion) and copilot-chat.el (for general usage). gpt.el and copilot-chat.el are overlapping in what they can do, so I have to figure out which I like better. gpt.el however can use any model, while copilot-chat has to use copilot, but is free for me.
Out of higher-level models, I think Ellama and aider.el might be worth trying out for me. Elisa is also interesting, although it might be better if I just set up PrivateGPT and use it with gpt.el.
I might also want to try out chatgpt-shell at some point, it is similar to gptel uses different approach.

*** High level
- [[https://github.com/s-kostyaev/ellama][Ellama]]
  Has cmds to ask llm to summarize, translate, complete, code review, use CoT, ... . A lot of very specific commands for specific tasks.
  Seems to me like I can do most of this with gpt.el directly with just a bit more work, so I will skip trying out Ellama for now, and maybe try it once I feel that I want more from gpt.el and Ellama offers it.
- [[https://github.com/tninja/aider.el][aider.el]]
  Makes it easy to use Aider from emacs, for the current project, and send it buffers and similar.
  Has nice transient menu.
  Certainly worth trying if using Aider.
- [[https://github.com/daedsidog/evedel][Evedel]]
  Uses gpt.el as a backend and needs it installed.
  Introduces unique workflow for working with LLM where you add instructions(directives) and references in the text/code in your buffer and that is sent to the LLM in order to modify it.
  Sounds powerful, but for now I don't need that level of control over how LLM refactors piece of my code.
- [[https://github.com/s-kostyaev/elisa][Elisa]]
  Implementation of RAG to be used in your emacs.
  Combines local files/dirs, Emacs info manuals, and web search -> all these are added to "collection(s)".
  And then you can ask questions about it.
  Sounds awesome for working on specific projects with specific knowledge, but is a bit limited in the way that it can do only chatting. Probably it is better for me to sure PrivateGPT then, as a backend for gpt.el.
- [[https://github.com/lanceberge/elysium][elysium]]
  Uses gpt.el as backend and needs it installed.
  Narrow-focused: given the query, it applies changes directly to the selected code. But I believe gpt.el can also do that?
*** Mid-level
- [[https://github.com/karthink/gptel][gptel]]
  Allows for chatting with llm of choice anywhere in Emacs, with a lot of care about DX and being inobtrusive.
  Quite flexible, allows a lot of customization on the fly with nice transient menu.
  Also has commands for stuff like rewriting a piece of code, adding buffers to the context, ... .
  Has support for multi-modal: specifically images.
  Most popular emacs LLM package at the moment.
- [[https://github.com/copilot-emacs/copilot.el][copilot.el]]
  Brings copilot completion to Emacs.
- [[https://github.com/chep/copilot-chat.el][copilot-chat.el]]
  Brings copilot-chat capabilities to Emacs. Similar to gptel in what it can do, but only for copilot as a backend.
- [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]]
  Similar to gptel, but as a comint shell, which is a kind of specific emacs's mechanism for prompts / convos.
*** Low-level
- [[https://github.com/ahyatt/llm][llm]]

** GPTel

#+begin_src emacs-lisp

  (use-package gptel
    :config
    (setq gptel-prompt-prefix-alist '((markdown-mode . "## You:\n")
                                      (org-mode . "** You:\n")
                                      (text-mode . "## You:\n")))
    (setq gptel-response-prefix-alist '((markdown-mode . "## AI:\n")
                                        (org-mode . "** AI:\n")
                                        (text-mode . "## AI:\n")))
    (setq gptel-default-mode 'org-mode)
    (add-hook 'gptel-post-response-functions 'gptel-end-of-response) ; On response, move cursor to the next prompt.
  )

#+end_src

*** Setting up the OpenAI API key :manual_setup:
By default, it pulls in the API key for OpenAI from the ~/.authinfo file (check the gptel docs for details), so that is what I use to provide the OpenAI API key.
*** Cheatsheet :cheatsheet:
- =C-c ENT= is for sending the query to AI when in the Gptel buffer.
*** TODO Set up and try
Doesn't work at the moment, I haven't set up OpenAI API key it seems.
Although I think I have one in the ENV, that is not enough?
**** TODO Install markdown-mode, it is useful?
** TODOs
*** TODO Learn/configure gptel
- Ok, so I get that I can do a lot of on-the-fly configuring via its transient menu, including where input comes from and where it goes, but the whole things feels a bit overly clunky / manual.
  I should try to learn more about it to see if I can use it better, and also spend some time trying it out, but maybe it is just too low level for me, and I should instead use something higher level.
  Or just use copilot-chat. Hm.
- There might be a nice way to color the responses, this is what I found suggested by the author of the package, give it a try:
  #+begin_src emacs-lisp :tangle no
    (defun gptel--color-response ()
      (let ((prop))
        (save-excursion
          (setq prop (text-property-search-forward 'gptel 'response t))
          (put-text-property (prop-match-beginning prop)
                            (prop-match-end prop)
                            'font-lock-face
                            'warning))))

    (add-hook 'gptel-post-response-hook #'gptel--color-response t)
  #+end_src
- I am struggling with using "rewrite" functionality, I should figure out how to use that.
- Here is a bit more on effectively using gptel: https://www.reddit.com/r/emacs/s/O7Kh4Z9uNV .
- I should ask on github for help if I get stuck. Or maybe on reddit. Also it might be worth actually trying out something like Elysium hm.
*** TODO Lean how to use Aider
- A bit about using Aider in Emacs, and other stuff, to get closer to Cursor experience: https://www.reddit.com/r/emacs/comments/1ikdb5c/how_is_cursor_ai_better_than_emacs/?share_id=-3XEqsEXmq65_vdCzFM6H&utm_content=1&utm_medium=android_app&utm_name=androidcss&utm_source=share&utm_term=10
- There is aider.el, I might want to look into that one, or I can just use Aider directly form the terminal. https://github.com/tninja/aider.el
*** TODO Set up copilot.el
*** TODO Set up and try copilot-chat.el. See how I like it vs gpt.el
* Misc

#+begin_src emacs-lisp

  ;; Primarily supposed to be used with visual-line-mode (which is emacs builtin that soft wraps the line at window end).
  ;; visual-fill-column, when used with visual-line-mode, modifies the wrapping to happen at the fixed (by default fill-column) width,
  ;; instead of at the window end.
  ;; It can also center the text.
  ;; Useful for making the buffer look "document" like.
  (use-package visual-fill-column)

#+end_src

#+begin_src emacs-lisp

  ;; This makes copy/paste properly work when emacs is running via the terminal.
  (use-package xclip
    :config
    (xclip-mode 1)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Allows fast jumping inside the buffer (to word, to line, ...).
  (use-package avy)

#+end_src

#+begin_src emacs-lisp

  ;; Allows jumping to any window by typing just a single letter.
  (use-package ace-window)

#+end_src

#+begin_src emacs-lisp

  ;; This package gives me commands to jump to a window with specific number (ace-window doesn't do that).
  (use-package winum
    :config
    (winum-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Remembers last used commands and puts them on top of M-x's list of commands.
  ;; Integrates seamlessly with Ivy/Counsel, Ido and some other.
  (use-package amx)

#+end_src

#+begin_src emacs-lisp

  ;; Highlight TODO and similar keywords in comments and strings.
  (use-package hl-todo
    :config
    (global-hl-todo-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Utility package that provides nice icons to be used in emacs, by other packages.
  ;; NOTE: The first time you load your config on a new machine, you'll have to
  ;; run the following command interactively:
  ;; M-x all-the-icons-install-fonts
  (use-package all-the-icons)

#+end_src

#+begin_src emacs-lisp

  ;; Enhances built-in Emacs help with more information: A "better" Emacs *Help* buffer.
  (use-package helpful
    :defer t
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    (([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key)
    ("C-h h" . helpful-at-point)
    )
  )

#+end_src

#+begin_src emacs-lisp

  ;; Colorizes color names in buffers.
  ;; Works better than clasical rainbow-mode, which would mess up Help buffer for me.
  (use-package colorful-mode
    :config
    (add-to-list 'global-colorful-modes 'help-mode)
    (global-colorful-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; It colors each pair of parenthesses into their own color.
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Brings functions for converting buffer text and decorations to html.
  (use-package htmlize)

#+end_src

* Cheatsheet :cheatsheet:

- M-: -> eval in echo buffer

- check-parens -> find unbalanced parenthesses in the buffer

- C-h -> help! find out about v (variable), f (function), face, ... .
- C-h h -> help for symbola at point.

- m <char> -> set mark
- ` <char> -> go to mark
- ` ` -> go to last mark

- C-x TAB -> indent-rigidly: allows indenting region one by one space via transient menu

Troubleshooting:
- package couldn't be found (upon install) -> local packages archive is old, run `list-packages` to update it.

* TODOs
** A must
*** TODO Use emacs-lsp-booster with lsp-mode, to speed it up / avoid freezes.
*** TODO Write down following next to lsp-mode
I investigated lsp-mode vs eglot. Eglot natively comes with emacs and is alternative to lsp-mode. Claims to have better code and be faster, but lsp-mode seems to be bigger and more featureful, so it is really not clear at all which is better. I think I will be sticking to lsp-mode for now, people seemed to report more issues with eglot, and lsp-mode I know works well. I can try eglot at some point.

*** TODO Set up TypeScript (TS) support
*** TODO Set up Haskell support
** Should do
*** TODO Try org roam, what is it about?
*** TODO Take care of the temporary files being created by emacs and undo.
*** TODO Add whitespace mode (or smth like that)
*** TODO Figure out how to pin down package versions (lockfile / freezing).

Search a bit how others do package version pinning down. There is :pin for use-package, but I am nto sure if that is what I need.

*** TODO Add a nice splash screen

With recent projects and recent files and maybe an inspirational quote? Check out emacs-dashboard.

*** TODO I will want some way to easily restore where I stopped working.

Maybe some presets -> e.g. quick loading of waspc project with certain file opened. Or maybe just from where I stopped.

*** TODO Go through my spacemacs config and copy stuff I liked from there.
*** TODO Take care of TODOs in org-present config.
*** TODO Set up shell, below is my spacemacs setup:

;; Make it so that in shell (vterm) C-p acts as "up" and C-n acts as "down", same like in external terminals.
;; NOTE: For insert mode it already works like this, but I also wanted it to work the same way for the normal mode.
(with-eval-after-load 'vterm
  (evil-define-key 'normal vterm-mode-map (kbd "C-p") 'vterm-send-up)
  (evil-define-key 'normal vterm-mode-map (kbd "C-n") 'vterm-send-down)
)
(shell :variables
    shell-default-shell 'vterm ;; Fastest and best terminal emulator currently avaiable for emacs.
    shell-default-width 50
    shell-default-position 'right
    spacemacs-vterm-history-file-location "~/.bash_history"
    )

*** TODO Stop that custom block from appearing at the end of this file.
*** TODO Look into workgroups
*** TODO Smooth scrolling package
https://github.com/jdtsmith/ultra-scroll
*** DONE Implement transient yanking
So I can go through the kill ring, like in spacemacs. counsel-yank-pop might be useful? Or should I implement my own hydra?
There is counsel-yank-pop, to nicely choose from the kill ring.
So what I want is once yank is done, to be offered something like hydra, so transient keys, that allow to easily rotate to through kill ring.
In spacemacs, it activates Pasting Transient State, where [C-j/C-k] cycles through yanked text, [p/P] pastes the same text above or below, [C-v] creates a visual selection from last paste and exits. Anything else exits.
I really need only cycling.
Maybe I can just offer a hydra that has one key, maybe "/", that opens counsel-yank-pop. That way, "p/" becomes "advanced" yank. It could also offer C-j and C-k next to it.
Actually, this already works hm! C-p gives previous (evil-paste-pop), C-n gives next (evil-paste-pop-next), that is evil thing. But it is not hydra. So maybe just make a hydra that mentions these + a way to start counsel-yank-pop.
*** DONE Use native installation of emacs.
*** DONE Organize general.el, which-key, hydra, evil under Keybindings header.
*** DONE How to split use-package into multiple blocks, in Org babel blocks?
 - SO: including snippets: https://emacs.stackexchange.com/questions/78624/splitting-use-package-declarations-in-literate-config
 - System Crafters: they use =(with-eval-after-load 'some-package ...)= to do extra config stuff. This is most reasonable solution probably.

** Going beyond
*** TODO Set up RSS feeds following in emacs ([[https://www.reddit.com/r/emacs/s/bOnWC7cv44][reddit]])
*** TODO Read [[https://www.reddit.com/r/emacs/s/mnpkOjzbOT][Article with nice explanation of IDE packages (lsp, dap, ...)]]
*** TODO Check out Prot's basic [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/][emacs config]]
*** TODO Try using command pallete
Similar to what VSCode has, and Sublime Text made popular. Also similar to vim telescope.
So instead of showing everything down there in the minibuffer, show some stuff in the command pallete at the top / middle of the screen.
I am not sure if I will like this or not, but I think it is worth trying it out.
- ivy-posframe package -> just for ivy completions
- emacs-miniframe -> for anything happening in the minibuffer
*** TODO Try Nano theme.
- Some additional work by Rougier that is interesting: https://www.reddit.com/r/emacs/comments/1hoehaa/boxes_everywhere/?share_id=H0m8UzpeWYzXfvp6dOXXu&utm_content=1&utm_medium=android_app&utm_name=androidcss&utm_source=share&utm_term=10
*** TODO Enable that new smooth/pixel scroll setting in emacs?
*** TODO Use smartparens or electric-pair-mode?
*** TODO Take a look at dogears.el -> sounds potentially useful, not sure though.
*** TODO symbol-overlay, multiple-cursors, and their [[https://lmno.lol/alvaro/its-all-up-for-grabs-and-it-compounds][combo]].
*** TODO Make is so that init.el and early-init.el are read only by default?
I could, in org-mode-hook, check buffer-file-name, and if it is one of these two files,
make them read only by default.
*** TODO Check out how System Crafters organized their Emacs.org
*** TODO Learn some Org keybindings / tricks
- [ ] How can I easily hide / fold / show current header and its parents?
- [ ] How can I easily navigate through headers?
- [ ] How can I increase/decreaese level of whole hierarchy/region of headers?
      A: Seems like that is done with M-<left> or M-<right>
*** TODO Improve my Org faces / look.
- [ ] Better way to communicate that header is collapsed (something more visible than three dots).
- [ ] Give a try at non-monospace font for not-code (check System Crafters video).
   - Fixed-pitch font: JetBrains Mono, light weight.
   - Variable-pitch font: Iosevka Aile, light weight.
- [ ] Play with toggling org-indent and org-bullets.
*** TODO Add "SPC j" prefix for "jump" and then put jump/goto commands under that?.
Or, go for "SPC g" and move magit to "SPC a g"? I think I should move magit there in any case, to free up "SPC g".
Stuff I could put under "SPC j" (or "SPC g") is avy/ace jumping around the file/window, stuff like "counsel-imenu" that lets me move around the definitions in file, ... .
Hm or it could even be "SPC n" for navigation? Maybe that is the best one, it is broad and niche enough at the same time.
Of course I would still keep some specific navigation like window or buffer under buffer/window prefixes, while I would put more general stuff here.
Or, maybe I don't need "SPC j" and I should just organize navigating by domain? So jumping around file -> under "SPC f". Jumping around the window -> under "SPC w". Counsel-imenu -> under "SPC b" or "SPC f".

*** TODO Look into [[https://github.com/karthink/popper][popper]] -> specify which buffers should appear in a popup
*** TODO Does emacs have this thing where you can easily get a list of keybindings to do stuff specific for current major mode?
I think it is something like "." or ","? If yes, copy that if I can, if not, it would be nice to have that, or if not that, then some other way where I can easily figure out the main commands for this major mode (e.g. org). I konw there is C-h m, but that has too much noise for me usually.
I know that some modes (e.g. Org) have keymaps, and I see Orgs keymap mapped to C-c. Maybe that is it, the convention? I just need to add additional map to what C-c maps to?

*** TODO Check this emacs eyecandy post for good ideas
https://lmno.lol/alvaro/my-emacs-eye-candy
*** TODO Hint system
I would love to show some kind of hints in certain situations. Couple of useful keybindings when I am in some context. Kind of like Helm in Spacemacs shows it at that footer it has. Maybe some text also.
But for Ivy. Also, for stuff like company when in completion popup, to remind me of C-s and C-M-s. What if I had an area in my emacs where contextual tips are shown as you do some actions?
For example they get shown when you open completion popup, or when you start using Ivy? Could I make this a universal mechanism? Maybe I can expand it then for a bit more info if I want,
for my custom cheasheet? It would be kind of a "publish" mechanism I guess.
Btw I started, in this org document, having headers with :cheatsheet: tag, where I collect these "cheatsheets".

Ok, so refinement of the idea:
- I implement logic that, at current moment, determines what the context is. Looks at buffer name, thing at point, major mode, couple of things like that. This is the core of things.
- Then, I allow them to connect pieces of .org markup with specific contexts. For example, they can say "this piece of .org markup will be a hint for any context with this buffer name (and or this major mode, this minor mode, ...)". How do they do that? I imagine that in some .org file, they put a property under PROPERTIES that describes to which context does this header attach. I could imagine they can specify it narrower or wider: each condition they add is combined via AND with the rest of the conditions that describe a context.
  This also means they would need to specify which org file(s) to search in for these hints.
- I implement a command `hints-show` that recognizes current context and based on it displays relevant hints. They are using .org markup so I imagine it would show them in a readonly org buffer, that was somehow produced by adding all hints that are connected with this context.
- For easier usage, I should also implement a function `hints-add` that recognizes current context, and then based on it creates a new entry in the .org file that is used for hints (if there are multiple, it can ask which one you want to add this to). I can also ask if you want to reuse existing entry, if such entry exists. This would make it easier to add new hints easily, exactly in the situation where you want to see them. I wonder if orgs capture templates would be of any help here.
- Might also be convenient to have `hints-context` which just shows current context. It could be useful in some situations, when debugging.
- Possible fun name for package: intel! Intel for the context. int.el .
  
*** TODO Try replacing Ivy, Counsel, Swiper, and Company even, with Vertico, Marginalia, Orderless, Embark, Corfu, ...
Vertico is alternative to Ivy, the rest are supporting packages for it same like Counsel and Swiper are for Ivy, and then Corfu is a replacement for Company.
Seems like a lot of people like Vertico, ... , Corfu and the rest. Allegedly they using more of native Emacs stuff, so are simpler but also make more sense? Hm.
Embark seems great, it is a quite unique package: the idea is that you have a keybinding for it and then whenever you are doing something, you hit that keybinding and Embark
offers you actions that you can do in that situation / with that thing. It does however work best if Marginalia is used, because it gives it more context on stuff, and Marginalia
works best with the rest of the stuff above, so it kind of pulls one another hm, so it probably makes sense to try to go for all of it at once.

*** TODO To figure out what packages to install, I should take a look at what Doomemacs, Spacemacs (and their layers), Emacs-bedrock, and others, use, for inspiration, and how they have it configured.

- [ ] Check out bedrock emacs, simple starting config but has good stuff allegedly: https://sr.ht/~ashton314/emacs-bedrock/ .
- [ ] Check out config by this Prot guy, people say it is good: https://protesilaos.com/emacs/dotemacs .
- [ ] Another emacs config to check out, kickstarter for neovimers, might have some good stuff for evil: https://github.com/LionyxML/emacs-kick . I also saw it uses vertico, marginalia, ... .
- [ ] Check out Zuzic's emacs config: https://mail.google.com/mail/u/0/#all/KtbxLwHDghsHQDzKGkxWCWmFZsNSCGcHQq

*** TODO Learn more about Avy: https://karthinks.com/software/avy-can-do-anything/ .
*** TODO Read more about other [[https://www.reddit.com/r/emacs/comments/1gux2bi/org_search_vs_organization/?share_id=f51nt5J93w5gxGj6rjjqm&utm_content=1&utm_medium=android_app&utm_name=androidcss&utm_source=share&utm_term=10][people's org workflows]]: 
