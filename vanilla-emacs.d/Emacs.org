#+TITLE: My Vanilla Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes :results none
#+STARTUP: fold

* Lexical binding

This has to be first line in the file for lexical binding to be enabled!

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

* Preamble
Whenever this file is saved from my emacs, =init.el= and =early-init.el= are automatically generated based on it. Check [[*Automatically tangle this file (Emacs.org)]] for logic that does this.

Even though =init.el= and =early-init.el= are generated, I still keep them in version control (git), because it helps me avoid the situation where I don't have them on disk (maybe I deleted them, or I did fresh checkout) and can't easily start emacs and evaluate this very org file in order to generate them! By keeping them in version control, I have easy access to them, and I can even more easily see the diffs that were done.

#+name: timestamp
#+begin_src emacs-lisp :tangle no :results value none
  (format-time-string "%Y-%m-%d %H:%M:%S %Z")
#+end_src

#+begin_src emacs-lisp :tangle ./early-init.el :noweb yes
  ;; NOTE: This file was generated from Emacs.org on <<timestamp()>>, don't edit it manually.

#+end_src

#+begin_src emacs-lisp :tangle ./init.el :noweb yes
  ;; NOTE: This file was generated from Emacs.org on <<timestamp()>>, don't edit it manually.

#+end_src

** NOTE: Splitting (use-package) declarations into multiple org code blocks
This can be useful in order to nicely group and document the code. In this case, best way to do this is to use =(with-eval-after-load 'packagename <code that would normally go under :config>)=, for code that would go under =:config=, which is usually what we need, this is better then having multiple =(use-package ...)= declarations for the same package, because those can allegedly mess up with each other then.

* Package management
** Tutorial
*** package.el vs use-package vs elpaca

There are three important "packages" to understand here: package.el, use-package, and elpaca.

- **package.el** is a default package manager (like e.g. cabal for Haskell) that comes with emacs.
- **use-package** is a third-party package that allows for nicer, declarative and performant way to define your package configurations.
  It uses package.el in the background to install packages, but it is not a package manager, instead it is a layer above it that is focused on loading and configuring packages (and not installing, that it delegates to package manager).
- **elpaca** is a third-party package that is a package manager, a direct alternative to package.el, but more powerful / performant.

In this config I use elpaca + use-package (package.el is not even loaded).

*** Installing vs loading vs configuring packages

- Installing package means downloading (and building) the package to your machine, so it can be loaded when you want.
  This is what package manager does for you.
- Loading package means importing/requiring it in our emacs config (init.el), so it can be used. It needs to be installed first in order to be loaded (unless it comes with emacs already).
  This is what use-package takes care of.
- Configuring means exactly that: adapting the package to your needs by defining variables, key bindings, hooks, ... .
  use-package also helps with this, giving us structure and reducing boilerplate.

*** Lifecycle of a package

1. Installation typically happens when you start emacs for first time on new machine, or when you update packages or add new package.
2. Loading typically happens each time you start emacs, and it can happen immediately on init, or it can happen later, on demand,
   when package is needed (in lazy fashion), depending on how you set it up for that package.
3. Configuration typically happens right after loading.

*** use-package

The idea is that you organize all your code in `(use-package <package-name> ...)` declarations.
There is even `(use-package emacs ...)` where `emacs` is a special "package" that won't trigger any installation or loading, allowing you to put general emacs config under it (e.g. `(column-number-mode)`).

use-package has a bunch of keywords that you can use to configure your package or define how it is loaded / installed.
Mostly you will use keywords that come with use-package, but other packages can also extend use-package with their own keywords.
I will quickly explain some of the more important/confusing ones:
- :ensure -> This is really an interface toward package manager (who does package installation). Any value passed to :ensure is passed to the package manager as instructions for installation, e.g. `:ensure (:host "github" :repo "user/repo")`.
    Therefore, its behaviour depends on the package manager used. But generally, `:ensure nil` will not allow package installation, while `:ensure t` or any other value will try to do install package if not installed yet. Should be really named :ensure-installed hah.
    Normally you will want `:ensure t` for most of the packages, in which case you can (I do) configure use-package to have it be `t` by default.
    When using elpaca, you can pass elpaca recipe to :ensure.
- :defer -> `:defer t` tells use-package to postpone loading of the package till it is needed (lazy). See "deferred loading" below.
    Alternatively, you can pass it a number of seconds emacs needs to be idle before package is loaded.
- :demand -> Opposite of defer, `:demand t` tells use-package to load package now. Useful when using autoload keywords (see "deferred loading" below).
- :init -> happens right before package is loaded.
- :config -> happens right after package is loaded.
- ...

**** Deferred loading 

It is generally recommended to postpone/defer loading of packages till they are needed (if applicable), for faster emacs startup.

use-package will defer loading of packages if `:defer <non-nil>` is set, or if any of the keywords with the "autoloading side effect" are used (e.g. `bind`, `command`, `hook`, ... : these all will make use-package defer loading and then autoload package once corresponding binding / command / hook / ... has happeend).

If you use any of the "autoload" keywords but don't want use-package to be "smart" and assume you want autoloading, you can use `:demand t`.

It can be good practice to add `:defer t` even when autoloading keywords are used, to be explicit about the intention.

*** elpaca
Elpaca can install package directly: `(elpaca some-package (message "this happens after package is installed"))`, but we use it via use-package.
In the background, a call to `(use-package some-package :ensure t :some-keyword <smth>)` becomes `(elpaca some-package (use-package some-package :some-keyword <smth>))`.

**** Recipes

Elpaca allows you to define how the package should be installed via a `recipe`, which is provided as an argument to `:ensure` if using `use-package`.
Example of a recipe: `(some-package :host github :repo "user/example")`.

**** Deferred installing

Elpaca, unlike package.el, doesn't install packages immediately, instead it waits for emacs init to finish, and then installs them asynchronously, in parallel for fast, non-blocking installations.

To prevent this behaviour and make elpaca install package right now, when the corresponding `use-package` declaration is evaluated, one can pass `:wait t` keyword do the elpaca recipe: `:ensure (:wait t ...)`.
This can be useful for packages that e.g. add keywords to use-package, since you need those installed and loaded first.

Due to elpaca's deffered installing, instead of installing and loading happening during init phase (evaluation of init.el), we have following order of events: init -> installation of packages -> loading packages.
Exception are packages with `:wait t` in their recipe, those will get installed / loaded at init.
That also means that `after-init-hook` is often not the right choice any more, and we should instead use `elpaca-after-init-hook`, which will guarantee packages are installed / loaded.

** Config
*** Disable package.el (in early-init.el)

#+begin_src emacs-lisp :tangle ./early-init.el

  (setq package-enable-at-startup nil) ; Elpaca requires this.

#+end_src

*** Install and set up Elpaca (in init.el)

#+begin_src emacs-lisp

  ;; Install and set up Elpaca. 
  (defvar elpaca-installer-version 0.7)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
        (build (expand-file-name "elpaca/" elpaca-builds-directory))
        (order (cdr elpaca-order))
        (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))

#+end_src
  
*** Install and set up use-package (with Elpaca as backend)

#+begin_src emacs-lisp

  (elpaca elpaca-use-package (elpaca-use-package-mode)) ; Install/setup use-package.
  (setq use-package-always-ensure t) ; Tells use-package to have :ensure t by default for every package it manages.

#+end_src

* Utils
** Vars

#+begin_src emacs-lisp

  (defun my/var-state (var)
    "Returns the value of a variable with specified name, or 'my/var-unbound if it is not bound."
    (if (boundp var) (symbol-value var) 'my/var-unbound)
  )

  (defun my/local-var-state (var)
    "Returns the value of a buffer-local variable with specified name, or 'my/var-unbound if it is not bound."
    (if (local-variable-p var) (symbol-value var) 'my/var-unbound)
  )

  (defun set-local (var value)
    "Like setq-local but takes a var symbol (analogous to setq and set)."
    (set (make-local-variable var) value)
  )

#+end_src

*** Saving and restoring buffer-local vars

#+begin_src emacs-lisp

  (defun my/save-local-var-state (var)
    "Save the current state of buffer-local VAR (symbol) and return a lambda that restores VAR to its original state.
  USAGE:
    (let ((restore-foo (my/save-local-var-state 'foo)))
      ...
      (funcall restore-foo)
    )"
    (let ((og-state (my/local-var-state var)))
      (lambda ()
        (if (eq og-state 'my/var-unbound)
  	(kill-local-variable var)
        (set-local var og-state)
      )
      )
    )
  )

  (defun my/save-local-vars-state (vars)
    "Like my/save-local-var-state but takes a list of vars.
  USAGE:
    (let ((restore-vars (my/save-local-vars-state '(foo bar buzz))))
      ...
      (funcall restore-vars)
    )"
    (let ((restore-fns (mapcar #'my/save-local-var-state vars)))
      (lambda () (dolist (restore-fn restore-fns) (funcall restore-fn)))
    )
  )

  (defun my/set-local-vars-with-restore (vars-and-values)
    "Set each variable in VARS-AND-VALUES as a buffer-local variable with the specified value.
  Returns a lambda that, when called, restores each variable to its original buffer-local state.
  VARS-AND-VALUES should be a list of (VAR . VALUE) pairs.
  USAGE:
    (let ((restore-vars (my/save-local-vars-with-restore '((foo . 42) (bar .  t)))))
      ...
      (funcall restore-vars)
    )"
    (let* ((vars (mapcar #'car vars-and-values))
  	 (restore-fn (my/save-local-vars-state vars)))
      (dolist (var-and-value vars-and-values)
        (let ((var (car var-and-value))
  	    (value (cdr var-and-value)))
  	(set-local var value)
        )
      )
      restore-fn
    )
  )

#+end_src

** Modes
*** Saving and restoring

#+begin_src emacs-lisp

  (defun my/save-mode-state (mode)
    "Save the current state (enabled or disabled) of MODE (symbol) and return a lambda that restores MODE to its original state.
  USAGE:
    (let ((restore-evil-local-mode (my/save-mode-state 'evil-local-mode)))
      ...
      (funcall restore-evil-local-mode)
    )"
    (let ((og-mode-var-state (my/var-state mode)))
      (lambda ()
        (when (not (eq og-mode-var-state 'my/var-unbound))
          (funcall mode (if (eq og-mode-var-state nil) -1 1))
        )
      )
    )
  )

  (defun my/save-modes-state (modes)
    "Like my/save-mode-state but takes a list of modes.
  USAGE:
    (let ((restore-modes (my/save-modes-state '(evil-local-mode org-tidy-mode))))
      ...
      (funcall restore-modes)
    )"
    (let ((restore-fns (mapcar #'my/save-mode-state modes)))
      (lambda () (dolist (restore-fn restore-fns) (funcall restore-fn)))
    )
  )

  (defun my/set-modes-with-restore (modes-and-values)
    "Set each mode in MODES-AND-VALUES with the specified value.
  Returns a lambda that, when called, restores each mode to its original state (enabled/disabled).
  MODES-AND-VALUES should be a list of (MODE . VALUE) pairs.
  USAGE:
    (let ((restore-modes (my/save-modes-with-restore '((evil-local-mode . -1) (org-tidy-mode . 1)))))
      ...
      (funcall restore-modes)
    )"
    (let* ((modes (mapcar #'car modes-and-values))
  	 (restore-fn (my/save-modes-state modes)))
      (dolist (mode-and-value modes-and-values)
        (let ((mode (car mode-and-value))
  	    (value (cdr mode-and-value)))
  	(funcall mode value)
        )
      )
      restore-fn
    )
  )

#+end_src

* Basic emacs config

#+begin_src emacs-lisp

  (use-package emacs
    :ensure nil
    :config
    (setq inhibit-startup-message t)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (menu-bar-mode -1)
    (setq ring-bell-function 'ignore)
    (set-fringe-mode 10)
    (setq-default fill-column 100)
    (column-number-mode) ; Show row:column in mode line.
    (visual-line-mode 1) ; Treat wrapped lines as multiple lines when moving around.
    (global-hl-line-mode 1) ; Highlights the line in which cursor is.
    (global-auto-revert-mode t) ; Automatically reload files if they change on disk (will ask if conflict).
    (add-hook 'window-setup-hook 'toggle-frame-fullscreen t) ; Start in fullscreen.

    (setq gc-cons-threshold 100000000) ; Default is low, so we set it to 100mb. Helps with e.g. lsp-mode.
    (setq read-process-output-max (* 1024 1024)) ;; Default is low, so we set it to 1mb. Helps with e.g. lsp-mode.
  )

#+end_src

* Theme

#+begin_src emacs-lisp

  ;; doom-themes have nice, high quality themes.
  (use-package doom-themes
    :ensure (:wait t) ; Too ensure theme gets loaded as early as possible, so there is no white scren.
    :config
    ;; I went with dracula for now. palenight is also nice.
    ;; TODO: Figure out where and how is the best way to do theme customization. I am guessing it shoudl be happening in a central place,
    ;;   even if it is about other packages faces, and that it should happen next to loading of the theme?
    (load-theme 'doom-dracula t)
  )

#+end_src

* Modeline

#+begin_src emacs-lisp

  ;; TODO: Configure better or use some other modeline.
  (use-package doom-modeline
    :config
    (setq doom-modeline-height 40)
    (doom-modeline-mode 1)
  )

#+end_src

* Undo
** Increase undo memory limits

#+begin_src emacs-lisp

  (use-package emacs
    :ensure nil
    :config
    ;; Default emacs undo limits are quite low so we increase them here.
    (setq undo-limit         50000000) ; ~50mb.
    (setq undo-strong-limit 100000000) ; ~100mb.
    (setq undo-outer-limit  300000000) ; ~300mb.
  )

#+end_src

** undo-fu: "normal" undo behaviour

**undo-fu** is a simple package that brings undo/redo commands that behave in a simple, linear fashion, like you would expect.
However, it still keeps emacs' undo/redo complex system intact with all the state it keeps, these commands just serve as a simpler interface toward it, so you can still interact with it if you wish (e.g. with vundo which visualizes the undo state as tree).
I don't set any keybindings here because it is enough to set undo-fu as evil's undo system (check my evil config) and then evil uses it.

#+begin_src emacs-lisp

  (use-package undo-fu
    :config
    (setq undo-fu-ignore-keyboard-quit t) ; I don't want C-g to trigger normal emacs undo behavior.
  )

#+end_src

** vundo: undo tree

#+begin_src emacs-lisp

  ;; Displays undo history as a tree and lets you move through it.
  (use-package vundo
    :defer t
    :config
    (setq vundo-glyph-alist vundo-unicode-symbols)

    ;;;;;; Vundo Live Diff ;;;;;;
    ;; In vundo, you have to manually mark one node and call diff on another node to get their diff.
    ;; Here we extend vundo to have "live diff mode", that always shows diff between current node and its parent.
    ;; I turn it on by default. It can be toggled by pressing "F".
    (defun vundo-live-diff-post-command ()
      "Post command hook function for live diffing."
      (when (not (memq this-command '(vundo-quit vundo-confirm)))
        (progn
          (vundo-diff-mark (vundo-m-parent (vundo--current-node vundo--prev-mod-list)))
          (vundo-diff)
        )
      )
    )
    (define-minor-mode vundo-live-diff-mode
      "Shows live diff between the current node and its parent."
      :lighter nil
      (if vundo-live-diff-mode
        (add-hook 'post-command-hook #'vundo-live-diff-post-command 0 t)
        (remove-hook 'post-command-hook #'vundo-live-diff-post-command t)
      )
    )
    (evil-define-key 'normal vundo-mode-map (kbd "F") #'vundo-live-diff-mode)
    (add-hook 'vundo-mode-hook (lambda () (vundo-live-diff-mode 1)))
    ;;;;;/ Vundo Live Diff ;;;;;;
  )

#+end_src

** TODO Install undo-fu-session?
Do I need persistent undo between the emacs sessions? I think not?
** TODO Install undo-hl (highlights changes by undo in buffer)?
Seems to not be on any package manager though, so I need straight.el probably.

* Keybindings
** general.el

#+begin_src emacs-lisp

  ;; general.el provides convenient, unified interface for key definitions.
  ;; It can do many cool things, one of them is specifying leader key and prefixes.
  ;; For best results, you should do all/most of the key defining via general (e.g. `general-define-key`).
  ;; NOTE: I found general.el to be really complex, and I haven't invested the time to properly understand it.
  ;;   Therefore, I don't completely understand if the config below is written in the best way, but
  ;;   it was recommended by others and it seems to work.
  (use-package general
    :ensure (:wait t) ; Load it immediately, so that I can use :general keyword in use-package declarations below if I want.
    :config
    (general-evil-setup t)

    ;; general-create-definer allows you to create a function with some defaults set, that you can use to define more keys.
    ;; We use it here to create a definer that sets SPC as a prefix (leader key) for any key that is defined with it.
    (general-create-definer my/leader-keys
      :states '(motion normal insert visual emacs)
      :keymaps 'override ; Override any other keymaps with same keybindings. Otherwise I get issues with the `motion` and SPC, since `motion` already defines keybindings for SPC.
      :prefix "SPC" ; This will be active only in "normal"-like states (so `normal`, `motion` and `emacs`).
      :global-prefix "C-SPC" ; This will be always active.
    )

    ;; TODO: In general.el README, this way of defining keys is listed as ineficient (slows down startup time).
    ;;   I should check https://github.com/noctuid/general.el?tab=readme-ov-file#will-generalel-slow-my-initialization-time
    ;;   and possibly rewrite it to follow the advice there.
    ;;   Also, should I use :general keyword in use-package? Figure this out, the best way to define keybindings with SPC prefix,
    ;;   should they all be here, or in their respective packages, or what.
    (my/leader-keys
      "SPC" '(counsel-M-x :which-key "M-x (exec cmd)")
      "TAB" '(my/alternate-buffer :which-key "previous buffer")
      "RET" '((lambda () (interactive) (org-agenda nil "w")) :which-key "work diary")

      "0"   '(winum-select-window-0 :which-key "jump to window 0")
      "1"   '(winum-select-window-1 :which-key "jump to window 1")
      "2"   '(winum-select-window-2 :which-key "jump to window 2")
      "3"   '(winum-select-window-3 :which-key "jump to window 3")
      "4"   '(winum-select-window-4 :which-key "jump to window 4")

      ;; TODO: When inside counsel-projectile-rg, you can do C-c C-o to persist the search results in a special buffer,
      ;;   and then in that buffer you can press enter on any of them and jump to that location.
      ;;   This is awesome, but how will I remember this? Somehow help myself remember this. Another candidate for "hint"/"help" zone?
      ;;   Btw Helm (in Spacemacs) has this bar at the bottom where it shows which command was just run and some hints (C-z for actions, ...).
      ;;   Is this something I can replicate, at least for Ivy?
      "/"   '(counsel-projectile-rg :which-key "search in project")
      "*"   '(counsel-projectile-rg-region-or-symbol :which-key "search in project w/input")

      ;; TODO: Add "'" to open shell.

      "t"   '(:ignore t :which-key "toggles") ; This is how prefix is defined.
      "tt"  '(counsel-load-theme :which-key "choose theme")
      "ts"  '(hydra-text-scale/body :which-key "scale text")

      "a"   '(:ignore t :which-key "apps")
      "au"  '(vundo :which-key "undo tree")

      "af"   '(:ignore t :which-key "fun")
      "afa" '(animate-birthday-present :which-key "birthday")
      "afb" '(blackbox :which-key "blackbox")
      "afc" '(butterfly :which-key "butterfly")
      "afd" '(doctor :which-key "doctor")
      "afe" '(bubbles :which-key "bubbles")
      "aff" '(dunnet :which-key "dunnet")
      "afg" '(gnugo :which-key "gnugo")
      "afh" '(hanoi :which-key "hanoi")
      "afi" '(gomoku :which-key "gomoku")
      "afj" '(solitaire :which-key "solitaire")
      "afl" '(life :which-key "life")
      "afp" '(pong :which-key "pong")
      "afs" '(snake :which-key "snake")
      "aft" '(tetris :which-key "tetris")
      "afx" '(5x5 :which-key "5x5")
      "afz" '(zone :which-key "zone")

      "q"   '(:ignore t :which-key "quit")
      "qq"  '(save-buffers-kill-terminal :which-key "quit")
      "qr"  '(restart-emacs :which-key "restart")

      "w"   '(:ignore t :which-key "windows")
      "ww"  '(ace-window :which-key "other window")
      "wd"  '(delete-window :which-key "delete window")
      "w/"  '(split-window-right :which-key "split vertically")
      "w-"  '(split-window-below :which-key "split horizontally")
      "wr"  '(hydra-window-resize/body :which-key "resize window")
      "wm"  '(hydra-window-move/body :which-key "move window")

      "b"   '(:ignore t :which-key "buffers")
      "bb"  '(ivy-switch-buffer :which-key "switch buffer")
      "bd"  '(kill-this-buffer :which-key "kill buffer")
      "bs"  '(scratch-buffer :which-key "go to scratch")
      "bm"  '(my/switch-to-messages-buffer :which-key "go to messages")
      "bp"  '(hydra-buffer-next-prev/previous-buffer :which-key "previous buffer")
      "bn"  '(hydra-buffer-next-prev/next-buffer :which-key "next buffer")
      "br"  '(revert-buffer :which-key "reload buffer")

      "e"   '(:ignore t :which-key "errors")
      "en"  '(flycheck-next-error :which-key "next")
      "ep"  '(flycheck-previous-error :which-key "previous")
      "el"  '(flycheck-list-errors :which-key "list")

      "f"   '(:ignore t :which-key "files")
      "fj"  '(avy-goto-char-timer :which-key "jump in file")
      "ff"  '(counsel-find-file :which-key "find file")
      "fs"  '(save-buffer :which-key "save")
      "fr"  '(counsel-recentf :which-key "recent files")

      "fe"  '(:ignore t :which-key "emacs")
      "feo" '(my/open-emacs-org-file :which-key "open Emacs.org file")
      "fei" '(my/open-init-file :which-key "open init.el file")

      "v"   '(:ignore t :which-key "eval (elisp)")
      "v:"  '(eval-expression :which-key "expression")
      "vl"  '(eval-last-sexp :which-key "last-sexp")
      "vv"  '(eval-defun :which-key "top-level form")
      "vr"  '(eval-region :which-key "region")

      "o"   '(:ignore t :which-key "org")
      "oa"  '(org-agenda :which-key "agenda")
      "oc"  '(org-capture :which-key "capture")
      "ol"  '(org-store-link :which-key "store link")

      "p"   '(:ignore t :which-key "projects")
      "pf"  '(counsel-projectile-find-file :which-key "find file")
      "pd"  '(projectile-find-dir :which-key "find dir")
      "pb"  '(projectile-switch-to-buffer :which-key "switch buffer")
      "pp"  '(counsel-projectile-switch-project :which-key "switch project")
      "pr"  '(projectile-replace :which-key "find and replace")
      "p."  '(projectile-command-map :which-key "all commands")

      "g"   '(magit :which-key "magit")
    )

    (general-define-key
      :states '(normal visual)
      :keymaps 'override
      "p" 'my/paste-after-then-hydra
      "P" 'my/paste-before-then-hydra
    )
  )

#+end_src

#+RESULTS:

** which-key

#+begin_src emacs-lisp

  (use-package which-key
    :config
    (setq which-key-idle-delay 0.5)
    (setq which-key-add-column-padding 2)
    (setq which-key-min-display-lines 5)
    (which-key-mode)
  )

#+end_src

** hydras

Hydra enables you to define a small "menu", which when you activate, activates transient unique keybindings (which you also defined) that you can use only then, and lists them in the minibuffer in a nice menu.

It is convenient when you need to spam a lot of very specific commands, e.g. scale text (in / out), or resize window (left / right / up / down), or iterate through kill ring, or something like that.
So then you go into "text scale resizing mode" to put it that way, and you can easily resize it with e.g. one letter commands.

#+begin_src emacs-lisp

  (use-package hydra
    :config
    (defhydra hydra-text-scale ()
      "Scale text"
      ("j" text-scale-decrease "out")
      ("k" text-scale-increase "in")
      ("r" (progn (text-scale-increase 0)) "restore")
      ("q" nil "quit" :exit t)
    )

    (defhydra hydra-buffer-next-prev ()
      "Next/previous buffer"
      ("p" previous-buffer "previous")
      ("n" next-buffer "next")
      ("q" nil "quit" :exit t)
    )

    (defhydra hydra-paste ()
      "Choose what to paste from the kill ring"
      ("C-j" evil-paste-pop "previous")
      ("C-k" evil-paste-pop-next "next")
      ("/" (progn
            (evil-undo-pop) ; Undo last paste.
            ;; NOTE: Ideally, I would put the new paste (about to be selected by counsel-yank-pop)
            ;; starting exactly from the same place as previous paste, as e.g. evil-paste-pop does,
            ;; but I haven't found a simple way to implement that, so I do a more simplistic
            ;; approach, below that is a bit less precise (e.g. adds redundant newline). However I
            ;; don't think that is a big problem if one decided to browse kill ring visually, you
            ;; care less about speed / formatting then.
            (goto-char (nth 2 evil-last-paste)) ; Put cursor back where it was before the last paste.
            (if (eq last-command 'evil-paste-before)
                (evil-insert-newline-above)
                (evil-insert-newline-below)
            )
            (counsel-yank-pop) ; Browse kill ring, pick entry and paste it.
          )
          "browse"
      )
      ("q" nil "quit" :exit t)
    )
    (defun my/paste-after-then-hydra ()
      (interactive)
      (call-interactively 'evil-paste-after)
      (hydra-paste/body)
      ;; This way this command is recognized as evil-paste-after, making evil-paste-after a last-command,
      ;; which is a requirement for evil-paste-pop functions from hydra-paste to be able to be executed
      ;; after this one.
      (setq this-command 'evil-paste-after)
    )
    (defun my/paste-before-then-hydra ()
      (interactive)
      (call-interactively 'evil-paste-before)
      (hydra-paste/body)
      (setq this-command 'evil-paste-before)
    )

    (defhydra hydra-window-resize (:hint nil)
      "
    Resize window
    -------------
                _h_: ⇾ ⇽          ↑        ↓
                              _k_:     _j_:
                _l_: ⇽ ⇾          ↓        ↑
    "
      ("h" shrink-window-horizontally)
      ("j" shrink-window)
      ("k" enlarge-window)
      ("l" enlarge-window-horizontally)
      ("q" nil "quit" :exit t)
    )

    (defhydra hydra-window-move (:hint nil)
      "
    Move window
    -----------
                        _k_: top
                _h_: left       _l_: right
                        _j_: bottom
    "
      ("h" evil-window-move-far-left)
      ("j" evil-window-move-very-bottom)
      ("k" evil-window-move-very-top)
      ("l" evil-window-move-far-right)
      ("q" nil "quit" :exit t)
    )
  )

#+end_src

** Evil

#+begin_src emacs-lisp
  
  ;; CHEATSHEET: C-z puts us into `emacs` mode, which is normal situation without evil.
  (use-package evil
    :init
    (setq evil-want-integration t)  ; Required by evil-collection.
    (setq evil-want-keybinding nil) ; Required by evil-collection.
    (setq evil-undo-system 'undo-fu)
    ;; C-u-scroll needs explicit enabling because in Emacs C-u is important, it is
    ;; universal argument. But I don't use it much, so I rather go with vi's
    ;; scroll, which I use a lot.
    (setq evil-want-C-u-scroll t)
    :custom
    (evil-shift-width 2) ; When shifting text left or right with < or >, do it for 2 spaces.
    :config
    (evil-mode 1)
    (define-key evil-motion-state-map (kbd "SPC") nil) ; To avoid conflict with me using SPC as leader key (defined via general.el).
  )

#+end_src

#+begin_src emacs-lisp

  (use-package evil-escape
    :after evil
    :custom
    (evil-escape-key-sequence "fd")
    :config
    (evil-escape-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Sets evil keybindings in many more parts of emacs than evil-mode does by default,
  ;; and in a better way than evil does.
  (use-package evil-collection
    :after evil
    :custom (evil-collection-setup-minibuffer nil)  ; If set to `t` it messes up / overrides my custom keybindings for Ivy (e.g. C-k).
    :config (evil-collection-init)
  )

#+end_src

* Org mode
** Basic setup (org)

#+begin_src emacs-lisp

  (use-package org
    :defer t
    :hook
    (org-mode . (lambda ()
      (org-indent-mode) ; Enforces correct indentation under each heading.
      (visual-line-mode 1)
      (setq evil-auto-indent nil)
    ))
    :config
    ;; Set headers to have different sizes.
    (dolist (face '((org-level-1 . 1.5)
                    (org-level-2 . 1.3)
                    (org-level-3 . 1.2)
                    (org-level-4 . 1.1)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :height (cdr face))
    )

    (setq org-log-into-drawer t)
    (setq org-habit-graph-column 60)

    (add-to-list 'org-modules
  	'org-habit
    )
  )

  ;; Replace stars (*) with nice bullets.
  (use-package org-bullets
    :after (org)
    :defer t
    :hook (org-mode . org-bullets-mode)
  )

  ;; Org Tempo expands snippets to structures defined in org-structure-template-alist and org-tempo-keywords-alist.
  (use-package org-tempo
    :after (org)
    :ensure nil ; Comes with org already.
  )

  (use-package org-habit-stats
    :after (org)
  )

  ; Colors tags in org mode with "random" colors based on their string hash.
  (use-package org-rainbow-tags
    :after (org)
    :hook (org-mode . org-rainbow-tags-mode)
    :custom
    (org-rainbow-tags-extra-face-attributes
     ;; Default is '(:weight 'bold)
     '(:inverse-video t :weight 'bold))
  )

#+end_src

** evil-org
#+begin_src emacs-lisp

  (use-package evil-org
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
  )

#+end_src

** Code blocks (org-babel)

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    ;; Here we define our custom structure templates (snippets) for quickly creating code blocks.
    ;; Typing e.g. "<elTAB" will expand it to snippet.
    (dolist (key-to-block-type '(("sh" . "src shell")
                                 ("el" . "src emacs-lisp")
  			       ("py" . "src python")))
      (add-to-list 'org-structure-template-alist key-to-block-type)
    )
    
    ;; Define which languages can be evaluated/executed in org files.
    ;; Org will load support for them.
    (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (python . t))
    )

    (setq org-confirm-babel-evaluate nil) ; Don't ask for confirmation when evaluation a block.
  )

#+end_src

** org-agenda
*** General setup
#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (setq org-agenda-scheduled-leaders '("-> " "-%dd -> "))
    (setq org-agenda-deadline-leaders '("! " "+%dd ! " "-%dd ! "))
    ;; Make the current time in the time-grid (<- now --------) stand out.
    (set-face-attribute 'org-agenda-current-time nil :inherit 'font-lock-constant-face :weight 'bold)
  )

#+end_src

*** org-super-agenda

Org-super-agenda allows both easier and smarter grouping of entries under a day/week org agenda view.
Each org-super-agenda group "consumes" entries it shows, leaving the next group with less entries, kind of like a parser. Whatever is left at the end is shown at the end of agenda as "Other items".

#+begin_src emacs-lisp

  (use-package org-super-agenda
    :after org
    :init 
    ;; org-super-agenda-header-map is keymap for super agenda headers and normally it just copies keybindings
    ;; from org-agenda-mode-map, but since I modify those later with evil-org, then I don't want
    ;; org-super-agenda-header-map sticking to the old keybindings and having super agenda headers behave
    ;; in default, non-evil way (e.g. "j" when on them doesn't move down but opens calendar).
    ;; I haven't managed to figure out how to update it to behave in an evil fashion, so I ended up just disabling
    ;; it completely, and that works great.
    (setq org-super-agenda-header-map nil)
    (setq org-super-agenda-keep-order t) ; Can degrade performance, which is why it isn't enabled by default.
    :config
    (org-super-agenda-mode)
  )

#+end_src

*** Evil keybindings

#+begin_src emacs-lisp

  (with-eval-after-load 'evil
    ;; TODO: I am basing these keybindings on the evil-org-agenda-set-keys function from
    ;;   evil-org-agenda.el (from evil-org package), but I copied them directly here so I can easily modify
    ;;   them as I wish.

    (evil-set-initial-state 'org-agenda-mode 'motion)

    (evil-define-key 'motion org-agenda-mode-map
      ;; Opening org file.
      (kbd "<tab>") 'org-agenda-goto
      (kbd "RET") 'org-agenda-switch-to
      (kbd "M-RET") 'org-agenda-recenter

      ;; Motion.
      "j" 'org-agenda-next-line
      "k" 'org-agenda-previous-line
      "gH" 'evil-window-top
      "gM" 'evil-window-middle
      "gL" 'evil-window-bottom
      (kbd "C-j") 'org-agenda-next-item
      (kbd "C-k") 'org-agenda-previous-item
      (kbd "[[") 'org-agenda-earlier
      (kbd "]]") 'org-agenda-later

      ;; manipulation
      ;; We follow standard org-mode bindings (not org-agenda bindings):
      ;; <HJKL> change todo items and priorities.
      ;; M-<jk> drag lines.
      ;; M-<hl> cannot demote/promote, we use it for "do-date".
      "J" 'org-agenda-priority-down
      "K" 'org-agenda-priority-up
      "H" 'org-agenda-do-date-earlier
      "L" 'org-agenda-do-date-later
      "t" 'org-agenda-todo
      (kbd "M-j") 'org-agenda-drag-line-forward
      (kbd "M-k") 'org-agenda-drag-line-backward
      (kbd "C-S-h") 'org-agenda-todo-previousset ; Original binding "C-S-<left>"
      (kbd "C-S-l") 'org-agenda-todo-nextset ; Original binding "C-S-<right>"

      ;; undo
      "u" 'org-agenda-undo

      ;; actions
      "dd" 'org-agenda-kill
      "dA" 'org-agenda-archive
      "da" 'org-agenda-archive-default-with-confirmation
      "ct" 'org-agenda-set-tags
      "ce" 'org-agenda-set-effort
      "cT" 'org-timer-set-timer
      "i" 'org-agenda-diary-entry
      "a" 'org-agenda-add-note
      "A" 'org-agenda-append-agenda
      "C" 'org-agenda-capture
      "e" 'org-agenda-tree-to-indirect-buffer

      ;; mark
      "m" 'org-agenda-bulk-toggle
      "~" 'org-agenda-bulk-toggle-all
      "*" 'org-agenda-bulk-mark-all
      "%" 'org-agenda-bulk-mark-regexp
      "M" 'org-agenda-bulk-unmark-all
      "x" 'org-agenda-bulk-action

      ;; refresh
      "gr" 'org-agenda-redo
      "gR" 'org-agenda-redo-all

      ;; quit
      "ZQ" 'org-agenda-exit
      "ZZ" 'org-agenda-quit

      ;; display
      "gD" 'org-agenda-view-mode-dispatch
      "ZD" 'org-agenda-dim-blocked-tasks

      ;; clock
      "I" 'org-agenda-clock-in ; Original binding
      "O" 'org-agenda-clock-out ; Original binding
      "cg" 'org-agenda-clock-goto
      "cc" 'org-agenda-clock-cancel
      "cr" 'org-agenda-clockreport-mode

      ;; go and show
      "." 'org-agenda-goto-today
      "gc" 'org-agenda-goto-calendar
      "gC" 'org-agenda-convert-date
      "gd" 'org-agenda-goto-date
      "gh" 'org-habit-stats-view-habit-at-point-agenda
      "gm" 'org-agenda-phases-of-moon
      "gs" 'org-agenda-sunrise-sunset
      "gt" 'org-agenda-show-tags
      "ge" 'org-agenda-entry-text-mode

      "p" 'org-agenda-date-prompt
      "P" 'org-agenda-show-the-flagging-note

      "+" 'org-agenda-manipulate-query-add
      "-" 'org-agenda-manipulate-query-subtract
    )
  )

#+end_src

*** Agenda custom commands

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (defun make-work-diary-command (cmd-key cmd-name cmd-start-day)
      `(,cmd-key ,cmd-name
         (;; The main view: a list of tasks for today.
  	(agenda ""
  		((org-agenda-span 'day)
  		 (org-agenda-prefix-format " %12s %5e %?-12t")
  		 (org-agenda-sorting-strategy '(time-up todo-state-down priority-down scheduled-up urgency-down))
                   (org-agenda-time-grid '((daily today remove-match)
  					 (800 1000 1200 1400 1600 1800 2000)
                                           " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"
  			                )
                   )
  		 (org-habit-show-all-today t)
  		 (org-super-agenda-groups
  		  '(;; Repeating tasks to be done every day, including today.
  		    (:name "Daily Checklist"
  			    :and (:category "dc"
  				  :not (:log t))
  		    )
                      (:name "Todo"
  		            :and (:time-grid t :not (:log t))
  		    )
  		    (:name "                   ----"
  			    :and (:category "task"
  				  :scheduled t
  				  :not (:log t))
  		    )
                      ;; Discard "closed" logs for items scheduled for today because they will be shown
  		    ;; as done already above, so we don't want to repeat it.
  		    ;; NOTE: Due to this bug in super-agenda https://github.com/alphapapa/org-super-agenda/issues/42,
  		    ;;   `:scheduled today` works as you would expect only when agenda is actually focused on today,
  		    ;;   because today means the actual day today, not the day that agenda daily view is focusing on.
                      ;;   Therefore if I look at yesterday, this discarding doesn't work and I get double done entries.
                      (:discard (:and (:scheduled today :log closed)))
  		    (:name none
  			    :and (:category "task"
  				  :log closed)
  		    )
  		    (:name "Clock log"
  	                   :log clocked
  		    )
  		   )
  		 )
  		)
  	)
  	(alltodo ""
  		 ((org-agenda-overriding-header "")
  		  (org-agenda-prefix-format " %5e ")
  		  (org-super-agenda-groups
  		   '((:name "Notes"
    			    :category "note"
    		     )
  		     (:discard (:scheduled t :deadline t :time-grid t))
  		     (:name "All tasks with no schedule / deadline"
  			    :category "task"
  		     )
  		     (:discard (:anything t))
  		    )
  		  )
  		 )
  	)
         )
         ((org-agenda-files '("~/Dropbox/work-diary.org"))

  	(org-agenda-start-day ,cmd-start-day)

  	;; Starts agenda log mode, which means that special extra "log" entries are added to agenda, in this logs about closing an entry and logs about clocking an entry. I could also have added 'state' if needed. I track "closed" logs in order to ensure that entries that are DONE but have been scheduled in the past are shown in agenda (normally they are not). What is not great is that they are not normal but special log entries which are a bit different, so a bit harder to organize.
  	(org-agenda-start-with-log-mode '(closed clock))

  	;; Org agenda shows both scheduled and deadline entries for an item, when available.
  	;; I don't want that, so this way I avoid having both.
  	;; Instead, if before deadline, scheduled item is shown, but deadline warning is not.
  	;; And if after deadline, only item with deadline delay is shown, not the one with scheduled delay.
  	;; The only thing there was no way to configure is to avoid showing both scheduled and deadline entries
  	;; on the day of the deadline itself, so in that case both are shown, but ok I can live with that.
  	(org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  	(org-agenda-skip-scheduled-repeats-after-deadline t)

          (org-todo-keyword-faces
           '(("EPIC" . (:foreground "orchid" :weight bold))
             ("CANCELED" . (:foreground "dim gray" :weight bold :strike-through t))
             ("CANCELED[EPIC]" . (:foreground "dim gray" :weight bold :strike-through t))
             ("CHKL" . (:foreground "grey" :weight bold))
  	  )
          )
         )
      )
    )

    (setq org-agenda-custom-commands
  	(list
  	 (make-work-diary-command "W" "Work Diary (tomorrow)" "+1d")

  	 (make-work-diary-command "w" "Work Diary"            nil)

           '("p" "Private Todo"
  	   (;; The main view: a list of tasks for today.
  	    (agenda ""
  		    ((org-agenda-span 'day)
                       (org-agenda-prefix-format " %12s %5e ")
  		     (org-agenda-sorting-strategy '(todo-state-down priority-down urgency-down effort-down))
  		     (org-habit-show-all-today t)
                       (org-super-agenda-groups
  		      '((:name "Habits"
                                 :and (:category "habit"
                                       :not (:log t))
  			)
  			;; Tasks to be done today.
                          (:name "Todo"
                                 :and (:category "task"
  				     :scheduled t
  				     :not (:scheduled future)
  				     :not (:log t))
  			)
  			;; Tasks that were done today.
                          (:name none
                                 :and (:category "task"
                                       :log closed)
  			)
  		       )
                       )
  		    )
              )
              ;; All tasks without a schedule or a deadline.
              (alltodo ""
                       ((org-agenda-overriding-header "")
                        (org-agenda-prefix-format " %5e ")
  		      (org-super-agenda-groups
                         '((:discard (:scheduled t :deadline t :time-grid t))
                           (:name "All tasks with no schedule / deadline"
                                  :category "task"
                           )
  			 (:discard (:anything t))
  		        )
  		      )
                       )
  	    )
  	   )
  	   ((org-agenda-files '("~/Dropbox/private-todo.org"))

  	    (org-agenda-start-with-log-mode '(closed clock))
              (org-agenda-skip-scheduled-if-done t)
              (org-agenda-skip-deadline-if-done t)

              (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
              (org-agenda-skip-scheduled-repeats-after-deadline t)
  	   )
  	  )
  	 )
    )
  )

#+end_src

** org-tidy

#+begin_src emacs-lisp

  (use-package org-tidy)

#+end_src

** org-present

Turns any org document into a presentation! Each top-level header is one slide.

#+begin_src emacs-lisp

  (use-package org-present
    :after (org visual-fill-column org-tidy)
    :bind (
      :map org-present-mode-keymap
             ("q" . org-present-quit)
    )
    :config

    ;; TODO: I should make it work with evil-mode.
    ;;   Then I could not probably even need to go read-only.

    (defun my/on-presentation-start ()
      (let ((restore-local-vars
  	      (my/save-local-vars-state
  	        '(visual-fill-column-width
  		  visual-fill-column-center-text
  		  org-tidy-properties-style
  		  org-tidy-general-drawer-flag
  		  org-tidy-general-drawer-name-whitelist)))
            (restore-modes
                (my/save-modes-state
                  '(evil-local-mode
  		  visual-line-fill-column-mode
                    org-tidy-mode)))
  	 )

        (when (featurep 'evil)
          (evil-local-mode -1) ; Otherwise evil messes up org-present.
        )

        (org-present-big)
        (org-display-inline-images)
        (org-present-hide-cursor)
        (org-present-read-only)

        ;; Soft wraps the text at fixed width while also centering it.
        ;; TODO: I could get decent fixed width only with value of 20 when `(org-present-big)`
        ;;   is used above, while I would normally expect 80 to do it.
        ;;   Figure out why is that so -> does usage of `(text-scale-increase)` in `(org-present-big)`
        ;;   uses somehow mess things up? This is because it is after inline-images!
        ;; TODO: There also seems to be some weird interaction between this mode and (org-display-inline-images).
        ;;   If this happens before inlining images, then ATTR_ORG :width behaves weird.
        (setq-local visual-fill-column-width 20
                    visual-fill-column-center-text t)
        (visual-line-fill-column-mode 1)

        ;; Hide org drawers (:PROPERTY: and :NOTES:).
        (setq-local org-tidy-properties-style 'invisible
  		  org-tidy-general-drawer-flag t
  		  org-tidy-general-drawer-name-whitelist '("NOTES"))
        (org-tidy-mode 1)

        (defun my/on-presentation-quit ()
  	(org-present-small)
  	(org-remove-inline-images)
  	(org-present-show-cursor)
  	(org-present-read-write)

  	(funcall restore-local-vars)
  	(funcall restore-modes)

  	(remove-hook 'org-present-mode-quit-hook 'my/on-presentation-quit)
        )
        (add-hook 'org-present-mode-quit-hook 'my/on-presentation-quit)
      )
    )
    (add-hook 'org-present-mode-hook 'my/on-presentation-start)

    (defun my/org-present-eval-print-last-sexp ()
      "Evaluate and print (in buffer) the last sexp while in presentation mode."
      (interactive)
      (org-present-read-write)
      (eval-print-last-sexp)
      (org-present-read-only)
    )
  )

#+end_src

*** Cheatsheet :cheatsheet:
- `org-present` to go into presentation mode.
- left and right arrow take you to previous or next header (which is actually now a slide).
- "q" to exit the presentation.
- I configured it so that it hides :NOTES: org drawer, so you can use it to add speaker notes to each slide.

** Automatically tangle this file (Emacs.org)

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (defun my/org-babel-tangle-no-confirm ()
      (let ((org-confirm-babel-evaluate nil)) (org-babel-tangle))
    )
    (defun my/when-emacs-org-file-tangle-on-save ()
      (when (and buffer-file-name (string-equal buffer-file-name (my/emacs-org-file-path)))
        (add-hook 'after-save-hook 'my/org-babel-tangle-no-confirm nil t) ; t here makes this hook buffer local.
      )
    )
    (add-hook 'org-mode-hook 'my/when-emacs-org-file-tangle-on-save)
  )

#+end_src

** Cheatsheet :cheatsheet:
- Shift-Tab -> cycles through expanding headers. Can be used to fold all but the current item -> Shift-Tab to fold all, then Tab to unfold current item.
- structure templates (snippets) -> type "<snippetstringTAB" to expand it to snippet. e.g. "<el". Be faster than completion or reject it first with C-g.
- org-babel is org package (comes with org) that allows execution of code blocks, sharing data between code blocks (polyglot), tangling (exporting code into file / literal programming), ... .
- When in code block, to get full support for that language (proper completion, ...), open it in separate buffer with "C-c '" and do the editing there.

* My buffer/file functions

#+begin_src emacs-lisp

  (use-package emacs
    :ensure nil
    :config
    (defun my/alternate-buffer (&optional window)
      "Switch back and forth between current and last buffer in the current window."
      (interactive)
      (cl-destructuring-bind (buf start pos)
        (or (cl-find (window-buffer window) (window-prev-buffers) :key #'car :test-not #'eq)
            (list (other-buffer) nil nil)
        )
        (if (not buf)
          (message "Last buffer not found.")
          (set-window-buffer-start-and-point window buf start pos)
        )
      )
    )

    (defun my/open-init-file ()
      "Open the init file."
      (interactive)
      (find-file user-init-file)
    )

    (defun my/open-emacs-org-file ()
      "Open the init file."
      (interactive)
      (find-file (my/emacs-org-file-path))
    )

    (defun my/emacs-org-file-path ()
      (file-name-concat user-emacs-directory "Emacs.org")
    )

    (defun my/switch-to-messages-buffer ()
      "Switch to the messages buffer."
      (interactive)
      (switch-to-buffer "*Messages*")
    )
  )

#+end_src

* Ivy, counsel and swiper
** ivy

#+begin_src emacs-lisp

    ;; Ivy is the main thing (nice search through list of stuff, in minibuffer and elsewhere),
    ;; while Counsel and Swiper extend its usage through more of the Emacs.

    ;; TODO: Check out Ivy hydra -> I saw it in Ivy manual but don't know how to use it (it doesn't seem to be installed?).
    ;;   Allegedly (use-package ivy-hydra :after (ivy hydra)) should do the job? Try it.
    ;; TODO: Should I set Ivy to use fuzzy search? Is that better or not?
    ;; TODO: In Spacemacs (helm), coloring of listed files on C-x C-f is richer than I have in Ivy here.
    ;; Directories have stronger contrast, hidden files are grey, symbolic links neon, ... .
    ;; I should also get Ivy to behave like this! Right now it shows dirs in too similar color uses the same
    ;; color for all the rest.
    ;;   TODO: Show this cheatsheet somehow as part of Ivy buffers? Kind of like Helm does in Spacemacs?
    (use-package ivy
      :bind (
            ;; I define some evil-ish keybindings here since neither evil not evil-connection
            ;; define these specific ones for Ivy.
            :map ivy-minibuffer-map ;; When in the minibuffer.
                  ("C-h" . ivy-backward-kill-word)
                  ("C-j" . ivy-next-line)
                  ("C-k" . ivy-previous-line)
                  ("C-l" . ivy-alt-done)
                  ("TAB" . ivy-alt-done)
            :map ivy-switch-buffer-map ; When in the buffer switching mode.
                  ("C-j" . ivy-next-line)
                  ("C-k" . ivy-previous-line)
                  ("C-l" . ivy-done)
                  ("C-d" . ivy-switch-buffer-kill)
            :map ivy-reverse-i-search-map ; When doing incremental search.
                  ("C-j" . ivy-next-line)
                  ("C-k" . ivy-previous-line)
                  ("C-l" . ivy-done)
                  ("C-d" . ivy-reverse-i-search-kill)
            )
      :custom
      (ivy-height 20)
      (ivy-use-virtual-buffers t)  ; Adds recent files and bookmarks and similar to results.
      (ivy-display-style 'fancy)
      (ivy-count-format "(%d/%d) ")  ; (num listed / total num)
      (ivy-extra-directories nil)  ; Don't show ./ and ../
      :config
      ;; ivy-format-functions-alist determines for each place where ivy is used how the output should be formatted.
      ;; t stands for default case, if there was no more specific formatting function defined.

      ;; Here, we specify which formatting function to use as a default case (t).
      ;; We choose ivy-format-functon-line, that extends the higlight of selection to the edge of the window,
      ;; not just till the end of the selected word. This is one of default choices and it looks better.
      ;; This is recommended by ivy-rich, as a setting.
      (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-arrow-line)

      ;; ivy-re-builders-alist defines which completion styles (fuzzy, in order, ...) to use for which ivy usage.
      ;; Here I define that we use ivy--regex-ignore-order for all situations, instead of the default ivy--regex-plus,
      ;; which is the same but cares about the order of words in the query, which I found to not be useful.
      (setq ivy-re-builders-alist
            '((t . ivy--regex-ignore-order)))

      ;; ivy-initial-inputs-alist defines what to start specific searches with. Default is ^ for all searches,
      ;; which makes queries start from the start of each completion candidate, but I set it to nil to avoid that.
      (setq ivy-initial-inputs-alist nil)

      ;; This will enhance specific emacs commands with ivy automatically.
      (ivy-mode 1)
    )

#+end_src

*** Cheatsheet :cheatsheet:
- M-o when in an Ivy buffer shows extra commands that can be run on selected completion item.

** counsel

#+begin_src emacs-lisp

  ;; Counsel is a package that is part of Ivy ecosystem.
  ;; It brings enhanced versions of common emacs commands, powered by Ivy.
  ;; Ivy already offers some enhanced commands, but Counsel offers more and better.
  (use-package counsel
    :config
    (setq counsel-describe-function-function 'helpful-callable)
    (setq counsel-describe-variable-function 'helpful-variable)
    (counsel-mode 1)  ; This will remap the built-in Emacs functions that have counsel replacements.
  )

#+end_src

** swiper

#+begin_src emacs-lisp

  ;; Swiper is a package that is part of Ivy ecosystem.
  ;; Better isearch (incremental search), powered by Ivy.
  (use-package swiper
    :bind
    (("C-s" . swiper)
      :map evil-normal-state-map
        ("/" . swiper)
    )
  )

#+end_src

** ivy-rich

#+begin_src emacs-lisp

  ;; Show more info for some usages of Ivy. Also allows easier customization of Ivy output.
  (use-package ivy-rich
    :after (ivy counsel)
    :config
    ;; This is my custom function for how Ivy shows candidates when finding a file.
    ;; Unlike default function used by ivy(-rich), here I do some additional formatting:
    ;;  - I stylize dot(files/dirs).
    ;;  - I stylize executables.
    (defun my/ivy-read-file-transformer (filename)
      "Transform candidate STR when reading files."
      (let*
        ((current-dir (or (ivy-state-directory ivy-last) default-directory))
        (filepath (expand-file-name filename current-dir))
        (is-dir (ivy--dirname-p filename))
        (is-dotfile (string-prefix-p "." filename))
        (is-exec (file-executable-p filepath))
        )
        (cond
  	((and is-dir is-dotfile) (propertize filename 'face '(:inherit (font-lock-comment-face ivy-subdir))))
  	(is-dotfile (propertize filename 'face 'font-lock-comment-face))
  	(is-dir (propertize filename 'face 'ivy-subdir))
  	(is-exec (propertize filename 'face 'font-lock-keyword-face))
  	(t filename)
        )
      )
    )

    ;; With ivy-rich-set-columns, you can add new ones or replace existing columns when ivy is used in specific commands.
    ;; For details check out ivy-rich docs and docs of ivy-rich-display-transformers-list .
    (ivy-rich-set-columns
      'counsel-find-file  ; Set columns for this command (therefore when finding file).
      '((my/ivy-read-file-transformer)  ; Use my function instead of default ivy-read-file-transformer.
        (ivy-rich-counsel-find-file-truename (:face font-lock-doc-face))  ; This I kept the same. It adds target for links.
       )
    )

    (ivy-rich-mode 1)
  )

#+end_src

* Projectile

#+begin_src emacs-lisp
  
  ;; Projectile brings the concept of "Project" to emacs, as a project on the disk.
  (use-package projectile
    :init
    ;; First thing that happens on switching to a new project.
    ;; TODO: Try without this, see if I like that better or not, or if I would like something else.
    (setq projectile-switch-project-action #'projectile-dired)
    :bind-keymap
    ("C-c p" . projectile-command-map) ; TODO: Get this behind SPC.
    :custom
    ((projectile-completion-system 'ivy))
    :config
    (projectile-mode)
  )

  ;; Provides better integration of Projectile and Counsel.
  (use-package counsel-projectile
    :config
    (defun counsel-projectile-rg-region-or-symbol ()
      "Search for selected region if active, otherwise search for symbol at point using `counsel-projectile-rg`."
      (interactive)
      (let ((counsel-projectile-rg-initial-input (projectile-symbol-or-selection-at-point)))
          (counsel-projectile-rg)
      )
    )

    (counsel-projectile-mode)
  )

#+end_src

** Cheatsheet :cheatsheet:
- Projectile recognizes projects with its heuristics (.git/, maven files, ...), but you can add .projectile file to the project root to explicitly mark it as a project.

* Magit

#+begin_src emacs-lisp

  ;; NOTE: I installed transient not because I use it directly, but because magit
  ;;   needs a newer version of it than what comes with emacs by default, and this
  ;;   takes care of it. If magit at some point stops needing it, I can remove this.
  (use-package transient)

  ;; Magit is all you need to work with git.
  ;; TODO: I had to explicitly install new transient above to get magit to work because
  ;;   it expects a newer version than what emacs ships with. Once I update emacs
  ;;   or magit, drop the :after transient and remove (use-package transient) unless
  ;;   I also use it for something else.
  (use-package magit
    :after transient
    :defer t
  )

#+end_src

* Company

#+begin_src emacs-lisp

  ;; TODO: Fix highlight and search faces in tooltip/popup, or have theme that makes them nice. Company has faces that we can customize.
  ;; TODO: Either make scroll more visible, or use lines instead.
  (use-package company
    :custom
    (company-idle-delay 0.2)
    (company-minimum-prefix-length 1)
    (company-selection-wrap-around t)
    (company-format-margin-function 'company-text-icons-margin)
    (company-text-face-extra-attributes '(:weight semi-light :slant italic))
    ;; I found default icons (be it vscode or text) to be too hard to understand,
    ;; so I made my own mapping here that provides more info. For the context, icons are
    ;; short descriptions left of the completion candidates in the popup.
    (company-text-icons-mapping
    '((array          "   []" font-lock-type-face)
      (boolean        " bool" font-lock-builtin-face)
      (class          "class" font-lock-type-face)
      (color          "color" success)
      (constant       "const" font-lock-constant-face)
      (constructor    "cnstr" font-lock-function-name-face)
      (enum-member    "enumv" font-lock-builtin-face)
      (enum           " enum" font-lock-builtin-face)
      (field          "field" font-lock-variable-name-face)
      (file           " file" font-lock-string-face)
      (folder         "  dir" font-lock-doc-face)
      (interface      " intf" font-lock-type-face)
      (keyword        "  kwd" font-lock-keyword-face)
      (method         " mthd" font-lock-function-name-face)
      (function       " func" font-lock-function-name-face)
      (module         "  mdl" font-lock-type-face)
      (numeric        "  num" font-lock-builtin-face)
      (operator       "   op" font-lock-comment-delimiter-face)
      (property       " prop" font-lock-variable-name-face)
      (reference      "  ref" font-lock-doc-face)
      (snippet        " snip" font-lock-string-face)
      (string         "  str" font-lock-string-face)
      (struct         "strct" font-lock-variable-name-face)
      (text           " text" shadow)
      (type-parameter "typep" font-lock-type-face)
      (unit           " unit" shadow)
      (value          "  val" font-lock-builtin-face)
      (variable       "  var" font-lock-variable-name-face)
      (t              "    ." shadow))
    )
    :config
    (global-company-mode 1)
  )

#+end_src

** TODO Find a way to also show additional docs next to each item. E.g. company-box
But company-box currently overrides my setting for company-text-icons-mapping with its icons and is for some reason slow.

** Cheatsheet :cheatsheet:
- C-s to search among the candidates. C-M-s to not just highlight but also filter. C-g to quit search mode.
  
* Flycheck

#+begin_src emacs-lisp

  (use-package flycheck
    :init (global-flycheck-mode)
    :custom
    (flycheck-display-errors-delay 0.2)
  )

  ;; Shows flycheck errors/warnings in a popup, instead of a minibuffer which is default.
  (use-package flycheck-posframe
    :after flycheck
    :custom
    (flycheck-auto-display-errors-after-checking nil) ; Prevents repeated displaying of errors at point.
    (flycheck-posframe-border-width 10)
    :config
    (add-hook 'flycheck-mode-hook 'flycheck-posframe-mode)
    (flycheck-posframe-configure-pretty-defaults)
  )

#+end_src

** TODO Improve how errors/warnings are shown
By default, flycheck shows errors/warnings in a minibuffer. It doesn't color them however, they are just white, and quite bland looking.
A way to improve those is to override the value of ~flycheck-display-errors-function~ with a function that will display the errors. They don't give much default options, only displaying them in the minibuffer which is the default.
I tried flycheck-pos-tip which is official extra package by flycheck taht shows errors in a popup, but it didn't work great / I didn't konw how to customize it.
Now I am trying out flycheck-posframe, but it is also not perfect, there is some flickering, and it feels a bit sluggish and I can't configure it still as much as I would like.
I should figure out what others do, what is the best way to go about it. There must be some approach that most people use that is nice.
Btw what is confusing to me is that reading the FlyCheck docs, it seems like it should be creating a GUI tooltip upon cursor (mouse). But it doesn't for me. I wonder if that is due to lsp-ui and its docs, some kind of conflict there?
Maybe I should just look into how flycheck-posframe is implemented and implement it on my own based on it?
One possibility is also to try Flymake!
** TODO Try Flymake
Flymake is emacs native checker, and long time flycheck was much better, but recently they improved flymake, revamped it.
Reading its docs, it actually makes more sense to me than flycheck. So I think I should give it a try.
Might also be worthy trying it with eglot!

* Development
** LSP

LSP as a general protocol has some of its own nomenclature. Some of it that is useful to know to better understand the config below, is how they name the most important information that LS returns.
 - =hover= info: Documentation about the symbol/function/thing under the cursor that LS sends.
 - =diagnostics=: Errors, warnings, info, that LS reports.
 - =code actions=: actions that LS suggests and that you can then ask it to execute. E.g. add missing import.

Rough summary how my configuration currently displays all this info:
 - Parts of code with diagnostics are marked with **squiggly lines** (by Flycheck).
 - **Short version of hover** info for a symbol is shown on cursor/mouse, in the minibuffer (by ~eldoc~).
 - **Full version of hover** info for a symbol under cursor is displayed in a popup, on demand, which I trigger with "K" or "?" (by ~lsp-ui-doc~).
 - Full info on **diagnostics** for a symbol is shown on cursor/mouse (by ~flycheck~, in a popup).
 - Only "quickfix" **code actions** for a symobl are shown on cursor/mouse, on the right side of the screen next to the code (by ~lsp-ui-sideline~).

#+begin_src emacs-lisp

  (use-package lsp-mode
    :init
    (setq lsp-keymap-prefix "C-c l") ;; TODO: Set it to ",". I tried but it didn't work, I guess evil overrides it.
    (setq lsp-use-plists t) ; Recommended performance optimization. Requires setting env var (check early-init.el block below).
    :hook (lsp-mode . lsp-enable-which-key-integration)
    :commands (lsp lsp-deferred)
    :custom
    ;; lsp-modeline is about showing "stats" in the modeline: number of errors, warnings, code actions.
    ;; Useful for languages where compilation might be broken due to errors in other files (e.g. Java, Haskell).
    (lsp-modeline-diagnostics-enable t) ; Show info about diagnostics (errors, warnings, ...) in the modeline.
    (lsp-modeline-diagnostics-scope :workspace) ; Whole project and not just this file.
    (lsp-modeline-code-actions-enable t) ; Show info about code actions in the modeline.

    ;; eldoc is the most "native" way for emacs to display docs for a thing under cursor.
    ;; It displays information about the thing under cursor/mouse in the minibuffer.
    ;; Here we tell lsp-mode to use eldoc to display "hover" lsp info (which is docs for function/symbol).
    (lsp-eldoc-enable-hover t)
    ;; Don't show all the info in minibuffer on hover, instead show only most basic info (what it is, type).
    ;; Otherwise, there is too much noise and jumping of minibuffer up and down.
    ;; If I want full docs for a thing under cursor, I will rather summon it manually: I use lsp-ui-docs-toggle for that and have bound it to "?" -> check lsp ui config for details.
    (lsp-eldoc-render-all nil)

    ;; At the top of the file, show info about the position of the cursor (path, module, symbol, ...).
    (lsp-headerline-breadcrumb-enable t)
    (lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))

    (lsp-semantic-tokens-enable t) ; Richer highlighting (e.g. differentiates function symbol from var symbol).
  )

#+end_src

#+begin_src emacs-lisp :tangle ./early-init.el

  (setenv "LSP_USE_PLISTS" "true") ; Recommended performance optimization.

#+end_src

*** LSP UI

Official extension for lsp-mode that brings the nice UI features, mostly for displaying info returned by LS.
It is common to use it next to lsp-mode.
It can show information in two main ways: via ~lsp-ui-doc~ popup, or inline via ~lsp-ui-sideline~.

#+begin_src emacs-lisp

  (use-package lsp-ui
    :after (lsp-mode evil)
    :commands lsp-ui-mode
    :custom
    ;; Show "hover" documentation for a thing under cursor/pointer in a popup.
    (lsp-ui-doc-enable t)
    ;; I don't want it to popup constantly as I move around, instead I want to summon it when I need it.
    ;; That is why below I define "?" as a key for toggling it.
    (lsp-ui-doc-show-with-cursor nil)
    ;; If I hover with a mouse, then do show the docs, that is not too intrusive.
    (lsp-ui-doc-show-with-mouse t)
    ;; Show the docs next to the cursor/point.
    (lsp-ui-doc-position 'at-point)
    (lsp-ui-doc-include-signature t)

    ;; lsp-ui-sideline shows info that you want (e.g. diagnostics, code actions, ...)
    ;; on the right side of the window, inline with the code.
    (lsp-ui-sideline-enable t)
    ;; If diagnostics are longer and in multiple lines, it becomes a mess, it doesn't align them nicely
    ;; and they are all over the place, really hard to read, which is why I disabled showing diagnostics
    ;; in the sideline.
    ;; When you disable it, lsp-mode instead sends diagnostics to flymake/flycheck, which by default show
    ;; then in the minibuffer.
    (lsp-ui-sideline-show-diagnostics nil)
    (lsp-ui-sideline-show-hover nil) ; This I already show in minibuffer (eldoc) or in popup (lsp-ui-doc).
    (lsp-ui-sideline-show-symbol nil) ; This I didn't find useful.
    (lsp-ui-sideline-show-code-actions t) ; But I do find it useful to see code actions.
    (lsp-ui-sideline-actions-kind-regex "quickfix.*") ; Show only quickfix code actions, otherwise it is too much noise.
    :config
    (general-define-key :states '(normal visual)
                        :keymaps 'lsp-mode-map
                        "?" 'lsp-ui-doc-glance ; TODO: This is sometimes being overshadowed with ? from evil mode, fix that.
                        "F" 'lsp-ui-doc-focus-frame
    ) 
    (setq evil-lookup-func 'lsp-ui-doc-glance)
  )

#+end_src

*** Misc

#+begin_src emacs-lisp

  ;; Brings lsp-ivy-workspace-symbol that searches for a symbol in project as you type its name.
  ;; TODO: Add a keybinding, under lsp-keymap-prefix, for this command, I guess under goto? So ", g s"?
  (use-package lsp-ivy :commands lsp-ivy-workspace-symbol)

  ;; Shows list of all errors in a nice treemacs fashion.
  (use-package lsp-treemacs :commands lsp-treemacs-errors-list)

#+end_src

*** TODO Use lsp-booster
- https://www.ovistoica.com/blog/2024-7-05-modern-emacs-typescript-web-tsx-config#orgf6d33f7 -> search for lsp-booster
*** TODO LSP's completion-at-point -> how to get that working with Company properly?
- https://emacs-lsp.github.io/lsp-mode/page/settings/completion/ -> useful?
** TODO Set up Treesitter?
Treesitter is for syntax highlighting / process what is LSP for semantic understanding of the code.
You could say that Treesitter brings syntax-level understanding, while LSP brings semantic-level understanding.
Same like LSP, Treesitter removes the burden from the specific editor to implement all the logic related to dealing with syntax, and instead any editor can just leverage the one central implementation of it: Treesitter + corresponding treesitter grammar for specific language.

- Emacs 29 brings its own built-in treesitter package and I see that I have it in my installation of emacs.
  What is left though is to tell it which grammars to pull for which language, and then also to get the major language modes to use the treesitter for their specific languages.
  - https://www.masteringemacs.org/article/how-to-get-started-tree-sitter
  - https://www.ovistoica.com/blog/2024-7-05-modern-emacs-typescript-web-tsx-config#orgf6d33f7
- It does seem that getting it to work for Haskell won't be easy, haskell-mode doesn't know how to use treesitter,
and haskell-ts-mode, which is a new mode that somebody made that should replace haskell-mode but with ts support,
has much less features than haskell-mode and is less mature. But maybe that is ok and worth trying? Do I use any of
advanced haskell-mode features anyway?
  - https://codeberg.org/pranshu/haskell-ts-mode

Maybe using treesitter is not so urgent and I should wait for better support in popular major modes.

** TypeScript
NOTE: I chose ts-ls as a language server, when asked.

#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . lsp-deferred)
    :config
    (setq typescript-indent-level 2)
  )
#+end_src

*** TODO Follow this reddit guide on how to set up IDE for TypeScript:  https://www.reddit.com/r/emacs/comments/1dwl8v0/modern_emacs_typescript_web_react_config_with/ 

*** TODO Add support for TSX
- There is tsx-mode.el.
- There is tide.
- Check what they do in Spacemacs/Doomemacs.
** Haskell

#+begin_src emacs-lisp

  (use-package haskell-mode
    :hook
    (haskell-mode . lsp-deferred)
    (haskell-literate-mode . lsp-deferred)
    :custom
    (haskell-indentation-layout-offset 4)
    (haskell-indentation-starter-offset 4)
    (haskell-indentation-left-offset 4)
    (haskell-indentation-where-pre-offset 2)
    (haskell-indentation-where-post-offset 2)
  )

  ;; Teaches lsp-mode how to find and launch HLS (Haskell Language Server).
  (use-package lsp-haskell)

  ;; NOTE: Requires ormolu to be installed on the machine.
  (use-package ormolu
    :hook (haskell-mode . ormolu-format-on-save-mode)
  )

#+end_src

*** Cheatsheet :cheatsheet:
- haskell-mode brings interactive mode where you get a ghci session in which you can easily load specific files and run stuff from them. To start it, run `interactive-haskell-mode`. File is added to it by ~haskell-process-load-file~ while in a Haskell file buffer.
- Haskell mode registers its keymap under "C-c", so check that for common commands.

** TODO Web (HTML, CSS, ...)
  - Check what they do in Spacemacs/Doomemacs.
* Misc

#+begin_src emacs-lisp

  ;; Primarily supposed to be used with visual-line-mode (which is emacs builtin that soft wraps the line at window end).
  ;; visual-fill-column, when used with visual-line-mode, modifies the wrapping to happen at the fixed (by default fill-column) width,
  ;; instead of at the window end.
  ;; It can also center the text.
  ;; Useful for making the buffer look "document" like.
  (use-package visual-fill-column)

#+end_src

#+begin_src emacs-lisp

  ;; This makes copy/paste properly work when emacs is running via the terminal.
  (use-package xclip
    :config
    (xclip-mode 1)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Allows fast jumping inside the buffer (to word, to line, ...).
  (use-package avy)

#+end_src

#+begin_src emacs-lisp

  ;; Allows jumping to any window by typing just a single letter.
  (use-package ace-window)

#+end_src

#+begin_src emacs-lisp

  ;; This package gives me commands to jump to a window with specific number (ace-window doesn't do that).
  (use-package winum
    :config
    (winum-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Remembers last used commands and puts them on top of M-x's list of commands.
  ;; Integrates seamlessly with Ivy/Counsel, Ido and some other.
  (use-package amx)

#+end_src

#+begin_src emacs-lisp

  ;; Highlight TODO and similar keywords in comments and strings.
  (use-package hl-todo
    :config
    (global-hl-todo-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; Utility package that provides nice icons to be used in emacs, by other packages.
  ;; NOTE: The first time you load your config on a new machine, you'll have to
  ;; run the following command interactively:
  ;; M-x all-the-icons-install-fonts
  (use-package all-the-icons)

#+end_src

#+begin_src emacs-lisp

  ;; Enhances built-in Emacs help with more information: A "better" Emacs *Help* buffer.
  (use-package helpful
    :defer t
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    (([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key)
    ("C-h h" . helpful-at-point)
    )
  )

#+end_src

#+begin_src emacs-lisp

  ;; Colorizes color names in buffers.
  ;; Works better than clasical rainbow-mode, which would mess up Help buffer for me.
  (use-package colorful-mode
    :config
    (add-to-list 'global-colorful-modes 'help-mode)
    (global-colorful-mode)
  )

#+end_src

#+begin_src emacs-lisp

  ;; It colors each pair of parenthesses into their own color.
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode)
  )

#+end_src

#+begin_src emacs-lisp
  ;; Brings functions for converting buffer text and decorations to html.
  (use-package htmlize)
#+end_src

* Cheatsheet :cheatsheet:

- M-: -> eval in echo buffer

- check-parens -> find unbalanced parenthesses in the buffer

- C-h -> help! find out about v (variable), f (function), face, ... .
- C-h h -> help for symbola at point.

- m <char> -> set mark
- ` <char> -> go to mark
- ` ` -> go to last mark

Troubleshooting:
- package couldn't be found (upon install) -> local packages archive is old, run `list-packages` to update it.

* TODOs
** A must
*** TODO Set up Company, Flycheck, LSP and LSP-UI.

Flycheck and LSP-UI overlap a bit, so I will likely want to configure them so they don't display same stuff -> confiugre just one of them to display LSP diagnostics. I can maybe start with flycheck, and then add LSP-UI and see who I like better doing what.

*** TODO Use emacs-lsp-booster with lsp-mode, to speed it up / avoid freezes.
*** TODO Write down following next to lsp-mode
I investigated lsp-mode vs eglot. Eglot natively comes with emacs and is alternative to lsp-mode. Claims to have better code and be faster, but lsp-mode seems to be bigger and more featureful, so it is really not clear at all which is better. I think I will be sticking to lsp-mode for now, people seemed to report more issues with eglot, and lsp-mode I know works well. I can try eglot at some point.

*** TODO Set up TypeScript (TS) support
https://www.ovistoica.com/blog/2024-7-05-modern-emacs-typescript-web-tsx-config
- especially the treesitter!
*** TODO Set up Haskell support
*** TODO Set up AI support
- GPTel
- Elysium
- Aider.el (https://www.reddit.com/r/emacs/comments/1fwwjgw/introduce_aider_ai_programming_in_terminal_and/)
- chatgpt-shell
- evedel
- copilot.el
- Using LLMs in Emacs: https://blog.aheymans.xyz/post/llm_in_emacs/
- https://www.reddit.com/r/emacs/s/g5deSIDOUZ
- https://www.reddit.com/r/emacs/s/tSCyJdXkJW
- RAG in emacs: https://www.reddit.com/r/emacs/s/YSoLgzSuRd
- https://www.reddit.com/r/emacs/s/6hlCzJ8GQq
- Should I look into using PrivateGPT? With RAG that has Wasp docs in it for example?
  
** Should do
*** TODO Take care of the temporary files being created by emacs and undo.
*** TODO Add whitespace mode (or smth like that)
*** TODO Figure out how to pin down package versions (lockfile / freezing).

Search a bit how others do package version pinning down. There is :pin for use-package, but I am nto sure if that is what I need.

*** TODO Add a nice splash screen

With recent projects and recent files and maybe an inspirational quote? Check out emacs-dashboard.

*** TODO I will want some way to easily restore where I stopped working.

Maybe some presets -> e.g. quick loading of waspc project with certain file opened. Or maybe just from where I stopped.

*** TODO Go through my spacemacs config and copy stuff I liked from there.
*** TODO Take care of TODOs in org-present config.
*** TODO Set up shell, below is my spacemacs setup:

;; Make it so that in shell (vterm) C-p acts as "up" and C-n acts as "down", same like in external terminals.
;; NOTE: For insert mode it already works like this, but I also wanted it to work the same way for the normal mode.
(with-eval-after-load 'vterm
  (evil-define-key 'normal vterm-mode-map (kbd "C-p") 'vterm-send-up)
  (evil-define-key 'normal vterm-mode-map (kbd "C-n") 'vterm-send-down)
)
(shell :variables
    shell-default-shell 'vterm ;; Fastest and best terminal emulator currently avaiable for emacs.
    shell-default-width 50
    shell-default-position 'right
    spacemacs-vterm-history-file-location "~/.bash_history"
    )

*** TODO Stop that custom block from appearing at the end of this file.
*** TODO Look into workgroups
*** DONE Implement transient yanking
So I can go through the kill ring, like in spacemacs. counsel-yank-pop might be useful? Or should I implement my own hydra?
There is counsel-yank-pop, to nicely choose from the kill ring.
So what I want is once yank is done, to be offered something like hydra, so transient keys, that allow to easily rotate to through kill ring.
In spacemacs, it activates Pasting Transient State, where [C-j/C-k] cycles through yanked text, [p/P] pastes the same text above or below, [C-v] creates a visual selection from last paste and exits. Anything else exits.
I really need only cycling.
Maybe I can just offer a hydra that has one key, maybe "/", that opens counsel-yank-pop. That way, "p/" becomes "advanced" yank. It could also offer C-j and C-k next to it.
Actually, this already works hm! C-p gives previous (evil-paste-pop), C-n gives next (evil-paste-pop-next), that is evil thing. But it is not hydra. So maybe just make a hydra that mentions these + a way to start counsel-yank-pop.
*** DONE Use native installation of emacs.
*** DONE Organize general.el, which-key, hydra, evil under Keybindings header.
*** DONE How to split use-package into multiple blocks, in Org babel blocks?
 - SO: including snippets: https://emacs.stackexchange.com/questions/78624/splitting-use-package-declarations-in-literate-config
 - System Crafters: they use =(with-eval-after-load 'some-package ...)= to do extra config stuff. This is most reasonable solution probably.

** Going beyond
*** TODO Read [[https://www.reddit.com/r/emacs/s/mnpkOjzbOT][Article with nice explanation of IDE packages (lsp, dap, ...)]]
*** TODO Check out Prot's basic [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/][emacs config]]
*** TODO Try using command pallete
Similar to what VSCode has, and Sublime Text made popular. Also similar to vim telescope.
So instead of showing everything down there in the minibuffer, show some stuff in the command pallete at the top / middle of the screen.
I am not sure if I will like this or not, but I think it is worth trying it out.
- ivy-posframe package -> just for ivy completions
- emacs-miniframe -> for anything happening in the minibuffer
*** TODO Try Nano theme.
*** TODO Enable that new smooth/pixel scroll setting in emacs?
*** TODO Use smartparens or electric-pair-mode?
*** TODO Take a look at dogears.el -> sounds potentially useful, not sure though.
*** TODO symbol-overlay, multiple-cursors, and their [[https://lmno.lol/alvaro/its-all-up-for-grabs-and-it-compounds][combo]].
*** TODO Make is so that init.el and early-init.el are read only by default?
I could, in org-mode-hook, check buffer-file-name, and if it is one of these two files,
make them read only by default.
*** TODO Check out how System Crafters organized their Emacs.org
*** TODO Learn some Org keybindings / tricks
- [ ] How can I easily hide / fold / show current header and its parents?
- [ ] How can I easily navigate through headers?
- [ ] How can I increase/decreaese level of whole hierarchy/region of headers?
      A: Seems like that is done with M-<left> or M-<right>
*** TODO Improve my Org faces / look.
- [ ] Better way to communicate that header is collapsed (something more visible than three dots).
- [ ] Give a try at non-monospace font for not-code (check System Crafters video).
   - Fixed-pitch font: JetBrains Mono, light weight.
   - Variable-pitch font: Iosevka Aile, light weight.
- [ ] Play with toggling org-indent and org-bullets.
*** TODO Add "SPC j" prefix for "jump" and then put jump/goto commands under that?.
Or, go for "SPC g" and move magit to "SPC a g"? I think I should move magit there in any case, to free up "SPC g".
Stuff I could put under "SPC j" (or "SPC g") is avy/ace jumping around the file/window, stuff like "counsel-imenu" that lets me move around the definitions in file, ... .
Hm or it could even be "SPC n" for navigation? Maybe that is the best one, it is broad and niche enough at the same time.
Of course I would still keep some specific navigation like window or buffer under buffer/window prefixes, while I would put more general stuff here.
Or, maybe I don't need "SPC j" and I should just organize navigating by domain? So jumping around file -> under "SPC f". Jumping around the window -> under "SPC w". Counsel-imenu -> under "SPC b" or "SPC f".

*** TODO Look into [[https://github.com/karthink/popper][popper]] -> specify which buffers should appear in a popup
*** TODO Does emacs have this thing where you can easily get a list of keybindings to do stuff specific for current major mode?
I think it is something like "." or ","? If yes, copy that if I can, if not, it would be nice to have that, or if not that, then some other way where I can easily figure out the main commands for this major mode (e.g. org). I konw there is C-h m, but that has too much noise for me usually.
I know that some modes (e.g. Org) have keymaps, and I see Orgs keymap mapped to C-c. Maybe that is it, the convention? I just need to add additional map to what C-c maps to?

*** TODO Check this emacs eyecandy post for good ideas
https://lmno.lol/alvaro/my-emacs-eye-candy
*** TODO Hint system
I would love to show some kind of hints in certain situations. Couple of useful keybindings when I am in some context. Kind of like Helm in Spacemacs shows it at that footer it has. Maybe some text also.
But for Ivy. Also, for stuff like company when in completion popup, to remind me of C-s and C-M-s. What if I had an area in my emacs where contextual tips are shown as you do some actions?
For example they get shown when you open completion popup, or when you start using Ivy? Could I make this a universal mechanism? Maybe I can expand it then for a bit more info if I want,
for my custom cheasheet? It would be kind of a "publish" mechanism I guess.
Btw I started, in this org document, having headers with :cheatsheet: tag, where I collect these "cheatsheets".

Ok, so refinement of the idea:
- I implement logic that, at current moment, determines what the context is. Looks at buffer name, thing at point, major mode, couple of things like that. This is the core of things.
- Then, I allow them to connect pieces of .org markup with specific contexts. For example, they can say "this piece of .org markup will be a hint for any context with this buffer name (and or this major mode, this minor mode, ...)". How do they do that? I imagine that in some .org file, they put a property under PROPERTIES that describes to which context does this header attach. I could imagine they can specify it narrower or wider: each condition they add is combined via AND with the rest of the conditions that describe a context.
  This also means they would need to specify which org file(s) to search in for these hints.
- I implement a command `hints-show` that recognizes current context and based on it displays relevant hints. They are using .org markup so I imagine it would show them in a readonly org buffer, that was somehow produced by adding all hints that are connected with this context.
- For easier usage, I should also implement a function `hints-add` that recognizes current context, and then based on it creates a new entry in the .org file that is used for hints (if there are multiple, it can ask which one you want to add this to). I can also ask if you want to reuse existing entry, if such entry exists. This would make it easier to add new hints easily, exactly in the situation where you want to see them. I wonder if orgs capture templates would be of any help here.
- Might also be convenient to have `hints-context` which just shows current context. It could be useful in some situations, when debugging.
- Possible fun name for package: intel! Intel for the context. int.el .
  
*** TODO Try replacing Ivy, Counsel, Swiper, and Company even, with Vertico, Marginalia, Orderless, Embark, Corfu, ...
Vertico is alternative to Ivy, the rest are supporting packages for it same like Counsel and Swiper are for Ivy, and then Corfu is a replacement for Company.
Seems like a lot of people like Vertico, ... , Corfu and the rest. Allegedly they using more of native Emacs stuff, so are simpler but also make more sense? Hm.
Embark seems great, it is a quite unique package: the idea is that you have a keybinding for it and then whenever you are doing something, you hit that keybinding and Embark
offers you actions that you can do in that situation / with that thing. It does however work best if Marginalia is used, because it gives it more context on stuff, and Marginalia
works best with the rest of the stuff above, so it kind of pulls one another hm, so it probably makes sense to try to go for all of it at once.

*** TODO To figure out what packages to install, I should take a look at what Doomemacs, Spacemacs (and their layers), Emacs-bedrock, and others, use, for inspiration, and how they have it configured.

- [ ] Check out bedrock emacs, simple starting config but has good stuff allegedly: https://sr.ht/~ashton314/emacs-bedrock/ .
- [ ] Check out config by this Prot guy, people say it is good: https://protesilaos.com/emacs/dotemacs .
- [ ] Another emacs config to check out, kickstarter for neovimers, might have some good stuff for evil: https://github.com/LionyxML/emacs-kick . I also saw it uses vertico, marginalia, ... .
- [ ] Check out Zuzic's emacs config: https://mail.google.com/mail/u/0/#all/KtbxLwHDghsHQDzKGkxWCWmFZsNSCGcHQq

*** TODO Learn more about Avy: https://karthinks.com/software/avy-can-do-anything/ .
*** TODO Read more about other [[https://www.reddit.com/r/emacs/comments/1gux2bi/org_search_vs_organization/?share_id=f51nt5J93w5gxGj6rjjqm&utm_content=1&utm_medium=android_app&utm_name=androidcss&utm_source=share&utm_term=10][people's org workflows]]: 
